{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/date-select.js","js/dist/components/js/dist/components/select-input.js","js/dist/components/js/dist/helpers/animation/height.js","js/dist/components/js/dist/helpers/date/date.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/make-element.js","js/dist/components/js/dist/helpers/dom/outer-height.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/mixin.js","js/dist/components/js/dist/helpers/util/trim.js","js/dist/components/js/dist/mixins/messaging.js","js/dist/components/js/dist/mixins/validation.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"date-select.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _selectInput = require('./select-input');\n\nvar _selectInput2 = _interopRequireDefault(_selectInput);\n\nvar _date = require('../helpers/date/date');\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # DateSelect\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Create a select list of days, months or years.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new DateSelect(el);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/date-select.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nfunction createDefaultElement() {\n  var el = document.createElement('span');\n  el.className = 'spark-select';\n  el.innerHTML = '<select class=\"spark-select__input\"></select><span class=\"spark-label\"></span>';\n  return el;\n}\n\nvar DateSelect = function (_BaseComponent) {\n  _inherits(DateSelect, _BaseComponent);\n\n  /**\n   * DateSelect constructor\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n  function DateSelect(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DateSelect);\n\n    // If the first argument is a plain object, create a default element\n    // since the user MUST provide additional params but the element\n    // is optional. Doing it this way to keep the arity the same\n    // as other components.\n    if (!(el instanceof HTMLElement)) {\n      params = el || {};\n      el = createDefaultElement();\n    }\n\n    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params));\n\n    _this._bindEventListenerCallbacks();\n    _this._createSelect(el);\n    return _this;\n  }\n\n  /**\n   * Get the value.\n   * @param {Boolean} asInt Get the value as a parsed integer.\n   * @return {Mixed}\n   */\n\n\n  DateSelect.prototype.getValue = function getValue(asInt) {\n    return asInt ? parseInt(this.select.getValue(), 10) : this.select.getValue();\n  };\n\n  /**\n   * Set the value.\n   * @param {Mixed} val\n   */\n\n\n  DateSelect.prototype.setValue = function setValue(val) {\n    return this.select.setValue(val);\n  };\n\n  /**\n   * Clear the value.\n   */\n\n\n  DateSelect.prototype.clearValue = function clearValue() {\n    return this.select.clearValue();\n  };\n\n  /**\n   * Enable the input.\n   */\n\n\n  DateSelect.prototype.enable = function enable() {\n    return this.select.enable();\n  };\n\n  /**\n   * Disable the input.\n   */\n\n\n  DateSelect.prototype.disable = function disable() {\n    return this.select.disable();\n  };\n\n  /**\n   * Update the date select's options.\n   * @param {Object|Array} params\n   */\n\n\n  DateSelect.prototype.setOptions = function setOptions(params) {\n\n    params = params || {};\n\n    this.min = params.min || this.min;\n    this.max = params.max || this.max;\n    this.monthNames = params.monthNames || this.monthNames;\n    this.numericMonth = params.numericMonth || this.numericMonth;\n\n    if (this.type === 'year') {\n      if (params.min && !params.max) {\n        this.max = this.min + 100;\n      } else if (params.max && !params.min) {\n        this.min = this.max - 100;\n      }\n    }\n\n    var i = this.min ? this.min - 1 : 0;\n    var len = this.max || this.monthNames.length;\n    var opts = [{}];\n\n    for (; i < len; i++) {\n      opts.push({\n        value: i + 1,\n        text: this.monthNames ? this.monthNames[i] : i + 1\n      });\n    }\n\n    this.select.setOptions(opts);\n\n    return this;\n  };\n\n  /**\n   * Set the label text for the select input.\n   * @param {String} text Optional\n   */\n\n\n  DateSelect.prototype.setLabel = function setLabel(text) {\n    this.select.setLabel(text !== undefined ? text : this._getTypeText());\n    return this;\n  };\n\n  /**\n   * Create a select input helper.\n   * @param {Object} el\n   */\n\n\n  DateSelect.prototype._createSelect = function _createSelect(el) {\n\n    this.select = new _selectInput2.default(el, {\n      onChange: this._onSelectChangeBound,\n      onFocus: this._onSelectFocusBound,\n      onBlur: this._onSelectBlurBound\n    });\n\n    this.setOptions();\n    this.setLabel();\n  };\n\n  /**\n   * Cache elements.\n   * @param {Element} el\n   */\n\n\n  DateSelect.prototype._cacheElements = function _cacheElements(el) {\n    this.el = el;\n    this.selectEl = this.el.querySelector('select');\n  };\n\n  /**\n   * Parse parameters from the elements.\n   */\n\n\n  DateSelect.prototype._parseParams = function _parseParams() {\n\n    this.type = this.type !== null ? this.type : (0, _parseAttribute.string)(this.selectEl, 'data-type', 'day');\n\n    if (this.type === 'year') {\n      var date = new Date();\n      this.min = this.min !== null ? this.min : (0, _parseAttribute.number)(this.selectEl, 'min', date.getFullYear() - 100);\n      this.max = this.max !== null ? this.max : (0, _parseAttribute.number)(this.selectEl, 'max', (this.min || date.getFullYear()) + 100);\n    } else if (this.type === 'month') {\n\n      this.monthNames = this.monthNames !== null ? this.monthNames : (0, _parseAttribute.string)(this.selectEl, 'data-month-names', null);\n      this.numericMonth = this.numericMonth !== null ? this.numericMonth : (0, _parseAttribute.boolean)(this.selectEl, 'data-numeric-month', false);\n      this.min = this.min !== null ? this.min : (0, _parseAttribute.number)(this.selectEl, 'min', null);\n      this.max = this.max !== null ? this.max : (0, _parseAttribute.number)(this.selectEl, 'max', null);\n\n      // No monthNames yet and no min or max\n      if (!this.monthNames && !this.numericMonth && !this.min && !this.max) {\n        this.monthNames = this._getDefaultMonthNames();\n      } else if (!this.min && !this.max) {\n        this.min = 1;\n        this.max = 12;\n      }\n\n      if (typeof this.monthNames === 'string') {\n        this.monthNames = this.monthNames.split(',');\n      }\n    } else {\n      this.min = this.min !== null ? this.min : (0, _parseAttribute.number)(this.selectEl, 'min', 1);\n      this.max = this.max !== null ? this.max : (0, _parseAttribute.number)(this.selectEl, 'max', 31);\n    }\n  };\n\n  /**\n   * Make a list of month options.\n   * @return {Array}\n   */\n\n\n  DateSelect.prototype._getDefaultMonthNames = function _getDefaultMonthNames() {\n    return _date2.default.getMonthNamesShort();\n  };\n\n  /**\n   * Get the text for this type of date select.\n   * @return {String}\n   */\n\n\n  DateSelect.prototype._getTypeText = function _getTypeText() {\n    return this.type.charAt(0).toUpperCase() + this.type.slice(1);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  DateSelect.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onSelectChangeBound = this._onSelectChange.bind(this);\n    this._onSelectFocusBound = this._onSelectFocus.bind(this);\n    this._onSelectBlurBound = this._onSelectBlur.bind(this);\n  };\n\n  /**\n   * When the select changes, run the callback.\n   * @param {String} val The value of the input\n   */\n\n\n  DateSelect.prototype._onSelectChange = function _onSelectChange(val) {\n    (this.onChange || noop)(val, this);\n  };\n\n  /**\n   * When the select changes, run the callback.\n   * @param {String} val The value of the input\n   */\n\n\n  DateSelect.prototype._onSelectFocus = function _onSelectFocus(val) {\n    (this.onFocus || noop)(val, this);\n  };\n\n  /**\n   * When the select changes, run the callback.\n   * @param {String} val The value of the input\n   */\n\n\n  DateSelect.prototype._onSelectBlur = function _onSelectBlur(val) {\n    (this.onBlur || noop)(val, this);\n  };\n\n  return DateSelect;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nDateSelect.prototype._whitelistedParams = ['type', 'monthNames', 'numericMonth', 'min', 'max', 'onChange', 'onFocus', 'onBlur'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nDateSelect.prototype.defaults = {\n  el: null,\n  selectEl: null,\n  type: null,\n  monthNames: null,\n  min: null,\n  max: null,\n  select: null,\n  numericMonth: null,\n  onChange: null,\n  onFocus: null,\n  onBlur: null,\n  _onChangeBound: null,\n  _onFocusBound: null,\n  _onBlurBound: null\n};\n\nexports.default = DateSelect;\nmodule.exports = exports['default'];\n//# sourceMappingURL=date-select.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _mixin = require('../helpers/util/mixin');\n\nvar _mixin2 = _interopRequireDefault(_mixin);\n\nvar _messaging = require('../mixins/messaging');\n\nvar _messaging2 = _interopRequireDefault(_messaging);\n\nvar _validation = require('../mixins/validation');\n\nvar _validation2 = _interopRequireDefault(_validation);\n\nvar _makeElement = require('../helpers/dom/make-element');\n\nvar _makeElement2 = _interopRequireDefault(_makeElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # SelectInput\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * A select input container.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new SelectInput(el);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/select-input.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar SelectInput = function (_BaseComponent) {\n  _inherits(SelectInput, _BaseComponent);\n\n  /**\n   * SelectInput constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function SelectInput(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, SelectInput);\n\n    params.elRequired = true;\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Get the value.\n   * @return {String}\n   */\n\n\n  SelectInput.prototype.getValue = function getValue() {\n    return this.selectEl.value;\n  };\n\n  /**\n   * Set the value.\n   * @param {String|Number} val\n   */\n\n\n  SelectInput.prototype.setValue = function setValue(val) {\n\n    // Cast to a string for comparison\n    val = val + '';\n\n    var i = 0;\n    var len = this.selectEl.children.length;\n\n    for (; i < len; i++) {\n      if (this.selectEl.children[i].value === val) {\n        this.selectEl.children[i].selected = true;\n        this._updateClass();\n        (this.onChange || noop)(val, this);\n        return this;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Clear the selected value.\n   */\n\n\n  SelectInput.prototype.clearValue = function clearValue() {\n\n    var i = 0;\n    var len = this.selectEl.children.length;\n\n    for (; i < len; i++) {\n      if (this.selectEl.children[i].selected === true) {\n        this.selectEl.children[i].selected = false;\n        this._updateClass();\n        (this.onChange || noop)('', this);\n        return this;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the options.\n   * @param {Array} opts\n   */\n\n\n  SelectInput.prototype.setOptions = function setOptions(opts) {\n\n    var i = 0;\n    var len = opts.length;\n    var str = '';\n\n    // Store the index of the currently selected option so we can set\n    // it when we're all done.\n    var curIndex = this.selectEl.selectedIndex;\n\n    for (; i < len; i++) {\n      str += '<option ' + (opts[i].value !== undefined ? 'value=\"' + (opts[i].value || '') + '\"' : '') + '>' + (opts[i].text || '') + '</option>';\n    }\n\n    this.selectEl.innerHTML = str;\n    this.selectEl.selectedIndex = Math.min(len - 1, curIndex);\n\n    return this;\n  };\n\n  /**\n   * Set the value of the label.\n   * @param {String} text\n   */\n\n\n  SelectInput.prototype.setLabel = function setLabel(text) {\n    if (!this.labelEl) return this;\n    this.labelEl.innerHTML = text;\n    return this;\n  };\n\n  /**\n   * Disable entry into the input.\n   */\n\n\n  SelectInput.prototype.disable = function disable() {\n    this.selectEl.setAttribute('disabled', '');\n    return this;\n  };\n\n  /**\n   * Enable entry into the input.\n   */\n\n\n  SelectInput.prototype.enable = function enable() {\n    this.selectEl.removeAttribute('disabled');\n    return this;\n  };\n\n  /**\n   * Store a reference to the needed elements.\n   * @param {Element} el\n   */\n\n\n  SelectInput.prototype._cacheElements = function _cacheElements(el) {\n\n    this.el = el;\n    this.selectEl = this.el.querySelector('select');\n    this.labelEl = this.el.querySelector('.spark-label');\n\n    this.messageEl = this.el.querySelector('.spark-select__message') || (0, _makeElement2.default)('<span class=\"spark-select__message\"></span>');\n\n    if (!this.selectEl) {\n      throw new Error('A <select> element must be present!', this.el);\n    }\n\n    this._updateClass();\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  SelectInput.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onFocusBound = this._onFocus.bind(this);\n    this._onBlurBound = this._onBlur.bind(this);\n    this._onInputBound = this._onInput.bind(this);\n  };\n\n  /**\n   * Add event listeners for focus, blur and input.\n   */\n\n\n  SelectInput.prototype._addEventListeners = function _addEventListeners() {\n    this.selectEl.addEventListener('focus', this._onFocusBound);\n    this.selectEl.addEventListener('blur', this._onBlurBound);\n    this.selectEl.addEventListener('input', this._onInputBound);\n  };\n\n  /**\n   * Remove event listeners for focus, blur and input.\n   */\n\n\n  SelectInput.prototype._removeEventListeners = function _removeEventListeners() {\n    this.selectEl.removeEventListener('focus', this._onFocusBound);\n    this.selectEl.removeEventListener('blur', this._onBlurBound);\n    this.selectEl.removeEventListener('input', this._onInputBound);\n  };\n\n  /**\n   * Update the active class.\n   */\n\n\n  SelectInput.prototype._updateClass = function _updateClass() {\n    this.hasValue = this.selectEl.value ? true : false;\n    (0, _toggleClass2.default)(this.el, 'has-value', this.hasValue);\n    (0, _toggleClass2.default)(this.el, 'active', this.isActive);\n  };\n\n  /**\n   * When the input element gains focus.\n   * @param {Object} e\n   */\n\n\n  SelectInput.prototype._onFocus = function _onFocus() {\n    this.isActive = true;\n    this._updateClass();\n    var value = this.getValue();\n    (this.onFocus || noop)(value, this);\n  };\n\n  /**\n   * When the input element loses focus.\n   * @param {Object} e\n   */\n\n\n  SelectInput.prototype._onBlur = function _onBlur() {\n    this.isActive = false;\n    this._updateClass();\n    var value = this.getValue();\n    (this.onBlur || noop)(value, this);\n  };\n\n  /**\n   * When the value is about to change, run the validation, set the characters count\n   * and resize if we're a textarea.\n   * @param {Object} e\n   */\n\n\n  SelectInput.prototype._onInput = function _onInput() {\n\n    this._updateClass();\n\n    var value = this.getValue();\n\n    if (value !== this.previousValue) {\n      this.previousValue = value;\n      (this.onChange || noop)(value, this);\n    }\n  };\n\n  return SelectInput;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nSelectInput.prototype._whitelistedParams = ['validate', 'onValidate', 'onChange', 'onFocus', 'onBlur'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nSelectInput.prototype.defaults = {\n  el: null,\n  messageEl: null,\n  selectEl: null,\n  labelEl: null,\n  hasValue: false,\n  isActive: false,\n  onChange: null,\n  onFocus: null,\n  onBlur: null,\n  previousValue: null,\n  _onFocusBound: null,\n  _onBlurBound: null,\n  _onInputBound: null\n};\n\n(0, _mixin2.default)(SelectInput.prototype, _messaging2.default, _validation2.default);\n\nexports.default = SelectInput;\nmodule.exports = exports['default'];\n//# sourceMappingURL=select-input.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _outerHeight = require('../dom/outer-height');\n\nvar _outerHeight2 = _interopRequireDefault(_outerHeight);\n\nvar _addClass = require('../dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {}; /**\n                                * # Animate Height\n                                * Animate the height of an element since we can't do this w/ pure CSS. Sigh.\n                                *\n                                * @example\n                                * animateHeight({\n                                *   el: ...,\n                                *   toggleEl: ...,\n                                *   // Optional params\n                                *   action: 'collapse'|'expand',\n                                *   heightAnimationClass: 'spark-animate-height',\n                                *   opacityAnimationClass: 'spark-animate-opacity',\n                                *   toggleProperty: 'display'|'overflow'|'visibility',\n                                *   toggleValue: 'block'|'none'|'visible'|'hidden',\n                                *   animationDuration: 250\n                                * });\n                                *\n                                * @module helpers/animation/height.js\n                                */\n\nvar runningAnimations = {\n  els: [],\n  completeCallbacks: []\n};\n\n/**\n * Get the inverse toggle value\n * @param  {String} property\n * @param  {String} originalValue\n * @return {String}\n */\nfunction getInverseToggleValue(el, property, originalValue) {\n\n  // Get the value to toggle to for the given property\n  switch (property) {\n    case 'overflow':\n    case 'visibility':\n      return originalValue === 'visible' ? 'hidden' : 'visible';\n    default:\n      return originalValue === 'block' || originalValue === 'inline-block' ? 'none' : 'block';\n  }\n}\n\n/**\n * When an animation is complete, clean up and run the callback.\n * @param  {Object} params\n */\nfunction onComplete(params) {\n\n  // Reset toggle el visibility\n  if (params.toggleClassName) {\n    (0, _toggleClass2.default)(params.el, params.toggleClassName, !params.collapse);\n  } else {\n    params.toggleEl.style[params.toggleProperty] = '';\n  }\n\n  // Remove the height property\n  params.el.style.height = '';\n  params.toggleEl.style.height = '';\n  params.toggleEl.style.marginBottom = '';\n  params.toggleEl.style.marginTop = '';\n\n  // Remove the spark-animate-height class so the transitions no longer apply\n  (0, _removeClass2.default)(params.el, params.heightAnimationClass);\n  (0, _removeClass2.default)(params.toggleEl, params.heightAnimationClass);\n\n  // Run the callback\n  params.onComplete();\n\n  // Remove the element and callback from their respective arrays\n  var runningIndex = runningAnimations.els.indexOf(params.el);\n  runningAnimations.els.splice(runningIndex, 1);\n  runningAnimations.completeCallbacks.splice(runningIndex, 1);\n}\n\n/**\n * @param {Object} params\n */\nfunction animateHeight(params) {\n\n  params = params || {};\n\n  var el = params.el;\n\n  if (!el) {\n    return;\n  }\n\n  var collapse = params.action && params.action === 'collapse';\n  var heightAnimationClass = params.heightAnimationClass || 'spark-animate-height';\n\n  // Allow for elements to be passed or selector strings\n  var toggleEl = typeof params.toggleEl === 'string' ? el.querySelector(params.toggleEl) : params.toggleEl;\n\n  // No element to be switching with toggling so we can't determine the desired height to animate to.\n  if (!toggleEl || (0, _hasClass2.default)(el, 'spark-no-animate')) {\n    return;\n  }\n\n  var toggleClassName = params.toggleClass;\n\n  // The style property to use when toggling visibility\n  var toggleProperty = params.toggleProperty || 'display';\n  var toggleStyles = window.getComputedStyle(toggleEl);\n  var originalToggleValue = toggleStyles[toggleProperty];\n  var toggleValue = params.toggleValue || getInverseToggleValue(toggleProperty, originalToggleValue);\n\n  // If we are already animating, stop now.\n  var runningIndex = runningAnimations.els.indexOf(el);\n  if (runningIndex !== -1) {\n\n    var completeCallback = runningAnimations.completeCallbacks[runningIndex];\n    if (completeCallback) {\n      clearTimeout(completeCallback);\n    }\n\n    onComplete({\n      el: el,\n      toggleEl: toggleEl,\n      onComplete: params.onComplete || noop,\n      collapse: collapse,\n      toggleProperty: toggleProperty,\n      toggleClassName: toggleClassName,\n      toggleValue: toggleValue,\n      heightAnimationClass: heightAnimationClass\n    });\n  }\n\n  // Store the current height\n  var originalHeight = (0, _outerHeight2.default)(el);\n\n  // Toggle the visible property\n  if (toggleClassName) {\n    (0, _toggleClass2.default)(el, toggleClassName, !collapse);\n  } else {\n    toggleEl.style[toggleProperty] = toggleValue;\n  }\n\n  // When measuring the size for a collapse, we have to wait a tic for it to be\n  // accurate. Not sure why. Ugh.\n  if (collapse) {\n    setTimeout(runAnimation, 0);\n  } else {\n    runAnimation();\n  }\n\n  function runAnimation() {\n\n    // Now that the toggle el is taking up space, get the new height which we will be animating to\n    var targetElHeight = (0, _outerHeight2.default)(el);\n\n    // We need to store the original and target toggle element heights. They differ depending on\n    // whether we are going to expand or collapse.\n    var targetToggleElHeight = void 0;\n    var originalToggleElHeight = void 0;\n\n    // If we are collapsing, reset the toggle style and set it when we're done. Set the height so\n    // that we can animate down to 0 or up to the target height.\n    if (collapse) {\n\n      if (toggleClassName) {\n        (0, _removeClass2.default)(el, toggleClassName);\n      } else {\n        toggleEl.style[toggleProperty] = originalToggleValue;\n      }\n\n      originalToggleElHeight = (0, _outerHeight2.default)(toggleEl, toggleStyles);\n      targetToggleElHeight = 0;\n    } else {\n      targetToggleElHeight = (0, _outerHeight2.default)(toggleEl, toggleStyles);\n      originalToggleElHeight = 0;\n    }\n\n    // Set the original height\n    el.style.height = originalHeight + 'px';\n    toggleEl.style.height = originalToggleElHeight + 'px';\n    toggleEl.style.marginBottom = '0px';\n    toggleEl.style.marginTop = '0px';\n\n    // Add the spark-animate-height class which will setup the transition-property and duration\n    (0, _addClass2.default)(el, heightAnimationClass);\n    (0, _addClass2.default)(toggleEl, heightAnimationClass);\n\n    runningAnimations.els.push(el);\n\n    // We need to wait a tick to toggle the height or else the animation class won't function\n    setTimeout(function () {\n\n      // Set the height to the target height\n      el.style.height = targetElHeight + 'px';\n      toggleEl.style.height = targetToggleElHeight + 'px';\n\n      // Remove inline styles after the animation is complete\n      runningAnimations.completeCallbacks.push(setTimeout(function () {\n        onComplete({\n          el: el,\n          toggleEl: toggleEl,\n          onComplete: params.onComplete || noop,\n          collapse: collapse,\n          toggleProperty: toggleProperty,\n          toggleClassName: toggleClassName,\n          toggleValue: toggleValue,\n          heightAnimationClass: heightAnimationClass\n        });\n      }, params.animationDuration !== undefined ? params.animationDuration : 201));\n    }, 0);\n  }\n}\n\nexports.default = animateHeight;\nmodule.exports = exports['default'];\n//# sourceMappingURL=height.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Date helper\n * General helpers for working with dates.\n *\n * @module helpers/date/date.js\n */\n\nvar monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nvar monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];\nvar dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nvar dayNamesShort = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'];\nvar adjustedDayNames = [];\nvar adjustedDayNamesShort = [];\nvar weekStartsOn = 0;\n\nvar dateHelper = {\n\n  /**\n   * Transform a date into an object of date values.\n   * @param {Date} date\n   * @return {Object}\n   */\n  create: function create(date) {\n\n    date = date instanceof Date ? date : new Date(date.year, date.month - 1, date.day);\n\n    var inst = Object.create(dateHelper);\n    inst._date = date;\n    inst._cache = {};\n\n    return inst;\n  },\n\n  /**\n   * Get a year.\n   * @return {Number}\n   */\n  get year() {\n    this._instanceCheck('year');\n    return this._date.getFullYear();\n  },\n\n  /**\n   * Set a year.\n   * @param {Number} y\n   */\n  set year(y) {\n    this._instanceCheck('year');\n    this._clearCache();\n    return this._date.setFullYear(y);\n  },\n\n  /**\n   * Get a month.\n   * @return {Number} 1-12\n   */\n  get month() {\n    this._instanceCheck('month');\n    return this._date.getMonth() + 1;\n  },\n\n  /**\n   * Set a month.\n   * @param {Number} m 1-12\n   */\n  set month(m) {\n    this._instanceCheck('month');\n    this._clearCache();\n    return this._date.setMonth(m - 1);\n  },\n\n  /**\n   * Get a day.\n   * @return {Number} 1-31\n   */\n  get day() {\n    this._instanceCheck('day');\n    return this._date.getDate();\n  },\n\n  /**\n   * Set a day.\n   * @param {Number} d 1-31\n   */\n  set day(d) {\n    this._instanceCheck('day');\n    this._clearCache();\n    return this._date.setDate(d);\n  },\n\n  /**\n   * Sets the day, month and year values at once.\n   * @param {Object} params\n   */\n  set: function set(params) {\n    params = params || {};\n    this.year = params.year || this.year;\n    this.month = params.month || this.month;\n    this.day = params.day || this.day;\n  },\n\n  /**\n   * Get the full name of the month.\n   * @param {Number} num\n   * @return {String}\n   */\n  getMonthName: function getMonthName(num) {\n    return monthNames[num - 1];\n  },\n\n  /**\n   * Get the month name.\n   * @return {String}\n   */\n  get monthName() {\n    this._instanceCheck('monthName');\n    return dateHelper.getMonthName(this.month);\n  },\n\n  /**\n   * Get the list of month names.\n   * @return {Array}\n   */\n  getMonthNames: function getMonthNames() {\n    return monthNames;\n  },\n\n  /**\n   * Get the short name of the month.\n   * @param {Number} num\n   * @return {String}\n   */\n  getMonthNameShort: function getMonthNameShort(num) {\n    return monthNamesShort[num - 1];\n  },\n\n  /**\n   * Get the month name.\n   * @return {String}\n   */\n  get monthNameShort() {\n    this._instanceCheck('monthName');\n    return dateHelper.getMonthNameShort(this.month);\n  },\n\n  /**\n   * Get the list of short month names.\n   * @return {Array}\n   */\n  getMonthNamesShort: function getMonthNamesShort() {\n    return monthNamesShort;\n  },\n\n  /**\n   * Set the month names.\n   * @param {Array} names\n   */\n  setMonthNames: function setMonthNames(names) {\n    if (names.length === 12) monthNames = names;\n  },\n\n  /**\n   * Set the short month names.\n   * @param {Array} names\n   */\n  setMonthNamesShort: function setMonthNamesShort(names) {\n    if (names.length === 12) monthNamesShort = names;\n  },\n\n  /**\n   * Get the day of the week for a given day.\n   * @param {Object} date\n   * @return {Number} 1-7\n   */\n  getDayOfWeek: function getDayOfWeek(date) {\n    var day = (date instanceof Date ? date : new Date(date.year, date.month - 1, date.day)).getDay() - weekStartsOn;\n    return (day < 0 ? 7 - Math.abs(day) : day) + 1;\n  },\n\n  /**\n   * Get the day of the week.\n   * @return {Number}\n   */\n  get dayOfWeek() {\n    return dateHelper.getDayOfWeek(this._date);\n  },\n\n  /**\n   * Get the full name of a day of the week.\n   * @param {Number} num\n   * @return {String}\n   */\n  getDayName: function getDayName(num) {\n    return dayNames[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];\n  },\n\n  /**\n   * Get the day name.\n   * @return {String}\n   */\n  get dayName() {\n    this._instanceCheck('dayName');\n    return dateHelper.getDayName(this.dayOfWeek);\n  },\n\n  /**\n   * Get the full name of the days of the week.\n   * @return {Array}\n   */\n  getDayNames: function getDayNames() {\n    return adjustedDayNames.length ? adjustedDayNames : dayNames;\n  },\n\n  /**\n   * Get the short name of the day.\n   * @param {Number} num\n   * @return {String}\n   */\n  getDayNameShort: function getDayNameShort(num) {\n    return dayNamesShort[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];\n  },\n\n  /**\n   * Get the short day name.\n   * @return {String}\n   */\n  get dayNameShort() {\n    this._instanceCheck('dayNameShort');\n    return dateHelper.getDayNameShort(this.dayOfWeek);\n  },\n\n  /**\n   * Get the full name of the days of the week.\n   * @return {Array}\n   */\n  getDayNamesShort: function getDayNamesShort() {\n    return adjustedDayNamesShort.length ? adjustedDayNamesShort : dayNamesShort;\n  },\n\n  /**\n   * Set the day names.\n   * @param {Array} names\n   */\n  setDayNames: function setDayNames(names) {\n    if (names.length === 7) dayNames = names;\n  },\n\n  /**\n   * Set the short day names.\n   * @param {Array} names\n   */\n  setDayNamesShort: function setDayNamesShort(names) {\n    if (names.length === 7) dayNamesShort = names;\n  },\n\n  /**\n   * Get the index of the first day of the week.\n   * @return {Number}\n   */\n  getWeekStartsOn: function getWeekStartsOn() {\n    return weekStartsOn;\n  },\n\n  /**\n   * Set the index of the first day of the week.\n   * @param {Number} index\n   * @return {String}\n   */\n  setWeekStartsOn: function setWeekStartsOn(number) {\n\n    weekStartsOn = number;\n\n    if (number) {\n      adjustedDayNames = dayNames.slice(weekStartsOn);\n      adjustedDayNames = adjustedDayNames.concat(dayNames.slice(0, weekStartsOn));\n      adjustedDayNamesShort = dayNamesShort.slice(weekStartsOn);\n      adjustedDayNamesShort = adjustedDayNamesShort.concat(dayNamesShort.slice(0, weekStartsOn));\n    } else {\n      adjustedDayNames = [];\n      adjustedDayNamesShort = [];\n    }\n  },\n\n  /**\n   * Get the current date.\n   * @return {Object}\n   */\n  now: function now() {\n    return dateHelper.create(new Date());\n  },\n\n  /**\n   * Get the next year after the given date.\n   * This obviously isn't very complicated, but it exists\n   * for parity with how we get the week, day and month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextYear: function getNextYear(date) {\n    return dateHelper.create(new Date(date.year + 1, date.month - 1, date.day));\n  },\n\n  /**\n   * Get the year following this.\n   * @return {Object}\n   */\n  get nextYear() {\n    this._instanceCheck('nextYear');\n    return this._cache.nextYear || (this._cache.nextYear = dateHelper.getNextYear(this));\n  },\n\n  /**\n   * Get the first day of the week for a given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getWeekStart: function getWeekStart(date) {\n    var inst = dateHelper.create(new Date(date.year, date.month - 1, date.day - dateHelper.getDayOfWeek(date) + 1));\n    inst.weekStartsOn = weekStartsOn;\n    return inst;\n  },\n\n  /**\n   * Get the start of the week for this date.\n   * @return {Object}\n   */\n  get weekStart() {\n    this._instanceCheck('weekStart');\n    return this._cache.weekStart && this._cache.weekStart.weekStartsOn === weekStartsOn ? this._cache.weekStart : this._cache.weekStart = dateHelper.getWeekStart(this);\n  },\n\n  /**\n   * Get the first day of the month for a given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getMonthStart: function getMonthStart(date) {\n    var inst = dateHelper.create(new Date(date.year, date.month - 1, 1));\n    return inst;\n  },\n\n  /**\n   * Get the start of the month for this date.\n   * @return {Object}\n   */\n  get monthStart() {\n    this._instanceCheck('monthStart');\n    return this._cache.monthStart || (this._cache.monthStart = dateHelper.getMonthStart(this));\n  },\n\n  /**\n   * Get the next week after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextWeek: function getNextWeek(date) {\n    var start = dateHelper.getWeekStart(date);\n    return dateHelper.create(new Date(start.year, start.month - 1, start.day + 7));\n  },\n\n  /**\n   * Get the week following this.\n   * @return {Object}\n   */\n  get nextWeek() {\n    this._instanceCheck('nextWeek');\n    return this._cache.nextWeek || (this._cache.nextWeek = dateHelper.getNextWeek(this));\n  },\n\n  /**\n   * Get the next day after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextDay: function getNextDay(date) {\n    return dateHelper.create(new Date(date.year, date.month - 1, date.day + 1));\n  },\n\n  /**\n   * Get the day following this.\n   * @return {Object}\n   */\n  get nextDay() {\n    this._instanceCheck('nextDay');\n    return this._cache.nextDay || (this._cache.nextDay = dateHelper.getNextDay(this));\n  },\n\n  /**\n   * Get the next month after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextMonth: function getNextMonth(date) {\n    // Date() has a *bug/feature* if last day of month is 31 when calculating the next month.\n    // Need to account for that so that it doesn't round up the date/month.\n\n    if (date.day === 31 && date.month !== 1 && date.month !== 7 && date.month !== 12) {\n      // Adjust for months ending in 31 followed by months ending in 30\n      return dateHelper.create(new Date(date.year, date.month, date.day - 1));\n    } else if (date.day > 28 && date.month === 1) {\n      // fix for last day of February\n      return dateHelper.create(new Date(date.year, date.month + 1, 0));\n    } else {\n      return dateHelper.create(new Date(date.year, date.month, date.day));\n    }\n  },\n\n  /**\n   * Get the month following this.\n   * @return {Object}\n   */\n  get nextMonth() {\n    this._instanceCheck('nextMonth');\n    return this._cache.nextMonth || (this._cache.nextMonth = dateHelper.getNextMonth(this));\n  },\n\n  /**\n   * Get the previous year after the given date.\n   * This obviously isn't very complicated, but it exists\n   * for parity with how we get the week, day and month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousYear: function getPreviousYear(date) {\n    return dateHelper.create(new Date(date.year - 1, date.month - 1, date.day));\n  },\n\n  /**\n   * Get the year preceding this.\n   * @return {Object}\n   */\n  get previousYear() {\n    this._instanceCheck('previousYear');\n    return this._cache.previousYear || (this._cache.previousYear = dateHelper.getPreviousYear(this));\n  },\n\n  /**\n   * Get the previous week after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousWeek: function getPreviousWeek(date) {\n    var start = dateHelper.getWeekStart(date);\n    var inst = dateHelper.create(new Date(start.year, start.month - 1, start.day - 7));\n    inst.weekStartsOn = weekStartsOn;\n    return inst;\n  },\n\n  /**\n   * Get the week preceding this.\n   * @return {Object}\n   */\n  get previousWeek() {\n    this._instanceCheck('previousWeek');\n    return this._cache.previousWeek || (this._cache.previousWeek = dateHelper.getPreviousWeek(this));\n  },\n\n  /**\n   * Get the previous day after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousDay: function getPreviousDay(date) {\n    return dateHelper.create(new Date(date.year, date.month - 1, date.day - 1));\n  },\n\n  /**\n   * Get the day preceding this.\n   * @return {Object}\n   */\n  get previousDay() {\n    this._instanceCheck('previousDay');\n    return this._cache.previousDay || (this._cache.previousDay = dateHelper.getPreviousDay(this));\n  },\n\n  /**\n   * Get the previous month after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousMonth: function getPreviousMonth(date) {\n    // Date() has a *bug/feature* if last day of month is 31 when calculating the previous month.\n    // Need to account for that so that it doesn't round up the date/month.\n\n    if (date.day === 31 && date.month !== 1 && date.month !== 3 && date.month !== 8) {\n      // Adjust for months ending in 31 that follow months ending in 30\n      return dateHelper.create(new Date(date.year, date.month - 2, date.day - 1));\n    } else if (date.day > 28 && date.month === 3) {\n      // Adjust for last day of February\n      return dateHelper.create(new Date(date.year, date.month - 1, 0));\n    } else {\n      return dateHelper.create(new Date(date.year, date.month - 2, date.day));\n    }\n  },\n\n  /**\n   * Get the month preceding this.\n   * @return {Object}\n   */\n  get previousMonth() {\n    this._instanceCheck('previousMonth');\n    return this._cache.previousMonth || (this._cache.previousMonth = dateHelper.getPreviousMonth(this));\n  },\n\n  /**\n   * Get the last day of the month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getMonthEnd: function getMonthEnd(date) {\n    return dateHelper.create(new Date(date.year, date.month, 0));\n  },\n\n  /**\n   * Get the last day of the month.\n   * @return {Object}\n   */\n  get monthEnd() {\n    this._instanceCheck('monthEnd');\n    return this._cache.monthEnd || (this._cache.monthEnd = dateHelper.getMonthEnd(this));\n  },\n\n  /**\n   * Does a given day equal another? Or is it present in a list of others?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equal: function equal(date, compare, full) {\n    return this.equalDay(date, compare, full);\n  },\n\n  /**\n   * Does a given day equal another? Or is it present in a list of others?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalDay: function equalDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (compare[i] && date.year === compare[i].year && date.month === compare[i].month && date.day === compare[i].day) matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalWeek: function equalWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.equalDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalMonth: function equalMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year !== compare[i].year || date.year === compare[i].year && date.month !== compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalYear: function equalYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year !== compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a date before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  before: function before(date, compare, full) {\n    return this.beforeDay(date, compare, full);\n  },\n\n  /**\n   * Is a given date before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeDay: function beforeDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date._date >= compare[i]._date) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeWeek: function beforeWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.beforeDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeMonth: function beforeMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year > compare[i].year || date.year === compare[i].year && date.month >= compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeYear: function beforeYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year >= compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a date after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  after: function after(date, compare, full) {\n    return this.afterDay(date, compare, full);\n  },\n\n  /**\n   * Is a given date after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterDay: function afterDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date._date <= compare[i]._date) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterWeek: function afterWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.afterDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterMonth: function afterMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year < compare[i].year || date.year === compare[i].year && date.month <= compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterYear: function afterYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year <= compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Get the earliest date in an array.\n   * @return {Object}\n   */\n  earliest: function earliest(arr) {\n\n    var i = 0;\n    var len = arr.length;\n    var e = void 0;\n\n    for (; i < len; i++) {\n      if (!e || arr[i].before(e)) e = arr[i];\n    }\n\n    return e;\n  },\n\n  /**\n   * Get the latest date in an array.\n   * @return {Object}\n   */\n  latest: function latest(arr) {\n\n    var i = 0;\n    var len = arr.length;\n    var l = void 0;\n\n    for (; i < len; i++) {\n      if (!l || arr[i].after(l)) l = arr[i];\n    }\n\n    return l;\n  },\n\n  /**\n   * Clone a date instance.\n   * @param {Object} date\n   * @return {Object}\n   */\n  clone: function clone(date) {\n\n    // If we weren't passed a date, use this instance.\n    if (!date && this._date && this._date instanceof Date && dateHelper.isPrototypeOf(this)) {\n      date = this;\n    }\n\n    // No date, can't clone.\n    if (!date) {\n      throw new Error('Must pass a date to clone or call on an instance.');\n    }\n\n    return dateHelper.create(new Date(date._date.valueOf()));\n  },\n\n  /**\n   * If a comparison function is called on an instance, properly\n   * assign the vars.\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full\n   */\n  _checkComparisonArgs: function _checkComparisonArgs(date, compare, full) {\n\n    if (compare === undefined || typeof compare === 'boolean') {\n\n      if (!dateHelper.isPrototypeOf(this)) {\n        throw new Error('Cannot compare only one date!');\n      }\n\n      full = compare;\n      compare = date;\n      date = this;\n    }\n\n    compare = compare instanceof Array ? compare : [compare];\n\n    return [date, compare, full];\n  },\n\n  /**\n   * Check to see if we have an instance of the date object.\n   * @param  {String} prop\n   */\n  _instanceCheck: function _instanceCheck(prop) {\n    if (!this._date || !(this._date instanceof Date) || !dateHelper.isPrototypeOf(this)) throw new Error('Cannot access the property \"' + prop + '\" of the date helper with creating an instance!');\n  },\n\n  /**\n   * Clear the cache.\n   */\n  _clearCache: function _clearCache() {\n    this._instanceCheck('clearCache');\n    this._cache = {};\n  }\n};\n\nexports.default = dateHelper;\nmodule.exports = exports['default'];\n//# sourceMappingURL=date.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (html) {\n\n  if (!html) {\n    throw new Error('Cannot create element with no HTML!');\n  }\n\n  var el = document.createElement('div');\n  el.innerHTML = html;\n  var el2 = el.children[0];\n  el2.parentNode.removeChild(el2);\n  return el2;\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Make Element\n                                      * Make en element using a string of HTML.\n                                      *\n                                      * @example\n                                      * makeElement('<div></div>');\n                                      *\n                                      * @module helpers/make-element.js\n                                      *\n                                      * @param {String} html\n                                      * @return {Element}\n                                      */\n//# sourceMappingURL=make-element.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar props = ['marginTop', 'marginBottom', 'borderTop', 'borderBottom']; /**\n                                                                         * # Outer Height\n                                                                         * Get the outer height of an element (including margin and border)\n                                                                         *\n                                                                         * @param {Element} el\n                                                                         * @param {Object} styles Optional Already have computed styles? Pass them in.\n                                                                         *\n                                                                         * @example\n                                                                         * outerHeight(el, computedStyles);\n                                                                         *\n                                                                         * @module helpers/outer-height.js\n                                                                         */\n\n\nfunction outerHeight(el, styles) {\n\n  styles = styles || window.getComputedStyle(el);\n\n  var height = el.clientHeight;\n\n  (0, _each2.default)(props, function (prop) {\n    height += parseInt(styles[prop] || 0, 10);\n  });\n\n  return height;\n}\n\nexports.default = outerHeight;\nmodule.exports = exports['default'];\n//# sourceMappingURL=outer-height.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (proto) {\n  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n\n  (0, _each2.default)(mixins, function (mixin) {\n    for (var i in mixin) {\n      if (mixin.hasOwnProperty(i) && !proto[i]) proto[i] = mixin[i];\n    }\n  });\n};\n\nvar _each = require('./each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Mixin\n * Apply a mixin, or mixins, to an Object\n *\n * @example\n * mixin(proto, mix, mix2)\n *\n * @module helpers/util/mixin.js\n */\nmodule.exports = exports['default'];\n//# sourceMappingURL=mixin.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _height = require('../helpers/animation/height');\n\nvar _height2 = _interopRequireDefault(_height);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n\n  /**\n   * Set the error state.\n   * @param {String} message Optional\n   */\n  setError: function setError(message) {\n\n    // Animate down\n    if (!this._isMessageVisible()) {\n      this._showMessage();\n    }\n\n    this.clearWarning();\n    this.clearSuccess();\n\n    this.el.setAttribute('data-error', true);\n\n    if (message) {\n      this.setMessage(message);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Set the error state.\n   */\n  clearError: function clearError() {\n    this.el.removeAttribute('data-error', true);\n    return this;\n  },\n\n\n  /**\n   * Set the warning state.\n   * @param {String} message Optional\n   */\n  setWarning: function setWarning(message) {\n\n    // Animate down\n    if (!this._isMessageVisible()) {\n      this._showMessage();\n    }\n\n    this.clearError();\n    this.clearSuccess();\n\n    this.el.setAttribute('data-warning', true);\n\n    if (message) {\n      this.setMessage(message);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Set the error state.\n   */\n  clearWarning: function clearWarning() {\n    this.el.removeAttribute('data-warning', true);\n    return this;\n  },\n\n\n  /**\n   * Set the success state.\n   * @param {String} message Optional\n   */\n  setSuccess: function setSuccess(message) {\n\n    // Animate down\n    if (!this._isMessageVisible()) {\n      this._showMessage();\n    }\n\n    this.clearError();\n    this.clearWarning();\n\n    this.el.setAttribute('data-success', true);\n\n    if (message) {\n      this.setMessage(message);\n    }\n\n    return this;\n  },\n\n\n  /**\n   * Set the success state.\n   */\n  clearSuccess: function clearSuccess() {\n    this.el.removeAttribute('data-success', true);\n    return this;\n  },\n\n\n  /**\n   * Clear all messages.\n   */\n  clearMessages: function clearMessages() {\n    this._hideMessage(function () {\n      this.clearError();\n      this.clearWarning();\n      this.clearSuccess();\n    }.bind(this));\n    return this;\n  },\n\n\n  /**\n   * Set the message text.\n   * @param {String} message\n   */\n  setMessage: function setMessage(message) {\n    this.messageEl.innerHTML = message;\n    return this;\n  },\n\n\n  /**\n   * Show the message\n   */\n  _showMessage: function _showMessage() {\n\n    if (!this.messageEl.parentNode) {\n      this.el.appendChild(this.messageEl);\n    }\n\n    (0, _height2.default)({\n      el: this.el,\n      toggleEl: this.messageEl\n    });\n  },\n\n\n  /**\n   * Hide the message.\n   * @param {Function} callback\n   */\n  _hideMessage: function _hideMessage(callback) {\n\n    (0, _height2.default)({\n      el: this.el,\n      toggleEl: this.messageEl,\n      toggleValue: 'none',\n      action: 'collapse',\n      onComplete: callback\n    });\n  },\n\n\n  /**\n   * Is the message currently visible?\n   * @return {Boolean}\n   */\n  _isMessageVisible: function _isMessageVisible() {\n    return this.el.getAttribute('data-error') || this.el.getAttribute('data-warning') || this.el.getAttribute('data-success');\n  }\n}; /**\n    * # Messaging Mixin\n    * Add functionality for showing messages related to a form field.\n    *\n    * @example\n    * mixin(Component, messaging);\n    *\n    * @module mixin/messaging.js\n    */\n\nmodule.exports = exports['default'];\n//# sourceMappingURL=messaging.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Validation Mixin\n * Add functionality for validating a form field's value.\n *\n * @example\n * mixin(Component, validation);\n *\n * @module mixin/validation.js\n */\n\nexports.default = {\n\n  /**\n   * Default validate function. This can be overridden by passing a\n   * custom validate method as a parameter. This really only helps out\n   * of the box for text inputs.\n   */\n  validate: function validate() {\n\n    var validate = this.validatePattern;\n\n    // Nothing to validate.\n    if (!this.onValidate || !validate) {\n      return this;\n    }\n\n    var re = new RegExp(validate);\n\n    this.onValidate(re.test(this.getValue()), this.getValue(), this);\n\n    return this;\n  }\n};\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=validation.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9kYXRlLXNlbGVjdC5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9zZWxlY3QtaW5wdXQuanMiLCJqcy9kaXN0L2hlbHBlcnMvYW5pbWF0aW9uL2hlaWdodC5qcyIsImpzL2Rpc3QvaGVscGVycy9kYXRlL2RhdGUuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2FkZC1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vaGFzLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9tYWtlLWVsZW1lbnQuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL291dGVyLWhlaWdodC5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9yZW1vdmUtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy91dGlsL2VhY2guanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9taXhpbi5qcyIsImpzL2Rpc3QvaGVscGVycy91dGlsL3RyaW0uanMiLCJqcy9kaXN0L21peGlucy9tZXNzYWdpbmcuanMiLCJqcy9kaXN0L21peGlucy92YWxpZGF0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy83QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VhY2ggPSByZXF1aXJlKCcuLi9oZWxwZXJzL3V0aWwvZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgQmFzZSBDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgYmFzZSBjbGFzcyBmb3IgU3BhcmsgSlMgY29tcG9uZW50cy4gVGhpcyBjbGFzcyBzaG91bGQgbmV2ZXIgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBjb21wb25lbnRzL2Jhc2UuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbnZhciBCYXNlID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBTZXQgcGFyYW1ldGVycyBhbmQgY2FjaGUgZWxlbWVudHMuXG4gICAqL1xuICBmdW5jdGlvbiBCYXNlKGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZSk7XG5cbiAgICBpZiAocGFyYW1zLmVsUmVxdWlyZWQgJiYgIWVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRQYXJhbXModGhpcy5kZWZhdWx0cyB8fCB7fSwgdHJ1ZSk7XG4gICAgdGhpcy5zZXRQYXJhbXMocGFyYW1zKTtcbiAgICAodGhpcy5fY2FjaGVFbGVtZW50cyB8fCBub29wKS5jYWxsKHRoaXMsIGVsLCBwYXJhbXMpO1xuICAgICh0aGlzLl9wYXJzZVBhcmFtcyB8fCBub29wKS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIERPTSBhbmQgcHJlcGFyZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIGJ5IGRlcmVmZXJlbmNpbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxlYXZlRWxlbWVudCBMZWF2ZSB0aGUgZWxlbWVudCBpbnRhY3QuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGxlYXZlRWxlbWVudCkge1xuXG4gICAgaWYgKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIGlmICghbGVhdmVFbGVtZW50ICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgfVxuXG4gICAgdGhpcy51bnNldFBhcmFtcyh0aGlzLmRlZmF1bHRzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbXBvbmVudCB0byB1c2UgYSBuZXcgZWxlbWVudCBvciByZXBhcnNlIGZyb21cbiAgICogdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgT3B0aW9uYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShlbCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cbiAgICBpZiAodGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgKHRoaXMuX2NhY2hlRWxlbWVudHMgfHwgbm9vcCkuY2FsbCh0aGlzLCBlbCB8fCB0aGlzLmVsLCBwYXJhbXMpO1xuICAgICh0aGlzLl9wYXJzZVBhcmFtcyB8fCBub29wKS5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBoYXNoIG9mIHBhcmFtZXRlcnMgaWYgdGhleSdyZSB3aGl0ZWxpc3RlZCBvciB3ZSdyZSB0b2xkIHRvIGZvcmNlIHRoZSBzZXQuXG4gICAqIFRoaXMgaXMgdXNlZCB0byBzZXQgaW5pdGlhbCB2YWx1ZXMgYXMgd2VsbCBhcyBzZXQgcGFzc2VkIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSBzZXR0aW5nIGV2ZW4gaWYgdGhlIHBhcmFtIGlzIG5vdCB3aGl0ZWxpc3RlZC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiBzZXRQYXJhbXMocGFyYW1zLCBmb3JjZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKHBhcmFtcywgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIGlmIChfdGhpcy5fd2hpdGVsaXN0ZWRQYXJhbXMuaW5kZXhPZihrKSAhPT0gLTEgfHwgZm9yY2UpIHtcbiAgICAgICAgX3RoaXNba10gPSB2O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2V0IGFsbCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgVGhlIG9iamVjdCB0byB1bnNldCB0aGUgcGFyYW1zIGZyb20uIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS51bnNldFBhcmFtcyA9IGZ1bmN0aW9uIHVuc2V0UGFyYW1zKGtleXMsIHNjb3BlKSB7XG5cbiAgICBrZXlzID0ga2V5cyBpbnN0YW5jZW9mIEFycmF5ID8ga2V5cyA6IE9iamVjdC5rZXlzKGtleXMpO1xuICAgIHNjb3BlID0gc2NvcGUgfHwgdGhpcztcbiAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICBkZWxldGUgc2NvcGVba107XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFzZTtcbn0oKTtcblxuLyoqXG4gKiBXaGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBzZXQgb24gY29uc3RydWN0aW9uLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cblxuQmFzZS5wcm90b3R5cGUuX3doaXRlbGlzdGVkUGFyYW1zID0gW107XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIGludGVybmFsIHByb3BlcnRpZXMgd2Ugd2lsbCBiZSBzZXR0aW5nLlxuICogVGhlc2UgYXJlIHNldCBvbiBlYWNoIGNvbnN0cnVjdGlvbiBzbyB3ZSBkb24ndCBsZWFrIHByb3BlcnRpZXNcbiAqIGludG8gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkJhc2UucHJvdG90eXBlLmRlZmF1bHRzID0ge307XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfc2VsZWN0SW5wdXQgPSByZXF1aXJlKCcuL3NlbGVjdC1pbnB1dCcpO1xuXG52YXIgX3NlbGVjdElucHV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdElucHV0KTtcblxudmFyIF9kYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kYXRlL2RhdGUnKTtcblxudmFyIF9kYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RhdGUpO1xuXG52YXIgX3BhcnNlQXR0cmlidXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIERhdGVTZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhIHNlbGVjdCBsaXN0IG9mIGRheXMsIG1vbnRocyBvciB5ZWFycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV3IERhdGVTZWxlY3QoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9kYXRlLXNlbGVjdC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRFbGVtZW50KCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGVsLmNsYXNzTmFtZSA9ICdzcGFyay1zZWxlY3QnO1xuICBlbC5pbm5lckhUTUwgPSAnPHNlbGVjdCBjbGFzcz1cInNwYXJrLXNlbGVjdF9faW5wdXRcIj48L3NlbGVjdD48c3BhbiBjbGFzcz1cInNwYXJrLWxhYmVsXCI+PC9zcGFuPic7XG4gIHJldHVybiBlbDtcbn1cblxudmFyIERhdGVTZWxlY3QgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERhdGVTZWxlY3QsIF9CYXNlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogRGF0ZVNlbGVjdCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG4gIGZ1bmN0aW9uIERhdGVTZWxlY3QoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlU2VsZWN0KTtcblxuICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlIGEgZGVmYXVsdCBlbGVtZW50XG4gICAgLy8gc2luY2UgdGhlIHVzZXIgTVVTVCBwcm92aWRlIGFkZGl0aW9uYWwgcGFyYW1zIGJ1dCB0aGUgZWxlbWVudFxuICAgIC8vIGlzIG9wdGlvbmFsLiBEb2luZyBpdCB0aGlzIHdheSB0byBrZWVwIHRoZSBhcml0eSB0aGUgc2FtZVxuICAgIC8vIGFzIG90aGVyIGNvbXBvbmVudHMuXG4gICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHBhcmFtcyA9IGVsIHx8IHt9O1xuICAgICAgZWwgPSBjcmVhdGVEZWZhdWx0RWxlbWVudCgpO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpO1xuXG4gICAgX3RoaXMuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCk7XG4gICAgX3RoaXMuX2NyZWF0ZVNlbGVjdChlbCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNJbnQgR2V0IHRoZSB2YWx1ZSBhcyBhIHBhcnNlZCBpbnRlZ2VyLlxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICovXG5cblxuICBEYXRlU2VsZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGFzSW50KSB7XG4gICAgcmV0dXJuIGFzSW50ID8gcGFyc2VJbnQodGhpcy5zZWxlY3QuZ2V0VmFsdWUoKSwgMTApIDogdGhpcy5zZWxlY3QuZ2V0VmFsdWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Quc2V0VmFsdWUodmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHZhbHVlLlxuICAgKi9cblxuXG4gIERhdGVTZWxlY3QucHJvdG90eXBlLmNsZWFyVmFsdWUgPSBmdW5jdGlvbiBjbGVhclZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdC5jbGVhclZhbHVlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgaW5wdXQuXG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdC5lbmFibGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgaW5wdXQuXG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0LmRpc2FibGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkYXRlIHNlbGVjdCdzIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBwYXJhbXNcbiAgICovXG5cblxuICBEYXRlU2VsZWN0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhwYXJhbXMpIHtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHRoaXMubWluID0gcGFyYW1zLm1pbiB8fCB0aGlzLm1pbjtcbiAgICB0aGlzLm1heCA9IHBhcmFtcy5tYXggfHwgdGhpcy5tYXg7XG4gICAgdGhpcy5tb250aE5hbWVzID0gcGFyYW1zLm1vbnRoTmFtZXMgfHwgdGhpcy5tb250aE5hbWVzO1xuICAgIHRoaXMubnVtZXJpY01vbnRoID0gcGFyYW1zLm51bWVyaWNNb250aCB8fCB0aGlzLm51bWVyaWNNb250aDtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd5ZWFyJykge1xuICAgICAgaWYgKHBhcmFtcy5taW4gJiYgIXBhcmFtcy5tYXgpIHtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLm1pbiArIDEwMDtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLm1heCAmJiAhcGFyYW1zLm1pbikge1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMubWF4IC0gMTAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpID0gdGhpcy5taW4gPyB0aGlzLm1pbiAtIDEgOiAwO1xuICAgIHZhciBsZW4gPSB0aGlzLm1heCB8fCB0aGlzLm1vbnRoTmFtZXMubGVuZ3RoO1xuICAgIHZhciBvcHRzID0gW3t9XTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9wdHMucHVzaCh7XG4gICAgICAgIHZhbHVlOiBpICsgMSxcbiAgICAgICAgdGV4dDogdGhpcy5tb250aE5hbWVzID8gdGhpcy5tb250aE5hbWVzW2ldIDogaSArIDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0LnNldE9wdGlvbnMob3B0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBsYWJlbCB0ZXh0IGZvciB0aGUgc2VsZWN0IGlucHV0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBPcHRpb25hbFxuICAgKi9cblxuXG4gIERhdGVTZWxlY3QucHJvdG90eXBlLnNldExhYmVsID0gZnVuY3Rpb24gc2V0TGFiZWwodGV4dCkge1xuICAgIHRoaXMuc2VsZWN0LnNldExhYmVsKHRleHQgIT09IHVuZGVmaW5lZCA/IHRleHQgOiB0aGlzLl9nZXRUeXBlVGV4dCgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2VsZWN0IGlucHV0IGhlbHBlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsXG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuX2NyZWF0ZVNlbGVjdCA9IGZ1bmN0aW9uIF9jcmVhdGVTZWxlY3QoZWwpIHtcblxuICAgIHRoaXMuc2VsZWN0ID0gbmV3IF9zZWxlY3RJbnB1dDIuZGVmYXVsdChlbCwge1xuICAgICAgb25DaGFuZ2U6IHRoaXMuX29uU2VsZWN0Q2hhbmdlQm91bmQsXG4gICAgICBvbkZvY3VzOiB0aGlzLl9vblNlbGVjdEZvY3VzQm91bmQsXG4gICAgICBvbkJsdXI6IHRoaXMuX29uU2VsZWN0Qmx1ckJvdW5kXG4gICAgfSk7XG5cbiAgICB0aGlzLnNldE9wdGlvbnMoKTtcbiAgICB0aGlzLnNldExhYmVsKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhY2hlIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuX2NhY2hlRWxlbWVudHMgPSBmdW5jdGlvbiBfY2FjaGVFbGVtZW50cyhlbCkge1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLnNlbGVjdEVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdzZWxlY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgcGFyYW1ldGVycyBmcm9tIHRoZSBlbGVtZW50cy5cbiAgICovXG5cblxuICBEYXRlU2VsZWN0LnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiBfcGFyc2VQYXJhbXMoKSB7XG5cbiAgICB0aGlzLnR5cGUgPSB0aGlzLnR5cGUgIT09IG51bGwgPyB0aGlzLnR5cGUgOiAoMCwgX3BhcnNlQXR0cmlidXRlLnN0cmluZykodGhpcy5zZWxlY3RFbCwgJ2RhdGEtdHlwZScsICdkYXknKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd5ZWFyJykge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgdGhpcy5taW4gPSB0aGlzLm1pbiAhPT0gbnVsbCA/IHRoaXMubWluIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5udW1iZXIpKHRoaXMuc2VsZWN0RWwsICdtaW4nLCBkYXRlLmdldEZ1bGxZZWFyKCkgLSAxMDApO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLm1heCAhPT0gbnVsbCA/IHRoaXMubWF4IDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5udW1iZXIpKHRoaXMuc2VsZWN0RWwsICdtYXgnLCAodGhpcy5taW4gfHwgZGF0ZS5nZXRGdWxsWWVhcigpKSArIDEwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdtb250aCcpIHtcblxuICAgICAgdGhpcy5tb250aE5hbWVzID0gdGhpcy5tb250aE5hbWVzICE9PSBudWxsID8gdGhpcy5tb250aE5hbWVzIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuc2VsZWN0RWwsICdkYXRhLW1vbnRoLW5hbWVzJywgbnVsbCk7XG4gICAgICB0aGlzLm51bWVyaWNNb250aCA9IHRoaXMubnVtZXJpY01vbnRoICE9PSBudWxsID8gdGhpcy5udW1lcmljTW9udGggOiAoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKHRoaXMuc2VsZWN0RWwsICdkYXRhLW51bWVyaWMtbW9udGgnLCBmYWxzZSk7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMubWluICE9PSBudWxsID8gdGhpcy5taW4gOiAoMCwgX3BhcnNlQXR0cmlidXRlLm51bWJlcikodGhpcy5zZWxlY3RFbCwgJ21pbicsIG51bGwpO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLm1heCAhPT0gbnVsbCA/IHRoaXMubWF4IDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5udW1iZXIpKHRoaXMuc2VsZWN0RWwsICdtYXgnLCBudWxsKTtcblxuICAgICAgLy8gTm8gbW9udGhOYW1lcyB5ZXQgYW5kIG5vIG1pbiBvciBtYXhcbiAgICAgIGlmICghdGhpcy5tb250aE5hbWVzICYmICF0aGlzLm51bWVyaWNNb250aCAmJiAhdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XG4gICAgICAgIHRoaXMubW9udGhOYW1lcyA9IHRoaXMuX2dldERlZmF1bHRNb250aE5hbWVzKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcbiAgICAgICAgdGhpcy5taW4gPSAxO1xuICAgICAgICB0aGlzLm1heCA9IDEyO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMubW9udGhOYW1lcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5tb250aE5hbWVzID0gdGhpcy5tb250aE5hbWVzLnNwbGl0KCcsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5taW4gIT09IG51bGwgPyB0aGlzLm1pbiA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUubnVtYmVyKSh0aGlzLnNlbGVjdEVsLCAnbWluJywgMSk7XG4gICAgICB0aGlzLm1heCA9IHRoaXMubWF4ICE9PSBudWxsID8gdGhpcy5tYXggOiAoMCwgX3BhcnNlQXR0cmlidXRlLm51bWJlcikodGhpcy5zZWxlY3RFbCwgJ21heCcsIDMxKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBsaXN0IG9mIG1vbnRoIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuXG4gIERhdGVTZWxlY3QucHJvdG90eXBlLl9nZXREZWZhdWx0TW9udGhOYW1lcyA9IGZ1bmN0aW9uIF9nZXREZWZhdWx0TW9udGhOYW1lcygpIHtcbiAgICByZXR1cm4gX2RhdGUyLmRlZmF1bHQuZ2V0TW9udGhOYW1lc1Nob3J0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCBmb3IgdGhpcyB0eXBlIG9mIGRhdGUgc2VsZWN0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuX2dldFR5cGVUZXh0ID0gZnVuY3Rpb24gX2dldFR5cGVUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLnR5cGUuc2xpY2UoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBEYXRlU2VsZWN0LnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG4gICAgdGhpcy5fb25TZWxlY3RDaGFuZ2VCb3VuZCA9IHRoaXMuX29uU2VsZWN0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TZWxlY3RGb2N1c0JvdW5kID0gdGhpcy5fb25TZWxlY3RGb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2VsZWN0Qmx1ckJvdW5kID0gdGhpcy5fb25TZWxlY3RCbHVyLmJpbmQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHNlbGVjdCBjaGFuZ2VzLCBydW4gdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICovXG5cblxuICBEYXRlU2VsZWN0LnByb3RvdHlwZS5fb25TZWxlY3RDaGFuZ2UgPSBmdW5jdGlvbiBfb25TZWxlY3RDaGFuZ2UodmFsKSB7XG4gICAgKHRoaXMub25DaGFuZ2UgfHwgbm9vcCkodmFsLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgc2VsZWN0IGNoYW5nZXMsIHJ1biB0aGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGhlIHZhbHVlIG9mIHRoZSBpbnB1dFxuICAgKi9cblxuXG4gIERhdGVTZWxlY3QucHJvdG90eXBlLl9vblNlbGVjdEZvY3VzID0gZnVuY3Rpb24gX29uU2VsZWN0Rm9jdXModmFsKSB7XG4gICAgKHRoaXMub25Gb2N1cyB8fCBub29wKSh2YWwsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBzZWxlY3QgY2hhbmdlcywgcnVuIHRoZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUaGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAqL1xuXG5cbiAgRGF0ZVNlbGVjdC5wcm90b3R5cGUuX29uU2VsZWN0Qmx1ciA9IGZ1bmN0aW9uIF9vblNlbGVjdEJsdXIodmFsKSB7XG4gICAgKHRoaXMub25CbHVyIHx8IG5vb3ApKHZhbCwgdGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIERhdGVTZWxlY3Q7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuLyoqXG4gKiBXaGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBzZXQgb24gY29uc3RydWN0aW9uLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cblxuRGF0ZVNlbGVjdC5wcm90b3R5cGUuX3doaXRlbGlzdGVkUGFyYW1zID0gWyd0eXBlJywgJ21vbnRoTmFtZXMnLCAnbnVtZXJpY01vbnRoJywgJ21pbicsICdtYXgnLCAnb25DaGFuZ2UnLCAnb25Gb2N1cycsICdvbkJsdXInXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRGF0ZVNlbGVjdC5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGVsOiBudWxsLFxuICBzZWxlY3RFbDogbnVsbCxcbiAgdHlwZTogbnVsbCxcbiAgbW9udGhOYW1lczogbnVsbCxcbiAgbWluOiBudWxsLFxuICBtYXg6IG51bGwsXG4gIHNlbGVjdDogbnVsbCxcbiAgbnVtZXJpY01vbnRoOiBudWxsLFxuICBvbkNoYW5nZTogbnVsbCxcbiAgb25Gb2N1czogbnVsbCxcbiAgb25CbHVyOiBudWxsLFxuICBfb25DaGFuZ2VCb3VuZDogbnVsbCxcbiAgX29uRm9jdXNCb3VuZDogbnVsbCxcbiAgX29uQmx1ckJvdW5kOiBudWxsXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRlU2VsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlLXNlbGVjdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF90b2dnbGVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcycpO1xuXG52YXIgX3RvZ2dsZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvZ2dsZUNsYXNzKTtcblxudmFyIF9taXhpbiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9taXhpbicpO1xuXG52YXIgX21peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21peGluKTtcblxudmFyIF9tZXNzYWdpbmcgPSByZXF1aXJlKCcuLi9taXhpbnMvbWVzc2FnaW5nJyk7XG5cbnZhciBfbWVzc2FnaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lc3NhZ2luZyk7XG5cbnZhciBfdmFsaWRhdGlvbiA9IHJlcXVpcmUoJy4uL21peGlucy92YWxpZGF0aW9uJyk7XG5cbnZhciBfdmFsaWRhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZGF0aW9uKTtcblxudmFyIF9tYWtlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL21ha2UtZWxlbWVudCcpO1xuXG52YXIgX21ha2VFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VFbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgU2VsZWN0SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEEgc2VsZWN0IGlucHV0IGNvbnRhaW5lci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV3IFNlbGVjdElucHV0KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvc2VsZWN0LWlucHV0LmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIFNlbGVjdElucHV0ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTZWxlY3RJbnB1dCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBTZWxlY3RJbnB1dCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBTZWxlY3RJbnB1dChlbCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdElucHV0KTtcblxuICAgIHBhcmFtcy5lbFJlcXVpcmVkID0gdHJ1ZTtcblxuICAgIGlmICghKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKSksIF90aGlzKSkge1xuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKTtcbiAgICBfdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBTZWxlY3RJbnB1dC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RFbC52YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAgICovXG5cblxuICBTZWxlY3RJbnB1dC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2YWwpIHtcblxuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgZm9yIGNvbXBhcmlzb25cbiAgICB2YWwgPSB2YWwgKyAnJztcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5zZWxlY3RFbC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RFbC5jaGlsZHJlbltpXS52YWx1ZSA9PT0gdmFsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RWwuY2hpbGRyZW5baV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl91cGRhdGVDbGFzcygpO1xuICAgICAgICAodGhpcy5vbkNoYW5nZSB8fCBub29wKSh2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5jbGVhclZhbHVlID0gZnVuY3Rpb24gY2xlYXJWYWx1ZSgpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5zZWxlY3RFbC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RFbC5jaGlsZHJlbltpXS5zZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdEVsLmNoaWxkcmVuW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzKCk7XG4gICAgICAgICh0aGlzLm9uQ2hhbmdlIHx8IG5vb3ApKCcnLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gb3B0c1xuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IG9wdHMubGVuZ3RoO1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIC8vIFN0b3JlIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbiBzbyB3ZSBjYW4gc2V0XG4gICAgLy8gaXQgd2hlbiB3ZSdyZSBhbGwgZG9uZS5cbiAgICB2YXIgY3VySW5kZXggPSB0aGlzLnNlbGVjdEVsLnNlbGVjdGVkSW5kZXg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdHIgKz0gJzxvcHRpb24gJyArIChvcHRzW2ldLnZhbHVlICE9PSB1bmRlZmluZWQgPyAndmFsdWU9XCInICsgKG9wdHNbaV0udmFsdWUgfHwgJycpICsgJ1wiJyA6ICcnKSArICc+JyArIChvcHRzW2ldLnRleHQgfHwgJycpICsgJzwvb3B0aW9uPic7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RFbC5pbm5lckhUTUwgPSBzdHI7XG4gICAgdGhpcy5zZWxlY3RFbC5zZWxlY3RlZEluZGV4ID0gTWF0aC5taW4obGVuIC0gMSwgY3VySW5kZXgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGxhYmVsLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uIHNldExhYmVsKHRleHQpIHtcbiAgICBpZiAoIXRoaXMubGFiZWxFbCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5sYWJlbEVsLmlubmVySFRNTCA9IHRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgZW50cnkgaW50byB0aGUgaW5wdXQuXG4gICAqL1xuXG5cbiAgU2VsZWN0SW5wdXQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMuc2VsZWN0RWwuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIGVudHJ5IGludG8gdGhlIGlucHV0LlxuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5zZWxlY3RFbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBuZWVkZWQgZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cblxuICBTZWxlY3RJbnB1dC5wcm90b3R5cGUuX2NhY2hlRWxlbWVudHMgPSBmdW5jdGlvbiBfY2FjaGVFbGVtZW50cyhlbCkge1xuXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuc2VsZWN0RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xuICAgIHRoaXMubGFiZWxFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWxhYmVsJyk7XG5cbiAgICB0aGlzLm1lc3NhZ2VFbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXNlbGVjdF9fbWVzc2FnZScpIHx8ICgwLCBfbWFrZUVsZW1lbnQyLmRlZmF1bHQpKCc8c3BhbiBjbGFzcz1cInNwYXJrLXNlbGVjdF9fbWVzc2FnZVwiPjwvc3Bhbj4nKTtcblxuICAgIGlmICghdGhpcy5zZWxlY3RFbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIDxzZWxlY3Q+IGVsZW1lbnQgbXVzdCBiZSBwcmVzZW50IScsIHRoaXMuZWwpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBTZWxlY3RJbnB1dC5wcm90b3R5cGUuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCkge1xuICAgIHRoaXMuX29uRm9jdXNCb3VuZCA9IHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkJsdXJCb3VuZCA9IHRoaXMuX29uQmx1ci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSW5wdXRCb3VuZCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgZm9jdXMsIGJsdXIgYW5kIGlucHV0LlxuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5zZWxlY3RFbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXNCb3VuZCk7XG4gICAgdGhpcy5zZWxlY3RFbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyQm91bmQpO1xuICAgIHRoaXMuc2VsZWN0RWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbklucHV0Qm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBmb2N1cywgYmx1ciBhbmQgaW5wdXQuXG4gICAqL1xuXG5cbiAgU2VsZWN0SW5wdXQucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnNlbGVjdEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0JvdW5kKTtcbiAgICB0aGlzLnNlbGVjdEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9vbkJsdXJCb3VuZCk7XG4gICAgdGhpcy5zZWxlY3RFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uSW5wdXRCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYWN0aXZlIGNsYXNzLlxuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5fdXBkYXRlQ2xhc3MgPSBmdW5jdGlvbiBfdXBkYXRlQ2xhc3MoKSB7XG4gICAgdGhpcy5oYXNWYWx1ZSA9IHRoaXMuc2VsZWN0RWwudmFsdWUgPyB0cnVlIDogZmFsc2U7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ2hhcy12YWx1ZScsIHRoaXMuaGFzVmFsdWUpO1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdhY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgaW5wdXQgZWxlbWVudCBnYWlucyBmb2N1cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBTZWxlY3RJbnB1dC5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiBfb25Gb2N1cygpIHtcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGVDbGFzcygpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAodGhpcy5vbkZvY3VzIHx8IG5vb3ApKHZhbHVlLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgaW5wdXQgZWxlbWVudCBsb3NlcyBmb2N1cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBTZWxlY3RJbnB1dC5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uIF9vbkJsdXIoKSB7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3VwZGF0ZUNsYXNzKCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICh0aGlzLm9uQmx1ciB8fCBub29wKSh2YWx1ZSwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHZhbHVlIGlzIGFib3V0IHRvIGNoYW5nZSwgcnVuIHRoZSB2YWxpZGF0aW9uLCBzZXQgdGhlIGNoYXJhY3RlcnMgY291bnRcbiAgICogYW5kIHJlc2l6ZSBpZiB3ZSdyZSBhIHRleHRhcmVhLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFNlbGVjdElucHV0LnByb3RvdHlwZS5fb25JbnB1dCA9IGZ1bmN0aW9uIF9vbklucHV0KCkge1xuXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3MoKTtcblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSB2YWx1ZTtcbiAgICAgICh0aGlzLm9uQ2hhbmdlIHx8IG5vb3ApKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNlbGVjdElucHV0O1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cblNlbGVjdElucHV0LnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ3ZhbGlkYXRlJywgJ29uVmFsaWRhdGUnLCAnb25DaGFuZ2UnLCAnb25Gb2N1cycsICdvbkJsdXInXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuU2VsZWN0SW5wdXQucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBlbDogbnVsbCxcbiAgbWVzc2FnZUVsOiBudWxsLFxuICBzZWxlY3RFbDogbnVsbCxcbiAgbGFiZWxFbDogbnVsbCxcbiAgaGFzVmFsdWU6IGZhbHNlLFxuICBpc0FjdGl2ZTogZmFsc2UsXG4gIG9uQ2hhbmdlOiBudWxsLFxuICBvbkZvY3VzOiBudWxsLFxuICBvbkJsdXI6IG51bGwsXG4gIHByZXZpb3VzVmFsdWU6IG51bGwsXG4gIF9vbkZvY3VzQm91bmQ6IG51bGwsXG4gIF9vbkJsdXJCb3VuZDogbnVsbCxcbiAgX29uSW5wdXRCb3VuZDogbnVsbFxufTtcblxuKDAsIF9taXhpbjIuZGVmYXVsdCkoU2VsZWN0SW5wdXQucHJvdG90eXBlLCBfbWVzc2FnaW5nMi5kZWZhdWx0LCBfdmFsaWRhdGlvbjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNlbGVjdElucHV0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QtaW5wdXQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfb3V0ZXJIZWlnaHQgPSByZXF1aXJlKCcuLi9kb20vb3V0ZXItaGVpZ2h0Jyk7XG5cbnZhciBfb3V0ZXJIZWlnaHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3V0ZXJIZWlnaHQpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vZG9tL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4uL2RvbS9yZW1vdmUtY2xhc3MnKTtcblxudmFyIF9yZW1vdmVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDbGFzcyk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuLi9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX3RvZ2dsZUNsYXNzID0gcmVxdWlyZSgnLi4vZG9tL3RvZ2dsZS1jbGFzcycpO1xuXG52YXIgX3RvZ2dsZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvZ2dsZUNsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgQW5pbWF0ZSBIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbmltYXRlIHRoZSBoZWlnaHQgb2YgYW4gZWxlbWVudCBzaW5jZSB3ZSBjYW4ndCBkbyB0aGlzIHcvIHB1cmUgQ1NTLiBTaWdoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhbmltYXRlSGVpZ2h0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGVsOiAuLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICB0b2dnbGVFbDogLi4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgLy8gT3B0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBhY3Rpb246ICdjb2xsYXBzZSd8J2V4cGFuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBoZWlnaHRBbmltYXRpb25DbGFzczogJ3NwYXJrLWFuaW1hdGUtaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIG9wYWNpdHlBbmltYXRpb25DbGFzczogJ3NwYXJrLWFuaW1hdGUtb3BhY2l0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICB0b2dnbGVQcm9wZXJ0eTogJ2Rpc3BsYXknfCdvdmVyZmxvdyd8J3Zpc2liaWxpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgdG9nZ2xlVmFsdWU6ICdibG9jayd8J25vbmUnfCd2aXNpYmxlJ3wnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGFuaW1hdGlvbkR1cmF0aW9uOiAyNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9hbmltYXRpb24vaGVpZ2h0LmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBydW5uaW5nQW5pbWF0aW9ucyA9IHtcbiAgZWxzOiBbXSxcbiAgY29tcGxldGVDYWxsYmFja3M6IFtdXG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW52ZXJzZSB0b2dnbGUgdmFsdWVcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSAge1N0cmluZ30gb3JpZ2luYWxWYWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRJbnZlcnNlVG9nZ2xlVmFsdWUoZWwsIHByb3BlcnR5LCBvcmlnaW5hbFZhbHVlKSB7XG5cbiAgLy8gR2V0IHRoZSB2YWx1ZSB0byB0b2dnbGUgdG8gZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eVxuICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnb3ZlcmZsb3cnOlxuICAgIGNhc2UgJ3Zpc2liaWxpdHknOlxuICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWUgPT09ICd2aXNpYmxlJyA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZSA9PT0gJ2Jsb2NrJyB8fCBvcmlnaW5hbFZhbHVlID09PSAnaW5saW5lLWJsb2NrJyA/ICdub25lJyA6ICdibG9jayc7XG4gIH1cbn1cblxuLyoqXG4gKiBXaGVuIGFuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgY2xlYW4gdXAgYW5kIHJ1biB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtc1xuICovXG5mdW5jdGlvbiBvbkNvbXBsZXRlKHBhcmFtcykge1xuXG4gIC8vIFJlc2V0IHRvZ2dsZSBlbCB2aXNpYmlsaXR5XG4gIGlmIChwYXJhbXMudG9nZ2xlQ2xhc3NOYW1lKSB7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkocGFyYW1zLmVsLCBwYXJhbXMudG9nZ2xlQ2xhc3NOYW1lLCAhcGFyYW1zLmNvbGxhcHNlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMudG9nZ2xlRWwuc3R5bGVbcGFyYW1zLnRvZ2dsZVByb3BlcnR5XSA9ICcnO1xuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBoZWlnaHQgcHJvcGVydHlcbiAgcGFyYW1zLmVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICBwYXJhbXMudG9nZ2xlRWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gIHBhcmFtcy50b2dnbGVFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnJztcbiAgcGFyYW1zLnRvZ2dsZUVsLnN0eWxlLm1hcmdpblRvcCA9ICcnO1xuXG4gIC8vIFJlbW92ZSB0aGUgc3BhcmstYW5pbWF0ZS1oZWlnaHQgY2xhc3Mgc28gdGhlIHRyYW5zaXRpb25zIG5vIGxvbmdlciBhcHBseVxuICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShwYXJhbXMuZWwsIHBhcmFtcy5oZWlnaHRBbmltYXRpb25DbGFzcyk7XG4gICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHBhcmFtcy50b2dnbGVFbCwgcGFyYW1zLmhlaWdodEFuaW1hdGlvbkNsYXNzKTtcblxuICAvLyBSdW4gdGhlIGNhbGxiYWNrXG4gIHBhcmFtcy5vbkNvbXBsZXRlKCk7XG5cbiAgLy8gUmVtb3ZlIHRoZSBlbGVtZW50IGFuZCBjYWxsYmFjayBmcm9tIHRoZWlyIHJlc3BlY3RpdmUgYXJyYXlzXG4gIHZhciBydW5uaW5nSW5kZXggPSBydW5uaW5nQW5pbWF0aW9ucy5lbHMuaW5kZXhPZihwYXJhbXMuZWwpO1xuICBydW5uaW5nQW5pbWF0aW9ucy5lbHMuc3BsaWNlKHJ1bm5pbmdJbmRleCwgMSk7XG4gIHJ1bm5pbmdBbmltYXRpb25zLmNvbXBsZXRlQ2FsbGJhY2tzLnNwbGljZShydW5uaW5nSW5kZXgsIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZUhlaWdodChwYXJhbXMpIHtcblxuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIGVsID0gcGFyYW1zLmVsO1xuXG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29sbGFwc2UgPSBwYXJhbXMuYWN0aW9uICYmIHBhcmFtcy5hY3Rpb24gPT09ICdjb2xsYXBzZSc7XG4gIHZhciBoZWlnaHRBbmltYXRpb25DbGFzcyA9IHBhcmFtcy5oZWlnaHRBbmltYXRpb25DbGFzcyB8fCAnc3BhcmstYW5pbWF0ZS1oZWlnaHQnO1xuXG4gIC8vIEFsbG93IGZvciBlbGVtZW50cyB0byBiZSBwYXNzZWQgb3Igc2VsZWN0b3Igc3RyaW5nc1xuICB2YXIgdG9nZ2xlRWwgPSB0eXBlb2YgcGFyYW1zLnRvZ2dsZUVsID09PSAnc3RyaW5nJyA/IGVsLnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRvZ2dsZUVsKSA6IHBhcmFtcy50b2dnbGVFbDtcblxuICAvLyBObyBlbGVtZW50IHRvIGJlIHN3aXRjaGluZyB3aXRoIHRvZ2dsaW5nIHNvIHdlIGNhbid0IGRldGVybWluZSB0aGUgZGVzaXJlZCBoZWlnaHQgdG8gYW5pbWF0ZSB0by5cbiAgaWYgKCF0b2dnbGVFbCB8fCAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShlbCwgJ3NwYXJrLW5vLWFuaW1hdGUnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0b2dnbGVDbGFzc05hbWUgPSBwYXJhbXMudG9nZ2xlQ2xhc3M7XG5cbiAgLy8gVGhlIHN0eWxlIHByb3BlcnR5IHRvIHVzZSB3aGVuIHRvZ2dsaW5nIHZpc2liaWxpdHlcbiAgdmFyIHRvZ2dsZVByb3BlcnR5ID0gcGFyYW1zLnRvZ2dsZVByb3BlcnR5IHx8ICdkaXNwbGF5JztcbiAgdmFyIHRvZ2dsZVN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRvZ2dsZUVsKTtcbiAgdmFyIG9yaWdpbmFsVG9nZ2xlVmFsdWUgPSB0b2dnbGVTdHlsZXNbdG9nZ2xlUHJvcGVydHldO1xuICB2YXIgdG9nZ2xlVmFsdWUgPSBwYXJhbXMudG9nZ2xlVmFsdWUgfHwgZ2V0SW52ZXJzZVRvZ2dsZVZhbHVlKHRvZ2dsZVByb3BlcnR5LCBvcmlnaW5hbFRvZ2dsZVZhbHVlKTtcblxuICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBhbmltYXRpbmcsIHN0b3Agbm93LlxuICB2YXIgcnVubmluZ0luZGV4ID0gcnVubmluZ0FuaW1hdGlvbnMuZWxzLmluZGV4T2YoZWwpO1xuICBpZiAocnVubmluZ0luZGV4ICE9PSAtMSkge1xuXG4gICAgdmFyIGNvbXBsZXRlQ2FsbGJhY2sgPSBydW5uaW5nQW5pbWF0aW9ucy5jb21wbGV0ZUNhbGxiYWNrc1tydW5uaW5nSW5kZXhdO1xuICAgIGlmIChjb21wbGV0ZUNhbGxiYWNrKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29tcGxldGVDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgb25Db21wbGV0ZSh7XG4gICAgICBlbDogZWwsXG4gICAgICB0b2dnbGVFbDogdG9nZ2xlRWwsXG4gICAgICBvbkNvbXBsZXRlOiBwYXJhbXMub25Db21wbGV0ZSB8fCBub29wLFxuICAgICAgY29sbGFwc2U6IGNvbGxhcHNlLFxuICAgICAgdG9nZ2xlUHJvcGVydHk6IHRvZ2dsZVByb3BlcnR5LFxuICAgICAgdG9nZ2xlQ2xhc3NOYW1lOiB0b2dnbGVDbGFzc05hbWUsXG4gICAgICB0b2dnbGVWYWx1ZTogdG9nZ2xlVmFsdWUsXG4gICAgICBoZWlnaHRBbmltYXRpb25DbGFzczogaGVpZ2h0QW5pbWF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSBjdXJyZW50IGhlaWdodFxuICB2YXIgb3JpZ2luYWxIZWlnaHQgPSAoMCwgX291dGVySGVpZ2h0Mi5kZWZhdWx0KShlbCk7XG5cbiAgLy8gVG9nZ2xlIHRoZSB2aXNpYmxlIHByb3BlcnR5XG4gIGlmICh0b2dnbGVDbGFzc05hbWUpIHtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KShlbCwgdG9nZ2xlQ2xhc3NOYW1lLCAhY29sbGFwc2UpO1xuICB9IGVsc2Uge1xuICAgIHRvZ2dsZUVsLnN0eWxlW3RvZ2dsZVByb3BlcnR5XSA9IHRvZ2dsZVZhbHVlO1xuICB9XG5cbiAgLy8gV2hlbiBtZWFzdXJpbmcgdGhlIHNpemUgZm9yIGEgY29sbGFwc2UsIHdlIGhhdmUgdG8gd2FpdCBhIHRpYyBmb3IgaXQgdG8gYmVcbiAgLy8gYWNjdXJhdGUuIE5vdCBzdXJlIHdoeS4gVWdoLlxuICBpZiAoY29sbGFwc2UpIHtcbiAgICBzZXRUaW1lb3V0KHJ1bkFuaW1hdGlvbiwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcnVuQW5pbWF0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBydW5BbmltYXRpb24oKSB7XG5cbiAgICAvLyBOb3cgdGhhdCB0aGUgdG9nZ2xlIGVsIGlzIHRha2luZyB1cCBzcGFjZSwgZ2V0IHRoZSBuZXcgaGVpZ2h0IHdoaWNoIHdlIHdpbGwgYmUgYW5pbWF0aW5nIHRvXG4gICAgdmFyIHRhcmdldEVsSGVpZ2h0ID0gKDAsIF9vdXRlckhlaWdodDIuZGVmYXVsdCkoZWwpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBzdG9yZSB0aGUgb3JpZ2luYWwgYW5kIHRhcmdldCB0b2dnbGUgZWxlbWVudCBoZWlnaHRzLiBUaGV5IGRpZmZlciBkZXBlbmRpbmcgb25cbiAgICAvLyB3aGV0aGVyIHdlIGFyZSBnb2luZyB0byBleHBhbmQgb3IgY29sbGFwc2UuXG4gICAgdmFyIHRhcmdldFRvZ2dsZUVsSGVpZ2h0ID0gdm9pZCAwO1xuICAgIHZhciBvcmlnaW5hbFRvZ2dsZUVsSGVpZ2h0ID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UgYXJlIGNvbGxhcHNpbmcsIHJlc2V0IHRoZSB0b2dnbGUgc3R5bGUgYW5kIHNldCBpdCB3aGVuIHdlJ3JlIGRvbmUuIFNldCB0aGUgaGVpZ2h0IHNvXG4gICAgLy8gdGhhdCB3ZSBjYW4gYW5pbWF0ZSBkb3duIHRvIDAgb3IgdXAgdG8gdGhlIHRhcmdldCBoZWlnaHQuXG4gICAgaWYgKGNvbGxhcHNlKSB7XG5cbiAgICAgIGlmICh0b2dnbGVDbGFzc05hbWUpIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoZWwsIHRvZ2dsZUNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2dnbGVFbC5zdHlsZVt0b2dnbGVQcm9wZXJ0eV0gPSBvcmlnaW5hbFRvZ2dsZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5hbFRvZ2dsZUVsSGVpZ2h0ID0gKDAsIF9vdXRlckhlaWdodDIuZGVmYXVsdCkodG9nZ2xlRWwsIHRvZ2dsZVN0eWxlcyk7XG4gICAgICB0YXJnZXRUb2dnbGVFbEhlaWdodCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFRvZ2dsZUVsSGVpZ2h0ID0gKDAsIF9vdXRlckhlaWdodDIuZGVmYXVsdCkodG9nZ2xlRWwsIHRvZ2dsZVN0eWxlcyk7XG4gICAgICBvcmlnaW5hbFRvZ2dsZUVsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIG9yaWdpbmFsIGhlaWdodFxuICAgIGVsLnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0ICsgJ3B4JztcbiAgICB0b2dnbGVFbC5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbFRvZ2dsZUVsSGVpZ2h0ICsgJ3B4JztcbiAgICB0b2dnbGVFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMHB4JztcbiAgICB0b2dnbGVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMHB4JztcblxuICAgIC8vIEFkZCB0aGUgc3BhcmstYW5pbWF0ZS1oZWlnaHQgY2xhc3Mgd2hpY2ggd2lsbCBzZXR1cCB0aGUgdHJhbnNpdGlvbi1wcm9wZXJ0eSBhbmQgZHVyYXRpb25cbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShlbCwgaGVpZ2h0QW5pbWF0aW9uQ2xhc3MpO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRvZ2dsZUVsLCBoZWlnaHRBbmltYXRpb25DbGFzcyk7XG5cbiAgICBydW5uaW5nQW5pbWF0aW9ucy5lbHMucHVzaChlbCk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIHdhaXQgYSB0aWNrIHRvIHRvZ2dsZSB0aGUgaGVpZ2h0IG9yIGVsc2UgdGhlIGFuaW1hdGlvbiBjbGFzcyB3b24ndCBmdW5jdGlvblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBTZXQgdGhlIGhlaWdodCB0byB0aGUgdGFyZ2V0IGhlaWdodFxuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0RWxIZWlnaHQgKyAncHgnO1xuICAgICAgdG9nZ2xlRWwuc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0VG9nZ2xlRWxIZWlnaHQgKyAncHgnO1xuXG4gICAgICAvLyBSZW1vdmUgaW5saW5lIHN0eWxlcyBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICBydW5uaW5nQW5pbWF0aW9ucy5jb21wbGV0ZUNhbGxiYWNrcy5wdXNoKHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkNvbXBsZXRlKHtcbiAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgdG9nZ2xlRWw6IHRvZ2dsZUVsLFxuICAgICAgICAgIG9uQ29tcGxldGU6IHBhcmFtcy5vbkNvbXBsZXRlIHx8IG5vb3AsXG4gICAgICAgICAgY29sbGFwc2U6IGNvbGxhcHNlLFxuICAgICAgICAgIHRvZ2dsZVByb3BlcnR5OiB0b2dnbGVQcm9wZXJ0eSxcbiAgICAgICAgICB0b2dnbGVDbGFzc05hbWU6IHRvZ2dsZUNsYXNzTmFtZSxcbiAgICAgICAgICB0b2dnbGVWYWx1ZTogdG9nZ2xlVmFsdWUsXG4gICAgICAgICAgaGVpZ2h0QW5pbWF0aW9uQ2xhc3M6IGhlaWdodEFuaW1hdGlvbkNsYXNzXG4gICAgICAgIH0pO1xuICAgICAgfSwgcGFyYW1zLmFuaW1hdGlvbkR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbXMuYW5pbWF0aW9uRHVyYXRpb24gOiAyMDEpKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhbmltYXRlSGVpZ2h0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWlnaHQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGF0ZSBoZWxwZXJcbiAqIEdlbmVyYWwgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIGRhdGVzLlxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kYXRlL2RhdGUuanNcbiAqL1xuXG52YXIgbW9udGhOYW1lcyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xudmFyIG1vbnRoTmFtZXNTaG9ydCA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVnJywgJ1NlcHQnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbnZhciBkYXlOYW1lcyA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXTtcbnZhciBkYXlOYW1lc1Nob3J0ID0gWydTdW4nLCAnTW9uJywgJ1R1ZXMnLCAnV2VkJywgJ1RodXInLCAnRnJpJywgJ1NhdCddO1xudmFyIGFkanVzdGVkRGF5TmFtZXMgPSBbXTtcbnZhciBhZGp1c3RlZERheU5hbWVzU2hvcnQgPSBbXTtcbnZhciB3ZWVrU3RhcnRzT24gPSAwO1xuXG52YXIgZGF0ZUhlbHBlciA9IHtcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgZGF0ZSBpbnRvIGFuIG9iamVjdCBvZiBkYXRlIHZhbHVlcy5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGRhdGUpIHtcblxuICAgIGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGUgOiBuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSk7XG5cbiAgICB2YXIgaW5zdCA9IE9iamVjdC5jcmVhdGUoZGF0ZUhlbHBlcik7XG4gICAgaW5zdC5fZGF0ZSA9IGRhdGU7XG4gICAgaW5zdC5fY2FjaGUgPSB7fTtcblxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB5ZWFyLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd5ZWFyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgeWVhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICovXG4gIHNldCB5ZWFyKHkpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd5ZWFyJyk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnNldEZ1bGxZZWFyKHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBtb250aC5cbiAgICogQHJldHVybiB7TnVtYmVyfSAxLTEyXG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGgnKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgbW9udGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtIDEtMTJcbiAgICovXG4gIHNldCBtb250aChtKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGgnKTtcbiAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuc2V0TW9udGgobSAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBkYXkuXG4gICAqIEByZXR1cm4ge051bWJlcn0gMS0zMVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdkYXknKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXREYXRlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBhIGRheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGQgMS0zMVxuICAgKi9cbiAgc2V0IGRheShkKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnZGF5Jyk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnNldERhdGUoZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRheSwgbW9udGggYW5kIHllYXIgdmFsdWVzIGF0IG9uY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIHNldDogZnVuY3Rpb24gc2V0KHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLnllYXIgPSBwYXJhbXMueWVhciB8fCB0aGlzLnllYXI7XG4gICAgdGhpcy5tb250aCA9IHBhcmFtcy5tb250aCB8fCB0aGlzLm1vbnRoO1xuICAgIHRoaXMuZGF5ID0gcGFyYW1zLmRheSB8fCB0aGlzLmRheTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBmdWxsIG5hbWUgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vbnRoTmFtZTogZnVuY3Rpb24gZ2V0TW9udGhOYW1lKG51bSkge1xuICAgIHJldHVybiBtb250aE5hbWVzW251bSAtIDFdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoIG5hbWUuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldCBtb250aE5hbWUoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGhOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0TW9udGhOYW1lKHRoaXMubW9udGgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgbW9udGggbmFtZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0TW9udGhOYW1lczogZnVuY3Rpb24gZ2V0TW9udGhOYW1lcygpIHtcbiAgICByZXR1cm4gbW9udGhOYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBuYW1lIG9mIHRoZSBtb250aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRNb250aE5hbWVTaG9ydDogZnVuY3Rpb24gZ2V0TW9udGhOYW1lU2hvcnQobnVtKSB7XG4gICAgcmV0dXJuIG1vbnRoTmFtZXNTaG9ydFtudW0gLSAxXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhOYW1lU2hvcnQoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGhOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0TW9udGhOYW1lU2hvcnQodGhpcy5tb250aCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBzaG9ydCBtb250aCBuYW1lcy5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRNb250aE5hbWVzU2hvcnQ6IGZ1bmN0aW9uIGdldE1vbnRoTmFtZXNTaG9ydCgpIHtcbiAgICByZXR1cm4gbW9udGhOYW1lc1Nob3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1vbnRoIG5hbWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xuICAgKi9cbiAgc2V0TW9udGhOYW1lczogZnVuY3Rpb24gc2V0TW9udGhOYW1lcyhuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEyKSBtb250aE5hbWVzID0gbmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2hvcnQgbW9udGggbmFtZXMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzXG4gICAqL1xuICBzZXRNb250aE5hbWVzU2hvcnQ6IGZ1bmN0aW9uIHNldE1vbnRoTmFtZXNTaG9ydChuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEyKSBtb250aE5hbWVzU2hvcnQgPSBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGEgZ2l2ZW4gZGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDEtN1xuICAgKi9cbiAgZ2V0RGF5T2ZXZWVrOiBmdW5jdGlvbiBnZXREYXlPZldlZWsoZGF0ZSkge1xuICAgIHZhciBkYXkgPSAoZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRlIDogbmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpKS5nZXREYXkoKSAtIHdlZWtTdGFydHNPbjtcbiAgICByZXR1cm4gKGRheSA8IDAgPyA3IC0gTWF0aC5hYnMoZGF5KSA6IGRheSkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheU9mV2VlaygpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5nZXREYXlPZldlZWsodGhpcy5fZGF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIGEgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldERheU5hbWU6IGZ1bmN0aW9uIGdldERheU5hbWUobnVtKSB7XG4gICAgcmV0dXJuIGRheU5hbWVzW251bSAtIDEgKyB3ZWVrU3RhcnRzT25dIHx8IGRheU5hbWVzW2RheU5hbWVzLmxlbmd0aCAtIG51bSAtIDEgKyB3ZWVrU3RhcnRzT25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGF5TmFtZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdkYXlOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0RGF5TmFtZSh0aGlzLmRheU9mV2Vlayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldERheU5hbWVzOiBmdW5jdGlvbiBnZXREYXlOYW1lcygpIHtcbiAgICByZXR1cm4gYWRqdXN0ZWREYXlOYW1lcy5sZW5ndGggPyBhZGp1c3RlZERheU5hbWVzIDogZGF5TmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgbmFtZSBvZiB0aGUgZGF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldERheU5hbWVTaG9ydDogZnVuY3Rpb24gZ2V0RGF5TmFtZVNob3J0KG51bSkge1xuICAgIHJldHVybiBkYXlOYW1lc1Nob3J0W251bSAtIDEgKyB3ZWVrU3RhcnRzT25dIHx8IGRheU5hbWVzW2RheU5hbWVzLmxlbmd0aCAtIG51bSAtIDEgKyB3ZWVrU3RhcnRzT25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGRheSBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGF5TmFtZVNob3J0KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ2RheU5hbWVTaG9ydCcpO1xuICAgIHJldHVybiBkYXRlSGVscGVyLmdldERheU5hbWVTaG9ydCh0aGlzLmRheU9mV2Vlayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldERheU5hbWVzU2hvcnQ6IGZ1bmN0aW9uIGdldERheU5hbWVzU2hvcnQoKSB7XG4gICAgcmV0dXJuIGFkanVzdGVkRGF5TmFtZXNTaG9ydC5sZW5ndGggPyBhZGp1c3RlZERheU5hbWVzU2hvcnQgOiBkYXlOYW1lc1Nob3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRheSBuYW1lcy5cbiAgICogQHBhcmFtIHtBcnJheX0gbmFtZXNcbiAgICovXG4gIHNldERheU5hbWVzOiBmdW5jdGlvbiBzZXREYXlOYW1lcyhuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDcpIGRheU5hbWVzID0gbmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2hvcnQgZGF5IG5hbWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xuICAgKi9cbiAgc2V0RGF5TmFtZXNTaG9ydDogZnVuY3Rpb24gc2V0RGF5TmFtZXNTaG9ydChuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDcpIGRheU5hbWVzU2hvcnQgPSBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXZWVrU3RhcnRzT246IGZ1bmN0aW9uIGdldFdlZWtTdGFydHNPbigpIHtcbiAgICByZXR1cm4gd2Vla1N0YXJ0c09uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBzZXRXZWVrU3RhcnRzT246IGZ1bmN0aW9uIHNldFdlZWtTdGFydHNPbihudW1iZXIpIHtcblxuICAgIHdlZWtTdGFydHNPbiA9IG51bWJlcjtcblxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIGFkanVzdGVkRGF5TmFtZXMgPSBkYXlOYW1lcy5zbGljZSh3ZWVrU3RhcnRzT24pO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lcyA9IGFkanVzdGVkRGF5TmFtZXMuY29uY2F0KGRheU5hbWVzLnNsaWNlKDAsIHdlZWtTdGFydHNPbikpO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lc1Nob3J0ID0gZGF5TmFtZXNTaG9ydC5zbGljZSh3ZWVrU3RhcnRzT24pO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lc1Nob3J0ID0gYWRqdXN0ZWREYXlOYW1lc1Nob3J0LmNvbmNhdChkYXlOYW1lc1Nob3J0LnNsaWNlKDAsIHdlZWtTdGFydHNPbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGp1c3RlZERheU5hbWVzID0gW107XG4gICAgICBhZGp1c3RlZERheU5hbWVzU2hvcnQgPSBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkYXRlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB5ZWFyIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBUaGlzIG9idmlvdXNseSBpc24ndCB2ZXJ5IGNvbXBsaWNhdGVkLCBidXQgaXQgZXhpc3RzXG4gICAqIGZvciBwYXJpdHkgd2l0aCBob3cgd2UgZ2V0IHRoZSB3ZWVrLCBkYXkgYW5kIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXROZXh0WWVhcjogZnVuY3Rpb24gZ2V0TmV4dFllYXIoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIgKyAxLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dFllYXIoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbmV4dFllYXInKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dFllYXIgfHwgKHRoaXMuX2NhY2hlLm5leHRZZWFyID0gZGF0ZUhlbHBlci5nZXROZXh0WWVhcih0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGZvciBhIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFdlZWtTdGFydDogZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0KGRhdGUpIHtcbiAgICB2YXIgaW5zdCA9IGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDEsIGRhdGUuZGF5IC0gZGF0ZUhlbHBlci5nZXREYXlPZldlZWsoZGF0ZSkgKyAxKSk7XG4gICAgaW5zdC53ZWVrU3RhcnRzT24gPSB3ZWVrU3RhcnRzT247XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IHdlZWtTdGFydCgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd3ZWVrU3RhcnQnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUud2Vla1N0YXJ0ICYmIHRoaXMuX2NhY2hlLndlZWtTdGFydC53ZWVrU3RhcnRzT24gPT09IHdlZWtTdGFydHNPbiA/IHRoaXMuX2NhY2hlLndlZWtTdGFydCA6IHRoaXMuX2NhY2hlLndlZWtTdGFydCA9IGRhdGVIZWxwZXIuZ2V0V2Vla1N0YXJ0KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TW9udGhTdGFydDogZnVuY3Rpb24gZ2V0TW9udGhTdGFydChkYXRlKSB7XG4gICAgdmFyIGluc3QgPSBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCAxKSk7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBtb250aFN0YXJ0KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ21vbnRoU3RhcnQnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubW9udGhTdGFydCB8fCAodGhpcy5fY2FjaGUubW9udGhTdGFydCA9IGRhdGVIZWxwZXIuZ2V0TW9udGhTdGFydCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB3ZWVrIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXROZXh0V2VlazogZnVuY3Rpb24gZ2V0TmV4dFdlZWsoZGF0ZSkge1xuICAgIHZhciBzdGFydCA9IGRhdGVIZWxwZXIuZ2V0V2Vla1N0YXJ0KGRhdGUpO1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShzdGFydC55ZWFyLCBzdGFydC5tb250aCAtIDEsIHN0YXJ0LmRheSArIDcpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dFdlZWsoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbmV4dFdlZWsnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dFdlZWsgfHwgKHRoaXMuX2NhY2hlLm5leHRXZWVrID0gZGF0ZUhlbHBlci5nZXROZXh0V2Vlayh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBkYXkgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE5leHREYXk6IGZ1bmN0aW9uIGdldE5leHREYXkoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSArIDEpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgZm9sbG93aW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBuZXh0RGF5KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ25leHREYXknKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dERheSB8fCAodGhpcy5fY2FjaGUubmV4dERheSA9IGRhdGVIZWxwZXIuZ2V0TmV4dERheSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBtb250aCBhZnRlciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TmV4dE1vbnRoOiBmdW5jdGlvbiBnZXROZXh0TW9udGgoZGF0ZSkge1xuICAgIC8vIERhdGUoKSBoYXMgYSAqYnVnL2ZlYXR1cmUqIGlmIGxhc3QgZGF5IG9mIG1vbnRoIGlzIDMxIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG5leHQgbW9udGguXG4gICAgLy8gTmVlZCB0byBhY2NvdW50IGZvciB0aGF0IHNvIHRoYXQgaXQgZG9lc24ndCByb3VuZCB1cCB0aGUgZGF0ZS9tb250aC5cblxuICAgIGlmIChkYXRlLmRheSA9PT0gMzEgJiYgZGF0ZS5tb250aCAhPT0gMSAmJiBkYXRlLm1vbnRoICE9PSA3ICYmIGRhdGUubW9udGggIT09IDEyKSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIG1vbnRocyBlbmRpbmcgaW4gMzEgZm9sbG93ZWQgYnkgbW9udGhzIGVuZGluZyBpbiAzMFxuICAgICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkgLSAxKSk7XG4gICAgfSBlbHNlIGlmIChkYXRlLmRheSA+IDI4ICYmIGRhdGUubW9udGggPT09IDEpIHtcbiAgICAgIC8vIGZpeCBmb3IgbGFzdCBkYXkgb2YgRmVicnVhcnlcbiAgICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggKyAxLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dE1vbnRoKCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ25leHRNb250aCcpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5uZXh0TW9udGggfHwgKHRoaXMuX2NhY2hlLm5leHRNb250aCA9IGRhdGVIZWxwZXIuZ2V0TmV4dE1vbnRoKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmV2aW91cyB5ZWFyIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBUaGlzIG9idmlvdXNseSBpc24ndCB2ZXJ5IGNvbXBsaWNhdGVkLCBidXQgaXQgZXhpc3RzXG4gICAqIGZvciBwYXJpdHkgd2l0aCBob3cgd2UgZ2V0IHRoZSB3ZWVrLCBkYXkgYW5kIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRQcmV2aW91c1llYXI6IGZ1bmN0aW9uIGdldFByZXZpb3VzWWVhcihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciAtIDEsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXIgcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c1llYXIoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNZZWFyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnByZXZpb3VzWWVhciB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNZZWFyID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c1llYXIodGhpcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIHdlZWsgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFByZXZpb3VzV2VlazogZnVuY3Rpb24gZ2V0UHJldmlvdXNXZWVrKGRhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBkYXRlSGVscGVyLmdldFdlZWtTdGFydChkYXRlKTtcbiAgICB2YXIgaW5zdCA9IGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKHN0YXJ0LnllYXIsIHN0YXJ0Lm1vbnRoIC0gMSwgc3RhcnQuZGF5IC0gNykpO1xuICAgIGluc3Qud2Vla1N0YXJ0c09uID0gd2Vla1N0YXJ0c09uO1xuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c1dlZWsoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNXZWVrJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnByZXZpb3VzV2VlayB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNXZWVrID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c1dlZWsodGhpcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIGRheSBhZnRlciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UHJldmlvdXNEYXk6IGZ1bmN0aW9uIGdldFByZXZpb3VzRGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkgLSAxKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IHByZWNlZGluZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgcHJldmlvdXNEYXkoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNEYXknKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucHJldmlvdXNEYXkgfHwgKHRoaXMuX2NhY2hlLnByZXZpb3VzRGF5ID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c0RheSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJldmlvdXMgbW9udGggYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFByZXZpb3VzTW9udGg6IGZ1bmN0aW9uIGdldFByZXZpb3VzTW9udGgoZGF0ZSkge1xuICAgIC8vIERhdGUoKSBoYXMgYSAqYnVnL2ZlYXR1cmUqIGlmIGxhc3QgZGF5IG9mIG1vbnRoIGlzIDMxIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgIC8vIE5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdCBzbyB0aGF0IGl0IGRvZXNuJ3Qgcm91bmQgdXAgdGhlIGRhdGUvbW9udGguXG5cbiAgICBpZiAoZGF0ZS5kYXkgPT09IDMxICYmIGRhdGUubW9udGggIT09IDEgJiYgZGF0ZS5tb250aCAhPT0gMyAmJiBkYXRlLm1vbnRoICE9PSA4KSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIG1vbnRocyBlbmRpbmcgaW4gMzEgdGhhdCBmb2xsb3cgbW9udGhzIGVuZGluZyBpbiAzMFxuICAgICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDIsIGRhdGUuZGF5IC0gMSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0ZS5kYXkgPiAyOCAmJiBkYXRlLm1vbnRoID09PSAzKSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIGxhc3QgZGF5IG9mIEZlYnJ1YXJ5XG4gICAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMiwgZGF0ZS5kYXkpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c01vbnRoKCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ3ByZXZpb3VzTW9udGgnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucHJldmlvdXNNb250aCB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNNb250aCA9IGRhdGVIZWxwZXIuZ2V0UHJldmlvdXNNb250aCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRNb250aEVuZDogZnVuY3Rpb24gZ2V0TW9udGhFbmQoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIDApKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGguXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBtb250aEVuZCgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdtb250aEVuZCcpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5tb250aEVuZCB8fCAodGhpcy5fY2FjaGUubW9udGhFbmQgPSBkYXRlSGVscGVyLmdldE1vbnRoRW5kKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogRG9lcyBhIGdpdmVuIGRheSBlcXVhbCBhbm90aGVyPyBPciBpcyBpdCBwcmVzZW50IGluIGEgbGlzdCBvZiBvdGhlcnM/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWw6IGZ1bmN0aW9uIGVxdWFsKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lcXVhbERheShkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgfSxcblxuICAvKipcbiAgICogRG9lcyBhIGdpdmVuIGRheSBlcXVhbCBhbm90aGVyPyBPciBpcyBpdCBwcmVzZW50IGluIGEgbGlzdCBvZiBvdGhlcnM/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxEYXk6IGZ1bmN0aW9uIGVxdWFsRGF5KGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNvbXBhcmVbaV0gJiYgZGF0ZS55ZWFyID09PSBjb21wYXJlW2ldLnllYXIgJiYgZGF0ZS5tb250aCA9PT0gY29tcGFyZVtpXS5tb250aCAmJiBkYXRlLmRheSA9PT0gY29tcGFyZVtpXS5kYXkpIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB3ZWVrIGVxdWFsIHRvIGFub3RoZXI/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxXZWVrOiBmdW5jdGlvbiBlcXVhbFdlZWsoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgIWRhdGUud2Vla1N0YXJ0LmVxdWFsRGF5KGNvbXBhcmVbaV0ud2Vla1N0YXJ0KSkgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgbW9udGggZXF1YWwgdG8gYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbE1vbnRoOiBmdW5jdGlvbiBlcXVhbE1vbnRoKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFjb21wYXJlW2ldIHx8IGRhdGUueWVhciAhPT0gY29tcGFyZVtpXS55ZWFyIHx8IGRhdGUueWVhciA9PT0gY29tcGFyZVtpXS55ZWFyICYmIGRhdGUubW9udGggIT09IGNvbXBhcmVbaV0ubW9udGgpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIHllYXIgZXF1YWwgdG8gYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbFllYXI6IGZ1bmN0aW9uIGVxdWFsWWVhcihkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLnllYXIgIT09IGNvbXBhcmVbaV0ueWVhcikgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZGF0ZSBiZWZvcmUgYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlRGF5KGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRhdGUgYmVmb3JlIGFub3RoZXI/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgYmVmb3JlRGF5OiBmdW5jdGlvbiBiZWZvcmVEYXkoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS5fZGF0ZSA+PSBjb21wYXJlW2ldLl9kYXRlKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB3ZWVrIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZVdlZWs6IGZ1bmN0aW9uIGJlZm9yZVdlZWsoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgIWRhdGUud2Vla1N0YXJ0LmJlZm9yZURheShjb21wYXJlW2ldLndlZWtTdGFydCkpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIG1vbnRoIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZU1vbnRoOiBmdW5jdGlvbiBiZWZvcmVNb250aChkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLnllYXIgPiBjb21wYXJlW2ldLnllYXIgfHwgZGF0ZS55ZWFyID09PSBjb21wYXJlW2ldLnllYXIgJiYgZGF0ZS5tb250aCA+PSBjb21wYXJlW2ldLm1vbnRoKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB5ZWFyIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZVllYXI6IGZ1bmN0aW9uIGJlZm9yZVllYXIoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS55ZWFyID49IGNvbXBhcmVbaV0ueWVhcikgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZGF0ZSBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWZ0ZXJEYXkoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZ2l2ZW4gZGF0ZSBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyRGF5OiBmdW5jdGlvbiBhZnRlckRheShkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLl9kYXRlIDw9IGNvbXBhcmVbaV0uX2RhdGUpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIHdlZWsgYWZ0ZXIgYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBhZnRlcldlZWs6IGZ1bmN0aW9uIGFmdGVyV2VlayhkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCAhZGF0ZS53ZWVrU3RhcnQuYWZ0ZXJEYXkoY29tcGFyZVtpXS53ZWVrU3RhcnQpKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSBtb250aCBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyTW9udGg6IGZ1bmN0aW9uIGFmdGVyTW9udGgoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS55ZWFyIDwgY29tcGFyZVtpXS55ZWFyIHx8IGRhdGUueWVhciA9PT0gY29tcGFyZVtpXS55ZWFyICYmIGRhdGUubW9udGggPD0gY29tcGFyZVtpXS5tb250aCkgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgeWVhciBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyWWVhcjogZnVuY3Rpb24gYWZ0ZXJZZWFyKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFjb21wYXJlW2ldIHx8IGRhdGUueWVhciA8PSBjb21wYXJlW2ldLnllYXIpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVhcmxpZXN0IGRhdGUgaW4gYW4gYXJyYXkuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGVhcmxpZXN0OiBmdW5jdGlvbiBlYXJsaWVzdChhcnIpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgZSA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghZSB8fCBhcnJbaV0uYmVmb3JlKGUpKSBlID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhdGVzdCBkYXRlIGluIGFuIGFycmF5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBsYXRlc3Q6IGZ1bmN0aW9uIGxhdGVzdChhcnIpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgbCA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghbCB8fCBhcnJbaV0uYWZ0ZXIobCkpIGwgPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lIGEgZGF0ZSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGRhdGUpIHtcblxuICAgIC8vIElmIHdlIHdlcmVuJ3QgcGFzc2VkIGEgZGF0ZSwgdXNlIHRoaXMgaW5zdGFuY2UuXG4gICAgaWYgKCFkYXRlICYmIHRoaXMuX2RhdGUgJiYgdGhpcy5fZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgZGF0ZUhlbHBlci5pc1Byb3RvdHlwZU9mKHRoaXMpKSB7XG4gICAgICBkYXRlID0gdGhpcztcbiAgICB9XG5cbiAgICAvLyBObyBkYXRlLCBjYW4ndCBjbG9uZS5cbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGEgZGF0ZSB0byBjbG9uZSBvciBjYWxsIG9uIGFuIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLl9kYXRlLnZhbHVlT2YoKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhIGNvbXBhcmlzb24gZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGluc3RhbmNlLCBwcm9wZXJseVxuICAgKiBhc3NpZ24gdGhlIHZhcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbFxuICAgKi9cbiAgX2NoZWNrQ29tcGFyaXNvbkFyZ3M6IGZ1bmN0aW9uIF9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIGlmIChjb21wYXJlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNvbXBhcmUgPT09ICdib29sZWFuJykge1xuXG4gICAgICBpZiAoIWRhdGVIZWxwZXIuaXNQcm90b3R5cGVPZih0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIG9ubHkgb25lIGRhdGUhJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bGwgPSBjb21wYXJlO1xuICAgICAgY29tcGFyZSA9IGRhdGU7XG4gICAgICBkYXRlID0gdGhpcztcbiAgICB9XG5cbiAgICBjb21wYXJlID0gY29tcGFyZSBpbnN0YW5jZW9mIEFycmF5ID8gY29tcGFyZSA6IFtjb21wYXJlXTtcblxuICAgIHJldHVybiBbZGF0ZSwgY29tcGFyZSwgZnVsbF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoZSBkYXRlIG9iamVjdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBwcm9wXG4gICAqL1xuICBfaW5zdGFuY2VDaGVjazogZnVuY3Rpb24gX2luc3RhbmNlQ2hlY2socHJvcCkge1xuICAgIGlmICghdGhpcy5fZGF0ZSB8fCAhKHRoaXMuX2RhdGUgaW5zdGFuY2VvZiBEYXRlKSB8fCAhZGF0ZUhlbHBlci5pc1Byb3RvdHlwZU9mKHRoaXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2Nlc3MgdGhlIHByb3BlcnR5IFwiJyArIHByb3AgKyAnXCIgb2YgdGhlIGRhdGUgaGVscGVyIHdpdGggY3JlYXRpbmcgYW4gaW5zdGFuY2UhJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBjYWNoZS5cbiAgICovXG4gIF9jbGVhckNhY2hlOiBmdW5jdGlvbiBfY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdjbGVhckNhY2hlJyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZGF0ZUhlbHBlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGh0bWwpIHtcblxuICBpZiAoIWh0bWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIG5vIEhUTUwhJyk7XG4gIH1cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgdmFyIGVsMiA9IGVsLmNoaWxkcmVuWzBdO1xuICBlbDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbDIpO1xuICByZXR1cm4gZWwyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgTWFrZSBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWFrZSBlbiBlbGVtZW50IHVzaW5nIGEgc3RyaW5nIG9mIEhUTUwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1ha2VFbGVtZW50KCc8ZGl2PjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL21ha2UtZWxlbWVudC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1lbGVtZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VhY2ggPSByZXF1aXJlKCcuLi91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgcHJvcHMgPSBbJ21hcmdpblRvcCcsICdtYXJnaW5Cb3R0b20nLCAnYm9yZGVyVG9wJywgJ2JvcmRlckJvdHRvbSddOyAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgT3V0ZXIgSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIG91dGVyIGhlaWdodCBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgbWFyZ2luIGFuZCBib3JkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBPcHRpb25hbCBBbHJlYWR5IGhhdmUgY29tcHV0ZWQgc3R5bGVzPyBQYXNzIHRoZW0gaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG91dGVySGVpZ2h0KGVsLCBjb21wdXRlZFN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL291dGVyLWhlaWdodC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxuZnVuY3Rpb24gb3V0ZXJIZWlnaHQoZWwsIHN0eWxlcykge1xuXG4gIHN0eWxlcyA9IHN0eWxlcyB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAoMCwgX2VhY2gyLmRlZmF1bHQpKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGhlaWdodCArPSBwYXJzZUludChzdHlsZXNbcHJvcF0gfHwgMCwgMTApO1xuICB9KTtcblxuICByZXR1cm4gaGVpZ2h0O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBvdXRlckhlaWdodDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3V0ZXItaGVpZ2h0LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFBhcnNlIERPTSBhdHRyaWJ1dGVzXG4gKiBHaXZlbiBhbiBlbGVtZW50IGFuZCBhbiBhdHRyaWJ1dGUgbmFtZSwgcGFyc2UgdGhhdCBhdHRyaWJ1dGVcbiAqIGlmIGl0IGV4aXN0cyBvciByZXR1cm4gYSBkZWZhdWx0LlxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlLmpzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIGJvb2xlYW4gdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSBkZWZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xlYW4oZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gdmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAnJyA/IHRydWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG51bWVyaWMgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSBkZWZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG51bWJlcihlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJvb2xlYW4gdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXG4gKiBmYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSBkZWZcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHN0cmluZyhlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiB2YWw7XG59XG5cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtYXR0cmlidXRlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd3MgPSAvXFxzKy87IC8qKlxuICAgICAgICAgICAgICAgICAqICMgUmVtb3ZlIENsYXNzXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL2RvbS9yZW1vdmUtY2xhc3MuanNcbiAgICAgICAgICAgICAgICAgKi9cblxudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZVswXSk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLy8gc3RvcmUgdHdvIGNvcGllc1xuICB2YXIgY2xzTmFtZSA9ICcgJyArICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnKSArICcgJztcbiAgdmFyIHJlc3VsdCA9IGNsc05hbWU7XG4gIHZhciBjdXJyZW50ID0gdm9pZCAwO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjdXJyZW50ID0gbmFtZVtpXTtcbiAgICBzdGFydCA9IGN1cnJlbnQgPyByZXN1bHQuaW5kZXhPZignICcgKyBjdXJyZW50ICsgJyAnKSA6IC0xO1xuICAgIGlmIChzdGFydCAhPT0gLTEpIHtcbiAgICAgIHN0YXJ0ICs9IDE7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgc3RhcnQpICsgcmVzdWx0LnNsaWNlKHN0YXJ0ICsgY3VycmVudC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9ubHkgd3JpdGUgaWYgbW9kaWZpZWRcbiAgaWYgKGNsc05hbWUgIT09IHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi9hZGQtY2xhc3MnKTtcblxudmFyIF9hZGRDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRDbGFzcyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MgPSByZXF1aXJlKCcuL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIGVuYWJsZSkge1xuXG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBwYXNzZWQgYW4gYXJyYXksIHRvZ2dsZSB0aGUgY2xhc3Mgb24gZWFjaC5cbiAgaWYgKGVsIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b2dnbGVDbGFzcyhlbFtpXSwgbmFtZSwgZW5hYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWN0aW9uID0gdm9pZCAwO1xuICBpZiAoZW5hYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmFibGUgPSB0eXBlb2YgZW5hYmxlID09PSAnZnVuY3Rpb24nID8gZW5hYmxlLmNhbGwobnVsbCwgZWwpIDogZW5hYmxlO1xuICAgIGFjdGlvbiA9IGVuYWJsZSA/ICdhZGQnIDogJ3JlbW92ZSc7XG4gIH0gZWxzZSB7XG4gICAgYWN0aW9uID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZWwsIG5hbWUpID8gJ3JlbW92ZScgOiAnYWRkJztcbiAgfVxuXG4gIHJldHVybiAoYWN0aW9uID09PSAnYWRkJyA/IF9hZGRDbGFzczIuZGVmYXVsdCA6IF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoZWwsIG5hbWUpO1xufSAvKipcbiAgICogIyBUb2dnbGUgQ2xhc3NcbiAgICogVG9nZ2xlIGEgY2xhc3Mgb24gYW4gZWxlbWVudCBnaXZlbiBhIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICpcbiAgICogQG1vZHVsZSAgaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzXG4gICAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB0b2dnbGVDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9nZ2xlLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEVhY2hcbiAqIEFwcGx5IGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGFueSBraW5kOiBBcnJheSwgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uIG9yIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE5vZGVMaXN0fEhUTUxDb2xsZWN0aW9ufE9iamVjdH0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqXG4gKiBAZXhhbXBsZVxuICogZWFjaChbXSwgY2FsbGJhY2spO1xuICogZWFjaChlbC5jaGlsZHJlbiwgY2FsbGJhY2spO1xuICogZWFjaChlbC5jaGlsZE5vZGVzLCBjYWxsYmFjayk7XG4gKiBlYWNoKHt9LCBjYWxsYmFjayk7XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvZWFjaC5qc1xuICovXG5mdW5jdGlvbiBlYWNoKGxpc3QsIGNiKSB7XG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBgZWFjaGAgd2l0aG91dCBhIGNhbGxiYWNrIScpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgLy8gT2JqZWN0XG4gIGlmIChsZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoaSBpbiBsaXN0KSB7XG4gICAgICBpZiAoaSAhPT0gJ3Byb3RvdHlwZScgJiYgbGlzdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBjYihpLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQXJyYXktbGlrZVxuICBlbHNlIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2IobGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBlYWNoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYWNoLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1peGlucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaXhpbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgKDAsIF9lYWNoMi5kZWZhdWx0KShtaXhpbnMsIGZ1bmN0aW9uIChtaXhpbikge1xuICAgIGZvciAodmFyIGkgaW4gbWl4aW4pIHtcbiAgICAgIGlmIChtaXhpbi5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhcHJvdG9baV0pIHByb3RvW2ldID0gbWl4aW5baV07XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4vZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogIyBNaXhpblxuICogQXBwbHkgYSBtaXhpbiwgb3IgbWl4aW5zLCB0byBhbiBPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogbWl4aW4ocHJvdG8sIG1peCwgbWl4MilcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9taXhpbi5qc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1peGluLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFRyaW1cbiAqIFRyaW0gd2hpdGVzcGFjZSBvbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvdHJpbS5qc1xuICovXG5cbnZhciB0cmltUkUgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh0cmltUkUsICcnKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHJpbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpbS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9oZWlnaHQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2FuaW1hdGlvbi9oZWlnaHQnKTtcblxudmFyIF9oZWlnaHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVpZ2h0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVycm9yIHN0YXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBPcHRpb25hbFxuICAgKi9cbiAgc2V0RXJyb3I6IGZ1bmN0aW9uIHNldEVycm9yKG1lc3NhZ2UpIHtcblxuICAgIC8vIEFuaW1hdGUgZG93blxuICAgIGlmICghdGhpcy5faXNNZXNzYWdlVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLl9zaG93TWVzc2FnZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXJXYXJuaW5nKCk7XG4gICAgdGhpcy5jbGVhclN1Y2Nlc3MoKTtcblxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLWVycm9yJywgdHJ1ZSk7XG5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXJyb3Igc3RhdGUuXG4gICAqL1xuICBjbGVhckVycm9yOiBmdW5jdGlvbiBjbGVhckVycm9yKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWVycm9yJywgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IHRoZSB3YXJuaW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBPcHRpb25hbFxuICAgKi9cbiAgc2V0V2FybmluZzogZnVuY3Rpb24gc2V0V2FybmluZyhtZXNzYWdlKSB7XG5cbiAgICAvLyBBbmltYXRlIGRvd25cbiAgICBpZiAoIXRoaXMuX2lzTWVzc2FnZVZpc2libGUoKSkge1xuICAgICAgdGhpcy5fc2hvd01lc3NhZ2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyRXJyb3IoKTtcbiAgICB0aGlzLmNsZWFyU3VjY2VzcygpO1xuXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2FybmluZycsIHRydWUpO1xuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMuc2V0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgY2xlYXJXYXJuaW5nOiBmdW5jdGlvbiBjbGVhcldhcm5pbmcoKSB7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtd2FybmluZycsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3VjY2VzcyBzdGF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgT3B0aW9uYWxcbiAgICovXG4gIHNldFN1Y2Nlc3M6IGZ1bmN0aW9uIHNldFN1Y2Nlc3MobWVzc2FnZSkge1xuXG4gICAgLy8gQW5pbWF0ZSBkb3duXG4gICAgaWYgKCF0aGlzLl9pc01lc3NhZ2VWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuX3Nob3dNZXNzYWdlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckVycm9yKCk7XG4gICAgdGhpcy5jbGVhcldhcm5pbmcoKTtcblxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN1Y2Nlc3MnLCB0cnVlKTtcblxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IHRoZSBzdWNjZXNzIHN0YXRlLlxuICAgKi9cbiAgY2xlYXJTdWNjZXNzOiBmdW5jdGlvbiBjbGVhclN1Y2Nlc3MoKSB7XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3VjY2VzcycsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBtZXNzYWdlcy5cbiAgICovXG4gIGNsZWFyTWVzc2FnZXM6IGZ1bmN0aW9uIGNsZWFyTWVzc2FnZXMoKSB7XG4gICAgdGhpcy5faGlkZU1lc3NhZ2UoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jbGVhckVycm9yKCk7XG4gICAgICB0aGlzLmNsZWFyV2FybmluZygpO1xuICAgICAgdGhpcy5jbGVhclN1Y2Nlc3MoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWVzc2FnZSB0ZXh0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKi9cbiAgc2V0TWVzc2FnZTogZnVuY3Rpb24gc2V0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlRWwuaW5uZXJIVE1MID0gbWVzc2FnZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBtZXNzYWdlXG4gICAqL1xuICBfc2hvd01lc3NhZ2U6IGZ1bmN0aW9uIF9zaG93TWVzc2FnZSgpIHtcblxuICAgIGlmICghdGhpcy5tZXNzYWdlRWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VFbCk7XG4gICAgfVxuXG4gICAgKDAsIF9oZWlnaHQyLmRlZmF1bHQpKHtcbiAgICAgIGVsOiB0aGlzLmVsLFxuICAgICAgdG9nZ2xlRWw6IHRoaXMubWVzc2FnZUVsXG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogSGlkZSB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF9oaWRlTWVzc2FnZTogZnVuY3Rpb24gX2hpZGVNZXNzYWdlKGNhbGxiYWNrKSB7XG5cbiAgICAoMCwgX2hlaWdodDIuZGVmYXVsdCkoe1xuICAgICAgZWw6IHRoaXMuZWwsXG4gICAgICB0b2dnbGVFbDogdGhpcy5tZXNzYWdlRWwsXG4gICAgICB0b2dnbGVWYWx1ZTogJ25vbmUnLFxuICAgICAgYWN0aW9uOiAnY29sbGFwc2UnLFxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2tcbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBJcyB0aGUgbWVzc2FnZSBjdXJyZW50bHkgdmlzaWJsZT9cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc01lc3NhZ2VWaXNpYmxlOiBmdW5jdGlvbiBfaXNNZXNzYWdlVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXJyb3InKSB8fCB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS13YXJuaW5nJykgfHwgdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3VjY2VzcycpO1xuICB9XG59OyAvKipcbiAgICAqICMgTWVzc2FnaW5nIE1peGluXG4gICAgKiBBZGQgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBtZXNzYWdlcyByZWxhdGVkIHRvIGEgZm9ybSBmaWVsZC5cbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogbWl4aW4oQ29tcG9uZW50LCBtZXNzYWdpbmcpO1xuICAgICpcbiAgICAqIEBtb2R1bGUgbWl4aW4vbWVzc2FnaW5nLmpzXG4gICAgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdpbmcuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBWYWxpZGF0aW9uIE1peGluXG4gKiBBZGQgZnVuY3Rpb25hbGl0eSBmb3IgdmFsaWRhdGluZyBhIGZvcm0gZmllbGQncyB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogbWl4aW4oQ29tcG9uZW50LCB2YWxpZGF0aW9uKTtcbiAqXG4gKiBAbW9kdWxlIG1peGluL3ZhbGlkYXRpb24uanNcbiAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsaWRhdGUgZnVuY3Rpb24uIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBhXG4gICAqIGN1c3RvbSB2YWxpZGF0ZSBtZXRob2QgYXMgYSBwYXJhbWV0ZXIuIFRoaXMgcmVhbGx5IG9ubHkgaGVscHMgb3V0XG4gICAqIG9mIHRoZSBib3ggZm9yIHRleHQgaW5wdXRzLlxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuXG4gICAgdmFyIHZhbGlkYXRlID0gdGhpcy52YWxpZGF0ZVBhdHRlcm47XG5cbiAgICAvLyBOb3RoaW5nIHRvIHZhbGlkYXRlLlxuICAgIGlmICghdGhpcy5vblZhbGlkYXRlIHx8ICF2YWxpZGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWxpZGF0ZSk7XG5cbiAgICB0aGlzLm9uVmFsaWRhdGUocmUudGVzdCh0aGlzLmdldFZhbHVlKCkpLCB0aGlzLmdldFZhbHVlKCksIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbi5qcy5tYXBcbiJdfQ=="}