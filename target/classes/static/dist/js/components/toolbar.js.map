{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/toolbar.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"toolbar.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _debounce = require('../helpers/util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Toolbar\n                                                                                                                                                           * Setup a responsive toolbar\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Toolbar(el);\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/toolbar.js\n                                                                                                                                                           */\n\n\nvar Toolbar = function () {\n\n  /**\n   * Toolbar constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function Toolbar(el) {\n    _classCallCheck(this, Toolbar);\n\n    if (!el) return;\n    this._init(el);\n  }\n\n  /**\n   * This function will update cached sizing when an element in the toolbar is changed\n   * or, when toolbar items are added or removed\n   */\n\n\n  Toolbar.prototype.change = function change() {\n    this._closeAll();\n    (0, _removeClass2.default)(this.el, ['ready', 'show-more', 'measured']);\n    var v = document.createDocumentFragment();\n    for (var i = 0; i < this.items.length; i++) {\n      v.appendChild(this.items[i].el);\n    }\n    this.visibleContainer.appendChild(v);\n    this._initItems();\n    (0, _addClass2.default)(this.el, 'measured');\n    this._calculateStyles();\n    (0, _addClass2.default)(this.el, 'ready');\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Toolbar.prototype.update = function update(el) {\n\n    if (el) {\n      this.remove(true);\n      this._init(el);\n    } else {\n      this.change();\n    }\n\n    return this;\n  };\n\n  /**\n   * Remove the element from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Toolbar.prototype.remove = function remove(leaveElement) {\n    this._removeListeners();\n    delete this.el.sparktoolbarcon;\n    delete this.showMoreButton.sparktoolbarshowmore;\n    for (var i = 0; i < this.items.length; i++) {\n      this.items[i].remove();\n    }\n    if (!leaveElement && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n      this.el = undefined;\n    }\n    return this;\n  };\n\n  /**\n   * Setup a toolbarItem Instance to track the state of individual toolbar items\n   * @param {Element} parent Reference to parent toolbar\n   * @param {Element} el Node to initalize as toolbarItem\n   * @param {Number} order The original index of the item in list of toolbarItems (used for maintaining order when sorting)\n   */\n\n\n  Toolbar.prototype.toolbarItem = function toolbarItem(parent, el, order) {\n    //Setup and cache the values for this item\n    var a = {};\n    a.parent = parent;\n    a.el = el;\n    //cache the priority value present on the toolbar element if it is present, else default to 0\n    a.priority = a.el.attributes['data-priority'] ? a.el.attributes['data-priority'].value : 0;\n    a.order = a.el.attributes['data-order'] ? a.el.attributes['data-order'].value : order;\n    a.hasContent = a.el.querySelector('.spark-toolbar__item--content') ? true : false;\n    a.helper = a.el.querySelector('.spark-toolbar__item-helper');\n    a.label = a.el.attributes.label ? a.el.attributes.label.value : false;\n    a.closeOnClick = (0, _hasClass2.default)(a.el, 'spark-toolbar__item--close-more-on-click');\n    a.width = a.el.offsetWidth;\n    a.height = a.el.offsetHeight;\n    a.dropdown = el.querySelector('.spark-toolbar__item--content');\n    if (a.dropdown) {\n      a.dropdown.sparktoolbardropdown = true;\n    }\n    /**\n     * Call method to toggle the open state, optional param sets open state to value\n     * Can get current state by referencing a.toggleDropdown.open\n     * @param {Boolean} open Set state to this regardless of current state\n     */\n    a.toggleDropdown = function (open) {\n      var o = typeof open !== 'undefined' ? !open : a.toggleDropdown.open;\n      if (o) {\n        a.toggleDropdown.open = false;\n        (0, _removeClass2.default)(a.el, 'animate');\n        window.setTimeout(function () {\n          (0, _removeClass2.default)(a.el, 'open');\n        }, 100);\n      } else {\n        if (a.hasContent) {\n          a.toggleDropdown.open = true;\n          (0, _addClass2.default)(a.el, 'open');\n          a.positionDropdown();\n          var e = document.createEvent('Event');\n          e.initEvent('spark.visible-children', true, true);\n          a.dropdown.dispatchEvent(e);\n          window.setTimeout(function () {\n            (0, _addClass2.default)(a.el, 'animate');\n          }, 0);\n        } else {\n          a.parent._toggleShowMore(false);\n        }\n      }\n    };\n    /**\n     * Click handler for local element - determines to close element\n     * conditionally based on presence of spark-toolbar__item--close-on-click\n     * closes parent's more dropdown conditionally as well\n     * @param {Boolean} open Set state to this regardless of current state\n     */\n    a.handleClick = function (e) {\n\n      if ((0, _parseAttribute.boolean)(a.el, 'disabled')) {\n        e.preventDefault();\n        return;\n      }\n\n      if (!a.toggleDropdown.open) {\n        a.toggleDropdown(true);\n      } else {\n        if (e.target === a.el || e.target === a.helper) {\n          a.toggleDropdown();\n        } else {\n          var b = e.target;\n          while (b !== a.el) {\n            if ((0, _hasClass2.default)(b, 'spark-toolbar__item--close-on-click')) {\n              a.toggleDropdown(false);\n              //close the mode section, as event originated inside a close-on-click area\n              a.parent._toggleShowMore(false);\n              break;\n            }\n            b = b.parentElement;\n          }\n        }\n      }\n      //e.preventDefault();\n    };\n    //perform bounds checking on dropdown open to position dropdown inside visual area\n    //this is called each time a dropdown is opened, in case the state of the component has\n    //changed since initialization\n    a.positionDropdown = function () {\n      if (a.dropdown) {\n        a.dropdown.style.left = '';\n        a.dropdown.style.right = '';\n        var pos = a.dropdown.getBoundingClientRect();\n        var left = window.pageXOffset;\n        var right = window.pageXOffset + document.documentElement.clientWidth;\n        if (pos.right > right) {\n          a.dropdown.style.left = 'inherit';\n          a.dropdown.style.right = 0;\n        }\n        if (pos.left < left) {\n          a.dropdown.style.left = 0;\n          a.dropdown.style.right = 'inherit';\n        }\n      }\n    };\n    a.remove = function () {\n      if (a.el) {\n        delete a.el.sparktoolbar;\n      }\n      if (a.dropdown) {\n        delete a.dropdown.sparktoolbardropdown;\n      }\n    };\n    a.el.sparktoolbar = a;\n    return a;\n  };\n\n  /**\n   * Close any open items, and more dropdown\n   */\n\n\n  Toolbar.prototype._closeAll = function _closeAll() {\n    this._closeItems();\n    this._toggleShowMore(false);\n  };\n\n  /**\n   * Returns array of open toolbarItems\n   */\n\n\n  Toolbar.prototype._getOpenItems = function _getOpenItems() {\n    var a = [];\n    for (var i = 0; i < this.items.length; i++) {\n      if (this.items[i].toggleDropdown.open) {\n        a.push(this.items[i]);\n      }\n    }\n    return a;\n  };\n\n  /**\n   * Close any open items\n   * @param {Array} a Optional array of toolbarItems to close, defaults to all open items\n   */\n\n\n  Toolbar.prototype._closeItems = function _closeItems(a) {\n    a = typeof a === 'undefined' ? this._getOpenItems() : a;\n    for (var i = 0; i < a.length; i++) {\n      a[i].toggleDropdown(false);\n    }\n  };\n\n  /**\n   * Setup the toolbar element, cache properties, and initalize styling\n   * when complete, show toolbar\n   * @param {Element} el The node to initalize on\n   */\n\n\n  Toolbar.prototype._init = function _init(el) {\n    this.el = el;\n    //store a reference to this on the node to expedite event handling\n    this.el.sparktoolbarcon = this;\n    this.visibleContainer = this.el.querySelector('.spark-toolbar__container--visible');\n    this.hiddenContainer = this.el.querySelector('.spark-toolbar__container--hidden');\n    this.showMoreButton = this.el.querySelector('.spark-toolbar__show-more');\n    this.showMoreButton.sparktoolbarshowmore = true;\n    this.isOpen = false;\n    this.isFocus = false;\n    this._setupListeners();\n    this.el.style.width = '100%';\n    this._initItems();\n    (0, _addClass2.default)(this.el, 'measured');\n    this._calculateStyles();\n    this.tabindex = this.el.attributes.tabindex ? this.el.attributes.tabindex.value : 0;\n    (0, _addClass2.default)(this.el, 'ready');\n  };\n\n  Toolbar.prototype._initItems = function _initItems() {\n    var items = this.el.querySelectorAll('.spark-toolbar__item');\n    this.items = [];\n    for (var i = 0; i < items.length; i++) {\n      this.items[i] = new this.toolbarItem(this, items[i], i);\n    }\n  };\n\n  /**\n   * Setup event listeners for clicks and resize events\n   */\n\n\n  Toolbar.prototype._setupListeners = function _setupListeners() {\n    this._handleWindowClick = this._handleWindowClickH.bind(this);\n    document.addEventListener('click', this._handleWindowClick);\n    this._handleResize = (0, _debounce2.default)(this._handleResizeH.bind(this), 100);\n    window.addEventListener('resize', this._handleResize);\n    this._handleKeyDown = this._handleKeyDownH.bind(this);\n    this.el.addEventListener('keydown', this._handleKeyDown);\n    this._handleFocus = this._handleFocusH.bind(this);\n    document.addEventListener('focus', this._handleFocus, true);\n    this._handleBlur = this._handleBlurH.bind(this);\n    document.addEventListener('blur', this._handleBlur, true);\n    this._handleVisibleChildren = this._handleVisibleChildrenH.bind(this);\n    document.addEventListener('spark.visible-children', this._handleVisibleChildren, true);\n  };\n\n  /**\n   * Remove event listeners for clicks and resize events\n   */\n\n\n  Toolbar.prototype._removeListeners = function _removeListeners() {\n    document.removeEventListener('click', this._handleWindowClick);\n    window.removeEventListener('resize', this._handleResize);\n    this.el.removeEventListener('keydown', this._handleKeyDown);\n    document.removeEventListener('blur', this._handleBlur, true);\n    document.removeEventListener('focus', this._handleFocus, true);\n    document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);\n  };\n\n  /**\n   * reset our tab index when user focuses outside of element (gets immediately reset to -1 if focus is placed back inside element)\n   * @param {Event} e The FocusEvent\n   */\n\n\n  Toolbar.prototype._handleBlurH = function _handleBlurH(e) {\n    if (this.el.contains(e.target)) {\n      this.el.attributes.tabindex.value = this.tabindex;\n    }\n  };\n\n  /**\n   * focus handler, works in conjunction with blur handler to set correct tabindex value\n   * @param {Event} e The FocusEvent\n   */\n\n\n  Toolbar.prototype._handleFocusH = function _handleFocusH(e) {\n    //if we're not being focused, reset our tabindex so we are accessible again, and close anything open\n    if (!this.el.contains(e.target)) {\n      this._closeAll();\n      this.el.attributes.tabindex.value = this.tabindex;\n    } else {\n      //set our tabindex to -1 so the user can shift-tab out of our element\n      this.el.attributes.tabindex.value = -1;\n      if (e.target.sparktoolbarcon) {\n        this._focusLast();\n        return;\n      }\n      //handle focusing an item\n      if (e.target.sparktoolbar) {\n        e.target.sparktoolbar.el.focus();\n        return;\n      }\n      var a = e.target;\n      //harder case - look up the tree to find if we're focusing inside content\n      while (!a.sparktoolbarcon) {\n        if (a.sparktoolbar) {\n          break;\n        }\n        //if we are - give our parent element a tabindex so the user can refocus the menu using shift-tab\n        if (a.sparktoolbardropdown) {\n          this.el.attributes.tabindex.value = this.tabindex;\n          return;\n        }\n        a = a.parentElement;\n      }\n    }\n  };\n\n  /**\n   * reset our focus to the last menu item that was focused\n   */\n\n\n  Toolbar.prototype._focusLast = function _focusLast() {\n    if (!this._lastFocus) {\n      var a = this.visibleContainer.querySelector('.spark-toolbar__item') || this.hiddenContainer.querySelector('.spark-toolbar__item');\n      this._lastFocus = a.sparktoolbar;\n    }\n    if (this.hiddenContainer.contains(this._lastFocus.el)) {\n      this._toggleShowMore(true);\n    }\n    this._lastFocus.el.focus();\n  };\n\n  /**\n   * keydown handler, used for keyboard navigation\n   * @param {Event} e The KeyDown Event\n   */\n\n\n  Toolbar.prototype._handleKeyDownH = function _handleKeyDownH(e) {\n    var a = e.target;\n    //find the nearest toolbaritem\n    while (!a.sparktoolbarcon) {\n      if (a.sparktoolbar) {\n        break;\n      }\n      if (a.sparktoolbardropdown) {\n        return;\n      }\n      a = a.parentElement;\n    }\n    if (a.sparktoolbar) {\n      //handle keys\n      switch (e.keyCode) {\n        //left arrow\n        //up arrow\n        case 37:\n        case 38:\n          if (a.previousSibling && a.previousSibling.sparktoolbar) {\n            this._lastFocus = a.previousSibling.sparktoolbar;\n            a.previousSibling.focus();\n          } else {\n            if (this.visibleContainer.querySelector('.spark-toolbar__item') !== a.sparktoolbar.el) {\n              a = this.visibleContainer.querySelector('.spark-toolbar__item:last-of-type');\n              if (a) {\n                this._toggleShowMore(false);\n                this._lastFocus = a.sparktoolbar;\n                a.focus();\n              }\n            }\n          }\n          this._closeItems();\n          e.preventDefault();\n          break;\n        //right arrow\n        //down arrow\n        case 39:\n        case 40:\n          if (a.nextSibling && a.nextSibling.sparktoolbar) {\n            this._lastFocus = a.nextSibling.sparktoolbar;\n            a.nextSibling.focus();\n          } else {\n            if (this.hiddenContainer.querySelector('.spark-toolbar__item:last-of-type') !== a.sparktoolbar.el) {\n              a = this.hiddenContainer.querySelector('.spark-toolbar__item');\n              if (a) {\n                this._toggleShowMore(true);\n                this._lastFocus = a.sparktoolbar;\n                a.focus();\n              }\n            }\n          }\n          this._closeItems();\n          e.preventDefault();\n          break;\n        //spacebar\n        case 32:\n          e.preventDefault();\n          //we only want to toggle the toolbar if we are actually focused directly on it;\n          if (e.target.sparktoolbar) {\n            e.target.sparktoolbar.el.click();\n          }\n          break;\n        //enter\n        case 13:\n          //we only want to toggle the toolbar if we are actually focused directly on it;\n          if (e.target.sparktoolbar) {\n            e.target.sparktoolbar.el.click();\n          }\n          break;\n      }\n    }\n  };\n\n  /**\n   * Hanldes the spark.visible-children event to resize the component when it is made visible.\n   * @param {Event} e The spark.visible-children event\n   */\n\n\n  Toolbar.prototype._handleVisibleChildrenH = function _handleVisibleChildrenH(e) {\n    if (e.target.contains(this.el)) {\n      window.setTimeout(function () {\n        this.change();\n      }.bind(this), 0);\n    }\n  };\n\n  /**\n   * Event handler for click events, handles window clicks, control element clicks,\n   * and forwards events to toolbarItem click handlers as needed\n   * @param {Event} e The click event\n   */\n\n\n  Toolbar.prototype._handleWindowClickH = function _handleWindowClickH(e) {\n\n    if ((0, _parseAttribute.boolean)(e.target, 'disabled')) {\n      e.preventDefault();\n      return;\n    }\n\n    //Check to see if the click was outside of the toolbar\n    if (!this.el.contains(e.target)) {\n      this._closeItems();\n      this._toggleShowMore(false);\n    } else {\n      var a = e.target;\n      //traverse the dom node tree until we find an element that handles the event,\n      //or we reach the toolbar root node\n      if (a === this.visibleContainer || a === this.el) {\n        e.stopPropagation();\n        e.preventDefault();\n        return;\n      }\n      while (a !== this.el) {\n        if (a.sparktoolbar) {\n          var c = this._getOpenItems();\n          if (c.indexOf(a.sparktoolbar) >= 0) {\n            c.splice(c.indexOf(a.sparktoolbar), 1);\n          }\n          this._closeItems(c);\n          if (!this.hiddenContainer.contains(e.target)) {\n            this._toggleShowMore(false);\n          }\n          return a.sparktoolbar.handleClick(e);\n        }\n        if (a.sparktoolbarshowmore) {\n          this._closeItems();\n          this._toggleShowMore();\n          return;\n        }\n        a = a.parentElement;\n      }\n      this._closeAll();\n    }\n  };\n\n  /**\n   * Toggle the state of the show more dropdown, optional parameter overrides toggle and\n   * sets state to passed value\n   * @param {Boolean} open The new state of the show more dropdown\n   */\n\n\n  Toolbar.prototype._toggleShowMore = function _toggleShowMore(open) {\n    var o = typeof open !== 'undefined' ? !open : this.isOpen;\n    if (o) {\n      (0, _removeClass2.default)(this.el, 'animate');\n      window.setTimeout(function () {\n        (0, _removeClass2.default)(this.el, 'open');\n        this.isOpen = false;\n      }.bind(this), 100);\n    } else {\n      this.isOpen = true;\n      (0, _addClass2.default)(this.el, 'open');\n      this._positionShowMore();\n      window.setTimeout(function () {\n        (0, _addClass2.default)(this.el, 'animate');\n      }.bind(this), 0);\n    }\n  };\n\n  /**\n  * Do bounds checking on show-more dropdown when it is opened, and position it accordingly\n  */\n\n\n  Toolbar.prototype._positionShowMore = function _positionShowMore() {\n    this.hiddenContainer.style.right = '0px';\n    var pos = this.hiddenContainer.getBoundingClientRect();\n    var left = window.pageXOffset;\n    var right = window.pageXOffset + document.documentElement.clientWidth;\n    if (pos.right > right) {\n      this.hiddenContainer.style.right = 'calc(' + (pos.right - right) + 'px + 1rem)';\n    }\n    if (pos.left < left) {\n      this.hiddenContainer.style.right = 'calc(' + (pos.left - left) + 'px - 1rem)';\n    }\n  };\n\n  /**\n   * Resize event helper, closes items then triggers recalculation of styles\n   */\n\n\n  Toolbar.prototype._handleResizeH = function _handleResizeH() {\n    this._closeAll();\n    this._calculateStyles();\n  };\n\n  /**\n   * Reevaluates the available area of the toolbar and places toolbarItems into\n   * the hidden container, as necessary. Should not call with any specified value\n   * for showMore (used internally)\n   * @param {Boolean} showMore Used to conditionally evaluate styling when showMore area is used\n   */\n\n\n  Toolbar.prototype._calculateStyles = function _calculateStyles(showMore) {\n    this.el.style.width = '100%';\n    showMore = typeof showMore !== 'undefined' ? showMore : false;\n    if (!showMore) {\n      (0, _removeClass2.default)(this.el, 'show-more');\n    }\n    var visible = [];\n    var hidden = [];\n    var i;\n    //sort items by their priority to ensure higher-priority items are always placed\n    //into the visible area first\n    this.items.sort(this._prioritySort);\n    //get container width and start placing items into their containers\n    var visibleWidth = this.visibleContainer.clientWidth;\n    for (i = 0; i < this.items.length; i++) {\n      if (visibleWidth - this.items[i].width >= 0) {\n        visible.push(this.items[i]);\n        visibleWidth -= this.items[i].width;\n      } else {\n        if (!showMore) {\n          (0, _addClass2.default)(this.el, 'show-more');\n          return this._calculateStyles(true);\n        }\n        hidden.push(this.items[i]);\n      }\n    }\n    //sort items back into their original order before inserting them into the document\n    visible.sort(this._orderSort);\n    hidden.sort(this._orderSort);\n    var v = document.createDocumentFragment();\n    var h = document.createDocumentFragment();\n    for (i = 0; i < visible.length; i++) {\n      v.appendChild(visible[i].el);\n    }\n    for (i = 0; i < hidden.length; i++) {\n      h.appendChild(hidden[i].el);\n    }\n    this.visibleContainer.appendChild(v);\n    this.hiddenContainer.appendChild(h);\n    this.el.style.width = '';\n  };\n\n  /**\n   * Sorts toolbar items in descending order based on their priority value\n   */\n\n\n  Toolbar.prototype._prioritySort = function _prioritySort(l, r) {\n    return r.priority - l.priority;\n  };\n\n  /**\n   * Sorts toolbar items in ascending order based on their order value\n   */\n\n\n  Toolbar.prototype._orderSort = function _orderSort(l, r) {\n    return l.order - r.order;\n  };\n\n  return Toolbar;\n}();\n\nexports.default = Toolbar;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toolbar.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvdG9vbGJhci5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vYWRkLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9oYXMtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC90cmltLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RlYm91bmNlID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL2RlYm91bmNlJyk7XG5cbnZhciBfZGVib3VuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVib3VuY2UpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG52YXIgX3BhcnNlQXR0cmlidXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgVG9vbGJhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNldHVwIGEgcmVzcG9uc2l2ZSB0b29sYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBUb29sYmFyKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy90b29sYmFyLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIFRvb2xiYXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFRvb2xiYXIgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gVG9vbGJhcihlbCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sYmFyKTtcblxuICAgIGlmICghZWwpIHJldHVybjtcbiAgICB0aGlzLl9pbml0KGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXBkYXRlIGNhY2hlZCBzaXppbmcgd2hlbiBhbiBlbGVtZW50IGluIHRoZSB0b29sYmFyIGlzIGNoYW5nZWRcbiAgICogb3IsIHdoZW4gdG9vbGJhciBpdGVtcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIGNoYW5nZSgpIHtcbiAgICB0aGlzLl9jbG9zZUFsbCgpO1xuICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsIFsncmVhZHknLCAnc2hvdy1tb3JlJywgJ21lYXN1cmVkJ10pO1xuICAgIHZhciB2ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdi5hcHBlbmRDaGlsZCh0aGlzLml0ZW1zW2ldLmVsKTtcbiAgICB9XG4gICAgdGhpcy52aXNpYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHYpO1xuICAgIHRoaXMuX2luaXRJdGVtcygpO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdtZWFzdXJlZCcpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVN0eWxlcygpO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdyZWFkeScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbXBvbmVudCB0byB1c2UgYSBuZXcgZWxlbWVudCBvciByZXBhcnNlIGZyb21cbiAgICogdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgT3B0aW9uYWxcbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcblxuICAgIGlmIChlbCkge1xuICAgICAgdGhpcy5yZW1vdmUodHJ1ZSk7XG4gICAgICB0aGlzLl9pbml0KGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFuZ2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSBhbmQgcHJlcGFyZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uIGJ5IGRlcmVmZXJlbmNpbmcgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxlYXZlRWxlbWVudCBMZWF2ZSB0aGUgZWxlbWVudCBpbnRhY3QuXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGxlYXZlRWxlbWVudCkge1xuICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgIGRlbGV0ZSB0aGlzLmVsLnNwYXJrdG9vbGJhcmNvbjtcbiAgICBkZWxldGUgdGhpcy5zaG93TW9yZUJ1dHRvbi5zcGFya3Rvb2xiYXJzaG93bW9yZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghbGVhdmVFbGVtZW50ICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgdGhpcy5lbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIGEgdG9vbGJhckl0ZW0gSW5zdGFuY2UgdG8gdHJhY2sgdGhlIHN0YXRlIG9mIGluZGl2aWR1YWwgdG9vbGJhciBpdGVtc1xuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCBSZWZlcmVuY2UgdG8gcGFyZW50IHRvb2xiYXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBOb2RlIHRvIGluaXRhbGl6ZSBhcyB0b29sYmFySXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3JkZXIgVGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSBpdGVtIGluIGxpc3Qgb2YgdG9vbGJhckl0ZW1zICh1c2VkIGZvciBtYWludGFpbmluZyBvcmRlciB3aGVuIHNvcnRpbmcpXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUudG9vbGJhckl0ZW0gPSBmdW5jdGlvbiB0b29sYmFySXRlbShwYXJlbnQsIGVsLCBvcmRlcikge1xuICAgIC8vU2V0dXAgYW5kIGNhY2hlIHRoZSB2YWx1ZXMgZm9yIHRoaXMgaXRlbVxuICAgIHZhciBhID0ge307XG4gICAgYS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgYS5lbCA9IGVsO1xuICAgIC8vY2FjaGUgdGhlIHByaW9yaXR5IHZhbHVlIHByZXNlbnQgb24gdGhlIHRvb2xiYXIgZWxlbWVudCBpZiBpdCBpcyBwcmVzZW50LCBlbHNlIGRlZmF1bHQgdG8gMFxuICAgIGEucHJpb3JpdHkgPSBhLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtcHJpb3JpdHknXSA/IGEuZWwuYXR0cmlidXRlc1snZGF0YS1wcmlvcml0eSddLnZhbHVlIDogMDtcbiAgICBhLm9yZGVyID0gYS5lbC5hdHRyaWJ1dGVzWydkYXRhLW9yZGVyJ10gPyBhLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtb3JkZXInXS52YWx1ZSA6IG9yZGVyO1xuICAgIGEuaGFzQ29udGVudCA9IGEuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2l0ZW0tLWNvbnRlbnQnKSA/IHRydWUgOiBmYWxzZTtcbiAgICBhLmhlbHBlciA9IGEuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2l0ZW0taGVscGVyJyk7XG4gICAgYS5sYWJlbCA9IGEuZWwuYXR0cmlidXRlcy5sYWJlbCA/IGEuZWwuYXR0cmlidXRlcy5sYWJlbC52YWx1ZSA6IGZhbHNlO1xuICAgIGEuY2xvc2VPbkNsaWNrID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoYS5lbCwgJ3NwYXJrLXRvb2xiYXJfX2l0ZW0tLWNsb3NlLW1vcmUtb24tY2xpY2snKTtcbiAgICBhLndpZHRoID0gYS5lbC5vZmZzZXRXaWR0aDtcbiAgICBhLmhlaWdodCA9IGEuZWwub2Zmc2V0SGVpZ2h0O1xuICAgIGEuZHJvcGRvd24gPSBlbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9faXRlbS0tY29udGVudCcpO1xuICAgIGlmIChhLmRyb3Bkb3duKSB7XG4gICAgICBhLmRyb3Bkb3duLnNwYXJrdG9vbGJhcmRyb3Bkb3duID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBtZXRob2QgdG8gdG9nZ2xlIHRoZSBvcGVuIHN0YXRlLCBvcHRpb25hbCBwYXJhbSBzZXRzIG9wZW4gc3RhdGUgdG8gdmFsdWVcbiAgICAgKiBDYW4gZ2V0IGN1cnJlbnQgc3RhdGUgYnkgcmVmZXJlbmNpbmcgYS50b2dnbGVEcm9wZG93bi5vcGVuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcGVuIFNldCBzdGF0ZSB0byB0aGlzIHJlZ2FyZGxlc3Mgb2YgY3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIGEudG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbiAob3Blbikge1xuICAgICAgdmFyIG8gPSB0eXBlb2Ygb3BlbiAhPT0gJ3VuZGVmaW5lZCcgPyAhb3BlbiA6IGEudG9nZ2xlRHJvcGRvd24ub3BlbjtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGEudG9nZ2xlRHJvcGRvd24ub3BlbiA9IGZhbHNlO1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShhLmVsLCAnYW5pbWF0ZScpO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkoYS5lbCwgJ29wZW4nKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhLmhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBhLnRvZ2dsZURyb3Bkb3duLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGEuZWwsICdvcGVuJyk7XG4gICAgICAgICAgYS5wb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBlLmluaXRFdmVudCgnc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGEuZHJvcGRvd24uZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShhLmVsLCAnYW5pbWF0ZScpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucGFyZW50Ll90b2dnbGVTaG93TW9yZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsaWNrIGhhbmRsZXIgZm9yIGxvY2FsIGVsZW1lbnQgLSBkZXRlcm1pbmVzIHRvIGNsb3NlIGVsZW1lbnRcbiAgICAgKiBjb25kaXRpb25hbGx5IGJhc2VkIG9uIHByZXNlbmNlIG9mIHNwYXJrLXRvb2xiYXJfX2l0ZW0tLWNsb3NlLW9uLWNsaWNrXG4gICAgICogY2xvc2VzIHBhcmVudCdzIG1vcmUgZHJvcGRvd24gY29uZGl0aW9uYWxseSBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcGVuIFNldCBzdGF0ZSB0byB0aGlzIHJlZ2FyZGxlc3Mgb2YgY3VycmVudCBzdGF0ZVxuICAgICAqL1xuICAgIGEuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgICBpZiAoKDAsIF9wYXJzZUF0dHJpYnV0ZS5ib29sZWFuKShhLmVsLCAnZGlzYWJsZWQnKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhLnRvZ2dsZURyb3Bkb3duLm9wZW4pIHtcbiAgICAgICAgYS50b2dnbGVEcm9wZG93bih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gYS5lbCB8fCBlLnRhcmdldCA9PT0gYS5oZWxwZXIpIHtcbiAgICAgICAgICBhLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGIgPSBlLnRhcmdldDtcbiAgICAgICAgICB3aGlsZSAoYiAhPT0gYS5lbCkge1xuICAgICAgICAgICAgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGIsICdzcGFyay10b29sYmFyX19pdGVtLS1jbG9zZS1vbi1jbGljaycpKSB7XG4gICAgICAgICAgICAgIGEudG9nZ2xlRHJvcGRvd24oZmFsc2UpO1xuICAgICAgICAgICAgICAvL2Nsb3NlIHRoZSBtb2RlIHNlY3Rpb24sIGFzIGV2ZW50IG9yaWdpbmF0ZWQgaW5zaWRlIGEgY2xvc2Utb24tY2xpY2sgYXJlYVxuICAgICAgICAgICAgICBhLnBhcmVudC5fdG9nZ2xlU2hvd01vcmUoZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2UucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIC8vcGVyZm9ybSBib3VuZHMgY2hlY2tpbmcgb24gZHJvcGRvd24gb3BlbiB0byBwb3NpdGlvbiBkcm9wZG93biBpbnNpZGUgdmlzdWFsIGFyZWFcbiAgICAvL3RoaXMgaXMgY2FsbGVkIGVhY2ggdGltZSBhIGRyb3Bkb3duIGlzIG9wZW5lZCwgaW4gY2FzZSB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBoYXNcbiAgICAvL2NoYW5nZWQgc2luY2UgaW5pdGlhbGl6YXRpb25cbiAgICBhLnBvc2l0aW9uRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYS5kcm9wZG93bikge1xuICAgICAgICBhLmRyb3Bkb3duLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgYS5kcm9wZG93bi5zdHlsZS5yaWdodCA9ICcnO1xuICAgICAgICB2YXIgcG9zID0gYS5kcm9wZG93bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgIHZhciByaWdodCA9IHdpbmRvdy5wYWdlWE9mZnNldCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKHBvcy5yaWdodCA+IHJpZ2h0KSB7XG4gICAgICAgICAgYS5kcm9wZG93bi5zdHlsZS5sZWZ0ID0gJ2luaGVyaXQnO1xuICAgICAgICAgIGEuZHJvcGRvd24uc3R5bGUucmlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MubGVmdCA8IGxlZnQpIHtcbiAgICAgICAgICBhLmRyb3Bkb3duLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICAgIGEuZHJvcGRvd24uc3R5bGUucmlnaHQgPSAnaW5oZXJpdCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGEucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGEuZWwpIHtcbiAgICAgICAgZGVsZXRlIGEuZWwuc3Bhcmt0b29sYmFyO1xuICAgICAgfVxuICAgICAgaWYgKGEuZHJvcGRvd24pIHtcbiAgICAgICAgZGVsZXRlIGEuZHJvcGRvd24uc3Bhcmt0b29sYmFyZHJvcGRvd247XG4gICAgICB9XG4gICAgfTtcbiAgICBhLmVsLnNwYXJrdG9vbGJhciA9IGE7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIGFueSBvcGVuIGl0ZW1zLCBhbmQgbW9yZSBkcm9wZG93blxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9jbG9zZUFsbCA9IGZ1bmN0aW9uIF9jbG9zZUFsbCgpIHtcbiAgICB0aGlzLl9jbG9zZUl0ZW1zKCk7XG4gICAgdGhpcy5fdG9nZ2xlU2hvd01vcmUoZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IG9mIG9wZW4gdG9vbGJhckl0ZW1zXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2dldE9wZW5JdGVtcyA9IGZ1bmN0aW9uIF9nZXRPcGVuSXRlbXMoKSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLml0ZW1zW2ldLnRvZ2dsZURyb3Bkb3duLm9wZW4pIHtcbiAgICAgICAgYS5wdXNoKHRoaXMuaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgYW55IG9wZW4gaXRlbXNcbiAgICogQHBhcmFtIHtBcnJheX0gYSBPcHRpb25hbCBhcnJheSBvZiB0b29sYmFySXRlbXMgdG8gY2xvc2UsIGRlZmF1bHRzIHRvIGFsbCBvcGVuIGl0ZW1zXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2Nsb3NlSXRlbXMgPSBmdW5jdGlvbiBfY2xvc2VJdGVtcyhhKSB7XG4gICAgYSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/IHRoaXMuX2dldE9wZW5JdGVtcygpIDogYTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFbaV0udG9nZ2xlRHJvcGRvd24oZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIHRvb2xiYXIgZWxlbWVudCwgY2FjaGUgcHJvcGVydGllcywgYW5kIGluaXRhbGl6ZSBzdHlsaW5nXG4gICAqIHdoZW4gY29tcGxldGUsIHNob3cgdG9vbGJhclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBub2RlIHRvIGluaXRhbGl6ZSBvblxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoZWwpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgLy9zdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIG9uIHRoZSBub2RlIHRvIGV4cGVkaXRlIGV2ZW50IGhhbmRsaW5nXG4gICAgdGhpcy5lbC5zcGFya3Rvb2xiYXJjb24gPSB0aGlzO1xuICAgIHRoaXMudmlzaWJsZUNvbnRhaW5lciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2NvbnRhaW5lci0tdmlzaWJsZScpO1xuICAgIHRoaXMuaGlkZGVuQ29udGFpbmVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9fY29udGFpbmVyLS1oaWRkZW4nKTtcbiAgICB0aGlzLnNob3dNb3JlQnV0dG9uID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9fc2hvdy1tb3JlJyk7XG4gICAgdGhpcy5zaG93TW9yZUJ1dHRvbi5zcGFya3Rvb2xiYXJzaG93bW9yZSA9IHRydWU7XG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICB0aGlzLmlzRm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycygpO1xuICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5faW5pdEl0ZW1zKCk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ21lYXN1cmVkJyk7XG4gICAgdGhpcy5fY2FsY3VsYXRlU3R5bGVzKCk7XG4gICAgdGhpcy50YWJpbmRleCA9IHRoaXMuZWwuYXR0cmlidXRlcy50YWJpbmRleCA/IHRoaXMuZWwuYXR0cmlidXRlcy50YWJpbmRleC52YWx1ZSA6IDA7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3JlYWR5Jyk7XG4gIH07XG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2luaXRJdGVtcyA9IGZ1bmN0aW9uIF9pbml0SXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3BhcmstdG9vbGJhcl9faXRlbScpO1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLml0ZW1zW2ldID0gbmV3IHRoaXMudG9vbGJhckl0ZW0odGhpcywgaXRlbXNbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgZXZlbnQgbGlzdGVuZXJzIGZvciBjbGlja3MgYW5kIHJlc2l6ZSBldmVudHNcbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5fc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfc2V0dXBMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5faGFuZGxlV2luZG93Q2xpY2sgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGlja0guYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrKTtcbiAgICB0aGlzLl9oYW5kbGVSZXNpemUgPSAoMCwgX2RlYm91bmNlMi5kZWZhdWx0KSh0aGlzLl9oYW5kbGVSZXNpemVILmJpbmQodGhpcyksIDEwMCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVJlc2l6ZSk7XG4gICAgdGhpcy5faGFuZGxlS2V5RG93biA9IHRoaXMuX2hhbmRsZUtleURvd25ILmJpbmQodGhpcyk7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5RG93bik7XG4gICAgdGhpcy5faGFuZGxlRm9jdXMgPSB0aGlzLl9oYW5kbGVGb2N1c0guYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2hhbmRsZUZvY3VzLCB0cnVlKTtcbiAgICB0aGlzLl9oYW5kbGVCbHVyID0gdGhpcy5faGFuZGxlQmx1ckguYmluZCh0aGlzKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlQmx1ciwgdHJ1ZSk7XG4gICAgdGhpcy5faGFuZGxlVmlzaWJsZUNoaWxkcmVuID0gdGhpcy5faGFuZGxlVmlzaWJsZUNoaWxkcmVuSC5iaW5kKHRoaXMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NwYXJrLnZpc2libGUtY2hpbGRyZW4nLCB0aGlzLl9oYW5kbGVWaXNpYmxlQ2hpbGRyZW4sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBjbGlja3MgYW5kIHJlc2l6ZSBldmVudHNcbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5fcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5faGFuZGxlUmVzaXplKTtcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlEb3duKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlQmx1ciwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVGb2N1cywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRoaXMuX2hhbmRsZVZpc2libGVDaGlsZHJlbiwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlc2V0IG91ciB0YWIgaW5kZXggd2hlbiB1c2VyIGZvY3VzZXMgb3V0c2lkZSBvZiBlbGVtZW50IChnZXRzIGltbWVkaWF0ZWx5IHJlc2V0IHRvIC0xIGlmIGZvY3VzIGlzIHBsYWNlZCBiYWNrIGluc2lkZSBlbGVtZW50KVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBGb2N1c0V2ZW50XG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2hhbmRsZUJsdXJIID0gZnVuY3Rpb24gX2hhbmRsZUJsdXJIKGUpIHtcbiAgICBpZiAodGhpcy5lbC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgIHRoaXMuZWwuYXR0cmlidXRlcy50YWJpbmRleC52YWx1ZSA9IHRoaXMudGFiaW5kZXg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBmb2N1cyBoYW5kbGVyLCB3b3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIGJsdXIgaGFuZGxlciB0byBzZXQgY29ycmVjdCB0YWJpbmRleCB2YWx1ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBGb2N1c0V2ZW50XG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2hhbmRsZUZvY3VzSCA9IGZ1bmN0aW9uIF9oYW5kbGVGb2N1c0goZSkge1xuICAgIC8vaWYgd2UncmUgbm90IGJlaW5nIGZvY3VzZWQsIHJlc2V0IG91ciB0YWJpbmRleCBzbyB3ZSBhcmUgYWNjZXNzaWJsZSBhZ2FpbiwgYW5kIGNsb3NlIGFueXRoaW5nIG9wZW5cbiAgICBpZiAoIXRoaXMuZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICB0aGlzLl9jbG9zZUFsbCgpO1xuICAgICAgdGhpcy5lbC5hdHRyaWJ1dGVzLnRhYmluZGV4LnZhbHVlID0gdGhpcy50YWJpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9zZXQgb3VyIHRhYmluZGV4IHRvIC0xIHNvIHRoZSB1c2VyIGNhbiBzaGlmdC10YWIgb3V0IG9mIG91ciBlbGVtZW50XG4gICAgICB0aGlzLmVsLmF0dHJpYnV0ZXMudGFiaW5kZXgudmFsdWUgPSAtMTtcbiAgICAgIGlmIChlLnRhcmdldC5zcGFya3Rvb2xiYXJjb24pIHtcbiAgICAgICAgdGhpcy5fZm9jdXNMYXN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vaGFuZGxlIGZvY3VzaW5nIGFuIGl0ZW1cbiAgICAgIGlmIChlLnRhcmdldC5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgZS50YXJnZXQuc3Bhcmt0b29sYmFyLmVsLmZvY3VzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gZS50YXJnZXQ7XG4gICAgICAvL2hhcmRlciBjYXNlIC0gbG9vayB1cCB0aGUgdHJlZSB0byBmaW5kIGlmIHdlJ3JlIGZvY3VzaW5nIGluc2lkZSBjb250ZW50XG4gICAgICB3aGlsZSAoIWEuc3Bhcmt0b29sYmFyY29uKSB7XG4gICAgICAgIGlmIChhLnNwYXJrdG9vbGJhcikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgd2UgYXJlIC0gZ2l2ZSBvdXIgcGFyZW50IGVsZW1lbnQgYSB0YWJpbmRleCBzbyB0aGUgdXNlciBjYW4gcmVmb2N1cyB0aGUgbWVudSB1c2luZyBzaGlmdC10YWJcbiAgICAgICAgaWYgKGEuc3Bhcmt0b29sYmFyZHJvcGRvd24pIHtcbiAgICAgICAgICB0aGlzLmVsLmF0dHJpYnV0ZXMudGFiaW5kZXgudmFsdWUgPSB0aGlzLnRhYmluZGV4O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5wYXJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogcmVzZXQgb3VyIGZvY3VzIHRvIHRoZSBsYXN0IG1lbnUgaXRlbSB0aGF0IHdhcyBmb2N1c2VkXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2ZvY3VzTGFzdCA9IGZ1bmN0aW9uIF9mb2N1c0xhc3QoKSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0Rm9jdXMpIHtcbiAgICAgIHZhciBhID0gdGhpcy52aXNpYmxlQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19pdGVtJykgfHwgdGhpcy5oaWRkZW5Db250YWluZXIucXVlcnlTZWxlY3RvcignLnNwYXJrLXRvb2xiYXJfX2l0ZW0nKTtcbiAgICAgIHRoaXMuX2xhc3RGb2N1cyA9IGEuc3Bhcmt0b29sYmFyO1xuICAgIH1cbiAgICBpZiAodGhpcy5oaWRkZW5Db250YWluZXIuY29udGFpbnModGhpcy5fbGFzdEZvY3VzLmVsKSkge1xuICAgICAgdGhpcy5fdG9nZ2xlU2hvd01vcmUodHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RGb2N1cy5lbC5mb2N1cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBrZXlkb3duIGhhbmRsZXIsIHVzZWQgZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgS2V5RG93biBFdmVudFxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9oYW5kbGVLZXlEb3duSCA9IGZ1bmN0aW9uIF9oYW5kbGVLZXlEb3duSChlKSB7XG4gICAgdmFyIGEgPSBlLnRhcmdldDtcbiAgICAvL2ZpbmQgdGhlIG5lYXJlc3QgdG9vbGJhcml0ZW1cbiAgICB3aGlsZSAoIWEuc3Bhcmt0b29sYmFyY29uKSB7XG4gICAgICBpZiAoYS5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYS5zcGFya3Rvb2xiYXJkcm9wZG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhID0gYS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoYS5zcGFya3Rvb2xiYXIpIHtcbiAgICAgIC8vaGFuZGxlIGtleXNcbiAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgIC8vbGVmdCBhcnJvd1xuICAgICAgICAvL3VwIGFycm93XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgaWYgKGEucHJldmlvdXNTaWJsaW5nICYmIGEucHJldmlvdXNTaWJsaW5nLnNwYXJrdG9vbGJhcikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEZvY3VzID0gYS5wcmV2aW91c1NpYmxpbmcuc3Bhcmt0b29sYmFyO1xuICAgICAgICAgICAgYS5wcmV2aW91c1NpYmxpbmcuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlzaWJsZUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9faXRlbScpICE9PSBhLnNwYXJrdG9vbGJhci5lbCkge1xuICAgICAgICAgICAgICBhID0gdGhpcy52aXNpYmxlQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19pdGVtOmxhc3Qtb2YtdHlwZScpO1xuICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZVNob3dNb3JlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0Rm9jdXMgPSBhLnNwYXJrdG9vbGJhcjtcbiAgICAgICAgICAgICAgICBhLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2xvc2VJdGVtcygpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9yaWdodCBhcnJvd1xuICAgICAgICAvL2Rvd24gYXJyb3dcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBpZiAoYS5uZXh0U2libGluZyAmJiBhLm5leHRTaWJsaW5nLnNwYXJrdG9vbGJhcikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEZvY3VzID0gYS5uZXh0U2libGluZy5zcGFya3Rvb2xiYXI7XG4gICAgICAgICAgICBhLm5leHRTaWJsaW5nLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuc3BhcmstdG9vbGJhcl9faXRlbTpsYXN0LW9mLXR5cGUnKSAhPT0gYS5zcGFya3Rvb2xiYXIuZWwpIHtcbiAgICAgICAgICAgICAgYSA9IHRoaXMuaGlkZGVuQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay10b29sYmFyX19pdGVtJyk7XG4gICAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlU2hvd01vcmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEZvY3VzID0gYS5zcGFya3Rvb2xiYXI7XG4gICAgICAgICAgICAgICAgYS5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2Nsb3NlSXRlbXMoKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vc3BhY2ViYXJcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgLy93ZSBvbmx5IHdhbnQgdG8gdG9nZ2xlIHRoZSB0b29sYmFyIGlmIHdlIGFyZSBhY3R1YWxseSBmb2N1c2VkIGRpcmVjdGx5IG9uIGl0O1xuICAgICAgICAgIGlmIChlLnRhcmdldC5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnNwYXJrdG9vbGJhci5lbC5jbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9lbnRlclxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIC8vd2Ugb25seSB3YW50IHRvIHRvZ2dsZSB0aGUgdG9vbGJhciBpZiB3ZSBhcmUgYWN0dWFsbHkgZm9jdXNlZCBkaXJlY3RseSBvbiBpdDtcbiAgICAgICAgICBpZiAoZS50YXJnZXQuc3Bhcmt0b29sYmFyKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5zcGFya3Rvb2xiYXIuZWwuY2xpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5sZGVzIHRoZSBzcGFyay52aXNpYmxlLWNoaWxkcmVuIGV2ZW50IHRvIHJlc2l6ZSB0aGUgY29tcG9uZW50IHdoZW4gaXQgaXMgbWFkZSB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBzcGFyay52aXNpYmxlLWNoaWxkcmVuIGV2ZW50XG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2hhbmRsZVZpc2libGVDaGlsZHJlbkggPSBmdW5jdGlvbiBfaGFuZGxlVmlzaWJsZUNoaWxkcmVuSChlKSB7XG4gICAgaWYgKGUudGFyZ2V0LmNvbnRhaW5zKHRoaXMuZWwpKSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlKCk7XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgY2xpY2sgZXZlbnRzLCBoYW5kbGVzIHdpbmRvdyBjbGlja3MsIGNvbnRyb2wgZWxlbWVudCBjbGlja3MsXG4gICAqIGFuZCBmb3J3YXJkcyBldmVudHMgdG8gdG9vbGJhckl0ZW0gY2xpY2sgaGFuZGxlcnMgYXMgbmVlZGVkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGNsaWNrIGV2ZW50XG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2hhbmRsZVdpbmRvd0NsaWNrSCA9IGZ1bmN0aW9uIF9oYW5kbGVXaW5kb3dDbGlja0goZSkge1xuXG4gICAgaWYgKCgwLCBfcGFyc2VBdHRyaWJ1dGUuYm9vbGVhbikoZS50YXJnZXQsICdkaXNhYmxlZCcpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy9DaGVjayB0byBzZWUgaWYgdGhlIGNsaWNrIHdhcyBvdXRzaWRlIG9mIHRoZSB0b29sYmFyXG4gICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgdGhpcy5fY2xvc2VJdGVtcygpO1xuICAgICAgdGhpcy5fdG9nZ2xlU2hvd01vcmUoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYSA9IGUudGFyZ2V0O1xuICAgICAgLy90cmF2ZXJzZSB0aGUgZG9tIG5vZGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGVsZW1lbnQgdGhhdCBoYW5kbGVzIHRoZSBldmVudCxcbiAgICAgIC8vb3Igd2UgcmVhY2ggdGhlIHRvb2xiYXIgcm9vdCBub2RlXG4gICAgICBpZiAoYSA9PT0gdGhpcy52aXNpYmxlQ29udGFpbmVyIHx8IGEgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAoYSAhPT0gdGhpcy5lbCkge1xuICAgICAgICBpZiAoYS5zcGFya3Rvb2xiYXIpIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuX2dldE9wZW5JdGVtcygpO1xuICAgICAgICAgIGlmIChjLmluZGV4T2YoYS5zcGFya3Rvb2xiYXIpID49IDApIHtcbiAgICAgICAgICAgIGMuc3BsaWNlKGMuaW5kZXhPZihhLnNwYXJrdG9vbGJhciksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jbG9zZUl0ZW1zKGMpO1xuICAgICAgICAgIGlmICghdGhpcy5oaWRkZW5Db250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVTaG93TW9yZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhLnNwYXJrdG9vbGJhci5oYW5kbGVDbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5zcGFya3Rvb2xiYXJzaG93bW9yZSkge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlSXRlbXMoKTtcbiAgICAgICAgICB0aGlzLl90b2dnbGVTaG93TW9yZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5wYXJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xvc2VBbGwoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIHNob3cgbW9yZSBkcm9wZG93biwgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyB0b2dnbGUgYW5kXG4gICAqIHNldHMgc3RhdGUgdG8gcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3BlbiBUaGUgbmV3IHN0YXRlIG9mIHRoZSBzaG93IG1vcmUgZHJvcGRvd25cbiAgICovXG5cblxuICBUb29sYmFyLnByb3RvdHlwZS5fdG9nZ2xlU2hvd01vcmUgPSBmdW5jdGlvbiBfdG9nZ2xlU2hvd01vcmUob3Blbikge1xuICAgIHZhciBvID0gdHlwZW9mIG9wZW4gIT09ICd1bmRlZmluZWQnID8gIW9wZW4gOiB0aGlzLmlzT3BlbjtcbiAgICBpZiAobykge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ2FuaW1hdGUnKTtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ29wZW4nKTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ29wZW4nKTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU2hvd01vcmUoKTtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ2FuaW1hdGUnKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIERvIGJvdW5kcyBjaGVja2luZyBvbiBzaG93LW1vcmUgZHJvcGRvd24gd2hlbiBpdCBpcyBvcGVuZWQsIGFuZCBwb3NpdGlvbiBpdCBhY2NvcmRpbmdseVxuICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX3Bvc2l0aW9uU2hvd01vcmUgPSBmdW5jdGlvbiBfcG9zaXRpb25TaG93TW9yZSgpIHtcbiAgICB0aGlzLmhpZGRlbkNvbnRhaW5lci5zdHlsZS5yaWdodCA9ICcwcHgnO1xuICAgIHZhciBwb3MgPSB0aGlzLmhpZGRlbkNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB2YXIgcmlnaHQgPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgaWYgKHBvcy5yaWdodCA+IHJpZ2h0KSB7XG4gICAgICB0aGlzLmhpZGRlbkNvbnRhaW5lci5zdHlsZS5yaWdodCA9ICdjYWxjKCcgKyAocG9zLnJpZ2h0IC0gcmlnaHQpICsgJ3B4ICsgMXJlbSknO1xuICAgIH1cbiAgICBpZiAocG9zLmxlZnQgPCBsZWZ0KSB7XG4gICAgICB0aGlzLmhpZGRlbkNvbnRhaW5lci5zdHlsZS5yaWdodCA9ICdjYWxjKCcgKyAocG9zLmxlZnQgLSBsZWZ0KSArICdweCAtIDFyZW0pJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBldmVudCBoZWxwZXIsIGNsb3NlcyBpdGVtcyB0aGVuIHRyaWdnZXJzIHJlY2FsY3VsYXRpb24gb2Ygc3R5bGVzXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2hhbmRsZVJlc2l6ZUggPSBmdW5jdGlvbiBfaGFuZGxlUmVzaXplSCgpIHtcbiAgICB0aGlzLl9jbG9zZUFsbCgpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZVN0eWxlcygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWV2YWx1YXRlcyB0aGUgYXZhaWxhYmxlIGFyZWEgb2YgdGhlIHRvb2xiYXIgYW5kIHBsYWNlcyB0b29sYmFySXRlbXMgaW50b1xuICAgKiB0aGUgaGlkZGVuIGNvbnRhaW5lciwgYXMgbmVjZXNzYXJ5LiBTaG91bGQgbm90IGNhbGwgd2l0aCBhbnkgc3BlY2lmaWVkIHZhbHVlXG4gICAqIGZvciBzaG93TW9yZSAodXNlZCBpbnRlcm5hbGx5KVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dNb3JlIFVzZWQgdG8gY29uZGl0aW9uYWxseSBldmFsdWF0ZSBzdHlsaW5nIHdoZW4gc2hvd01vcmUgYXJlYSBpcyB1c2VkXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX2NhbGN1bGF0ZVN0eWxlcyA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVTdHlsZXMoc2hvd01vcmUpIHtcbiAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHNob3dNb3JlID0gdHlwZW9mIHNob3dNb3JlICE9PSAndW5kZWZpbmVkJyA/IHNob3dNb3JlIDogZmFsc2U7XG4gICAgaWYgKCFzaG93TW9yZSkge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3Nob3ctbW9yZScpO1xuICAgIH1cbiAgICB2YXIgdmlzaWJsZSA9IFtdO1xuICAgIHZhciBoaWRkZW4gPSBbXTtcbiAgICB2YXIgaTtcbiAgICAvL3NvcnQgaXRlbXMgYnkgdGhlaXIgcHJpb3JpdHkgdG8gZW5zdXJlIGhpZ2hlci1wcmlvcml0eSBpdGVtcyBhcmUgYWx3YXlzIHBsYWNlZFxuICAgIC8vaW50byB0aGUgdmlzaWJsZSBhcmVhIGZpcnN0XG4gICAgdGhpcy5pdGVtcy5zb3J0KHRoaXMuX3ByaW9yaXR5U29ydCk7XG4gICAgLy9nZXQgY29udGFpbmVyIHdpZHRoIGFuZCBzdGFydCBwbGFjaW5nIGl0ZW1zIGludG8gdGhlaXIgY29udGFpbmVyc1xuICAgIHZhciB2aXNpYmxlV2lkdGggPSB0aGlzLnZpc2libGVDb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2aXNpYmxlV2lkdGggLSB0aGlzLml0ZW1zW2ldLndpZHRoID49IDApIHtcbiAgICAgICAgdmlzaWJsZS5wdXNoKHRoaXMuaXRlbXNbaV0pO1xuICAgICAgICB2aXNpYmxlV2lkdGggLT0gdGhpcy5pdGVtc1tpXS53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc2hvd01vcmUpIHtcbiAgICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmVsLCAnc2hvdy1tb3JlJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVN0eWxlcyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRkZW4ucHVzaCh0aGlzLml0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9zb3J0IGl0ZW1zIGJhY2sgaW50byB0aGVpciBvcmlnaW5hbCBvcmRlciBiZWZvcmUgaW5zZXJ0aW5nIHRoZW0gaW50byB0aGUgZG9jdW1lbnRcbiAgICB2aXNpYmxlLnNvcnQodGhpcy5fb3JkZXJTb3J0KTtcbiAgICBoaWRkZW4uc29ydCh0aGlzLl9vcmRlclNvcnQpO1xuICAgIHZhciB2ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBoID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2LmFwcGVuZENoaWxkKHZpc2libGVbaV0uZWwpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoLmFwcGVuZENoaWxkKGhpZGRlbltpXS5lbCk7XG4gICAgfVxuICAgIHRoaXMudmlzaWJsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh2KTtcbiAgICB0aGlzLmhpZGRlbkNvbnRhaW5lci5hcHBlbmRDaGlsZChoKTtcbiAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRvb2xiYXIgaXRlbXMgaW4gZGVzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGVpciBwcmlvcml0eSB2YWx1ZVxuICAgKi9cblxuXG4gIFRvb2xiYXIucHJvdG90eXBlLl9wcmlvcml0eVNvcnQgPSBmdW5jdGlvbiBfcHJpb3JpdHlTb3J0KGwsIHIpIHtcbiAgICByZXR1cm4gci5wcmlvcml0eSAtIGwucHJpb3JpdHk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRvb2xiYXIgaXRlbXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoZWlyIG9yZGVyIHZhbHVlXG4gICAqL1xuXG5cbiAgVG9vbGJhci5wcm90b3R5cGUuX29yZGVyU29ydCA9IGZ1bmN0aW9uIF9vcmRlclNvcnQobCwgcikge1xuICAgIHJldHVybiBsLm9yZGVyIC0gci5vcmRlcjtcbiAgfTtcblxuICByZXR1cm4gVG9vbGJhcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbGJhcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbGJhci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBQYXJzZSBET00gYXR0cmlidXRlc1xuICogR2l2ZW4gYW4gZWxlbWVudCBhbmQgYW4gYXR0cmlidXRlIG5hbWUsIHBhcnNlIHRoYXQgYXR0cmlidXRlXG4gKiBpZiBpdCBleGlzdHMgb3IgcmV0dXJuIGEgZGVmYXVsdC5cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBib29sZWFuIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sZWFuKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJycgPyB0cnVlIDogZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBudW1lcmljIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBudW1iZXIoZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBib29sZWFuIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBzdHJpbmcoZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gdmFsO1xufVxuXG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWF0dHJpYnV0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdzID0gL1xccysvOyAvKipcbiAgICAgICAgICAgICAgICAgKiAjIFJlbW92ZSBDbGFzc1xuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzXG4gICAgICAgICAgICAgICAgICovXG5cbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSBlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVbMF0pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8vIHN0b3JlIHR3byBjb3BpZXNcbiAgdmFyIGNsc05hbWUgPSAnICcgKyAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJykgKyAnICc7XG4gIHZhciByZXN1bHQgPSBjbHNOYW1lO1xuICB2YXIgY3VycmVudCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3VycmVudCA9IG5hbWVbaV07XG4gICAgc3RhcnQgPSBjdXJyZW50ID8gcmVzdWx0LmluZGV4T2YoJyAnICsgY3VycmVudCArICcgJykgOiAtMTtcbiAgICBpZiAoc3RhcnQgIT09IC0xKSB7XG4gICAgICBzdGFydCArPSAxO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHN0YXJ0KSArIHJlc3VsdC5zbGljZShzdGFydCArIGN1cnJlbnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHdyaXRlIGlmIG1vZGlmaWVkXG4gIGlmIChjbHNOYW1lICE9PSByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtY2xhc3MuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBEZWJvdW5jZVxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBjYWxsXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtJbnRlZ2VyfSBkZWxheVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2RlYm91bmNlLmpzXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIGRlbGF5KSB7XG5cbiAgdmFyIHRpbWVyID0gdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHRpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSwgZGVsYXkpO1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWJvdW5jZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBUcmltXG4gKiBUcmltIHdoaXRlc3BhY2Ugb24gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL3RyaW0uanNcbiAqL1xuXG52YXIgdHJpbVJFID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodHJpbVJFLCAnJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW0uanMubWFwXG4iXX0="}