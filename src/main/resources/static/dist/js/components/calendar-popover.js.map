{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/calendar-popover.js","js/dist/components/js/dist/components/popover.js","js/dist/components/js/dist/helpers/animation/request.js","js/dist/components/js/dist/helpers/animation/scroll-to.js","js/dist/components/js/dist/helpers/animation/tween.js","js/dist/components/js/dist/helpers/date/date.js","js/dist/components/js/dist/helpers/date/parse-format.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/breakpoint.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/offset.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/dom/trigger-event.js","js/dist/components/js/dist/helpers/form/build-select.js","js/dist/components/js/dist/helpers/manipulation/append-children.js","js/dist/components/js/dist/helpers/position/affix.js","js/dist/components/js/dist/helpers/position/box-position.js","js/dist/components/js/dist/helpers/traversal/get-parent.js","js/dist/components/js/dist/helpers/traversal/get-sibling-after.js","js/dist/components/js/dist/helpers/traversal/get-sibling-before.js","js/dist/components/js/dist/helpers/traversal/has-parent.js","js/dist/components/js/dist/helpers/traversal/matches.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/pad.js","js/dist/components/js/dist/helpers/util/range.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvmEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"calendar-popover.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _popover = require('./popover');\n\nvar _popover2 = _interopRequireDefault(_popover);\n\nvar _parseFormat = require('../helpers/date/parse-format');\n\nvar _parseFormat2 = _interopRequireDefault(_parseFormat);\n\nvar _date = require('../helpers/date/date');\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _buildSelect = require('../helpers/form/build-select');\n\nvar _buildSelect2 = _interopRequireDefault(_buildSelect);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _triggerEvent = require('../helpers/dom/trigger-event');\n\nvar _triggerEvent2 = _interopRequireDefault(_triggerEvent);\n\nvar _breakpoint = require('../helpers/dom/breakpoint');\n\nvar _scrollTo = require('../helpers/animation/scroll-to');\n\nvar _scrollTo2 = _interopRequireDefault(_scrollTo);\n\nvar _getSiblingBefore = require('../helpers/traversal/get-sibling-before');\n\nvar _getSiblingBefore2 = _interopRequireDefault(_getSiblingBefore);\n\nvar _getSiblingAfter = require('../helpers/traversal/get-sibling-after');\n\nvar _getSiblingAfter2 = _interopRequireDefault(_getSiblingAfter);\n\nvar _range = require('../helpers/util/range');\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Calendar Popover\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Create a calendar from which dates can be selected.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new CalendarPopover(el);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/calendar-popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\nvar domDateFormat = 'YYYY-MM-DD';\nvar parsedDomFormat = (0, _parseFormat2.default)(domDateFormat);\n\nfunction createDefaultElement() {\n  var el = document.createElement('span');\n  el.className = 'spark-input spark-date';\n  el.innerHTML = '<input class=\"spark-input__field\" type=\"date\"><span class=\"spark-label\"></span>';\n  return el;\n}\n\n/**\n * Parse the proper params for initialization\n * @param  {Element} el\n * @param  {Object} params\n * @return {Objec}\n */\nfunction parseInitParams(el, params) {\n\n  // If the first element is an array or array-like (NodeList),\n  // we will be working with a range.\n  if (el && el.hasOwnProperty('length')) {\n    params.els = el;\n  }\n  // If the first argument is a plain object, create a default element\n  // since the user MUST provide additional params but the element\n  // is optional. Doing it this way to keep the arity the same\n  // as other components.\n  else if (!(el instanceof HTMLElement)) {\n      params = el || {};\n      params.els = [createDefaultElement()];\n    }\n    // A single element is passed.\n    else {\n        params.els = [el];\n      }\n\n  params.visibleCounts = params.visibleCounts || (params.visibleCount ? [params.visibleCount] : null);\n  params.mins = params.mins || (params.min ? [params.min] : []);\n  params.maxes = params.maxes || (params.max ? [params.max] : []);\n  params.values = params.values || (params.value ? [params.value] : []);\n\n  return params;\n}\n\nvar CalendarPopover = function (_BaseComponent) {\n  _inherits(CalendarPopover, _BaseComponent);\n\n  /**\n   * Calendar Popover constructor\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n  function CalendarPopover(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, CalendarPopover);\n\n    params = parseInitParams(el, params);\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    // Create a calendar element if we weren't passed one.\n    (_this.calendarEl ? noop : _this._createCalendar).call(_this);\n    _this._cacheCalendarElements();\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._initDatesToShow();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  CalendarPopover.prototype.update = function update(el) {\n\n    if (el) {\n      this._removeEventListeners();\n      this.els = el instanceof Array ? el : [el];\n      this._cacheElements();\n      this._addEventListeners();\n    }\n\n    this._initDatesToShow();\n\n    if (this.activeIndex !== null) {\n      this.render();\n      this._checkSize();\n    }\n\n    return this;\n  };\n\n  /**\n   * Open the calendar widget.\n   * @param {Number} index Optional The index of the element to tie actions to\n   * @param {Object} params Optional\n   */\n\n\n  CalendarPopover.prototype.open = function open() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._isDisabled[index]) {\n      return this;\n    }\n\n    this._unfillToggle();\n\n    // Allow for only params to be passed\n    if ((typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'object') {\n      params = index;\n      index = 0;\n    }\n\n    // Already open\n    if (this.activeIndex === index) {\n      return this;\n    }\n\n    // We have an already active item, close it\n    if (this.activeIndex !== null) {\n      this._deactivateElement(this.activeIndex);\n    }\n\n    // Clear any timers which may be running to close or open this\n    clearTimeout(this._openCloseTimer);\n\n    // Set the new index\n    this.activeIndex = index;\n\n    // If we don't have a popover yet, create it.\n    if (!this.popover) {\n      this._createPopover();\n    }\n\n    // Get the list of dates to show for this view.\n    this._initDatesToShow();\n\n    // Ensure the cached values are in line with the input values.\n    this.updateValues();\n\n    // Create a calendar or calendars inside the popover\n    this.render({\n      clearCache: true\n    });\n\n    // Finally, show the popover after a delay or on the next tick.\n    this._openCloseTimer = setTimeout(function () {\n      this.popover.open({\n        affixTo: this.els[index].querySelector('.spark-date__calendar-toggle')\n      });\n    }.bind(this), params.delay || 0);\n\n    // Activate the corresponding element\n    this._activateElement(index);\n\n    return this;\n  };\n\n  /**\n   * Close the calendar widget.\n   * @param {Object} params\n   */\n\n\n  CalendarPopover.prototype.close = function close(params) {\n\n    this._unfillToggle();\n\n    params = params || {};\n\n    // Can't close if we aren't or haven't yet opened.\n    if (this.activeIndex === null || !this.popover) {\n      return this;\n    }\n\n    // Deactive the corresponding element\n    this._deactivateElement(this.activeIndex);\n\n    // Clear any existing close or open events which are queued\n    clearTimeout(this._openCloseTimer);\n\n    // Close after a delay, or on the next tick\n    this.activeIndex = null;\n    this._openCloseTimer = setTimeout(function () {\n      this.popover.close();\n    }.bind(this), params.delay || 0);\n  };\n\n  /**\n   * Get the value.\n   * @param {Number|Element} index Optional\n   * @return {Mixed}\n   */\n\n\n  CalendarPopover.prototype.getValue = function getValue(index) {\n    return this.values[index || 0];\n  };\n\n  /**\n   * Set the date for a given element.\n   * @param {String|Object} value\n   * @param {Number|Element} index\n   * @param {Boolean} skipRangeCheck Optional Don't check for sequential range values.\n   */\n\n\n  CalendarPopover.prototype.setValue = function setValue(value, index, skipRangeCheck) {\n\n    var obj = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : parsedDomFormat.getValues(value);\n    var el = void 0;\n\n    // If we are passed an element instead of an index, use that.\n    if (index instanceof HTMLElement) {\n      el = index;\n      index = this.inputEls.indexOf(el);\n    }\n    // Otherwise, find the element in our list.\n    else {\n        index = index || 0;\n        el = this.inputEls[index];\n      }\n\n    // Update the stored value\n    this.values[index] = obj;\n\n    // If we are working with a range, make sure that the values are in order.\n    if (value) {\n      this._checkValues(index, skipRangeCheck);\n    }\n\n    // Set the value on the input element. Make sure we don't get into an infinite\n    // loop since we listen to the change event on the input. We have to trigger it\n    // so that other components listening to it get the update.\n    el.value = value && obj === value ? parsedDomFormat.getString(value) : value || '';\n\n    this._inputsChanging = this._inputsChanging || [];\n    if (this._inputsChanging.indexOf(index) === -1) {\n      this._inputsChanging.push(index);\n\n      (0, _triggerEvent2.default)(el, 'change');\n      (this.onChange || noop)(el, el.value, this);\n\n      var pos = this._inputsChanging.indexOf(index);\n      this._inputsChanging.splice(pos, 1);\n    }\n\n    this.render({\n      clearCache: true\n    });\n\n    return this;\n  };\n\n  /**\n   * Clear the selected values.\n   */\n\n\n  CalendarPopover.prototype.clearValues = function clearValues() {\n\n    var els = this.inputEls;\n    var i = 0;\n    var len = els.length;\n\n    for (; i < len; i++) {\n      this.clearValue(i);\n    }\n\n    return this;\n  };\n\n  /**\n   * Clear the selected value.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.clearValue = function clearValue() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this.values = this.values || [];\n    if (!this.inputEls[index]) throw new Error('Cannot clear value at index ' + index + '. No input element exists with that index!');\n    this.values[index] = this.inputEls[index].value = null;\n    return this;\n  };\n\n  /**\n   * Take the date values from the inputs and set them as dates on the calendar.\n   */\n\n\n  CalendarPopover.prototype.updateValues = function updateValues() {\n\n    var els = this.inputEls;\n    var i = 0;\n    var len = els.length;\n\n    for (; i < len; i++) {\n      this.updateValue(i);\n    }\n\n    return this;\n  };\n\n  /**\n   * Take the date values from the inputs and set them as dates on the calendar.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.updateValue = function updateValue() {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this.values = this.values || [];\n    if (!this.inputEls[index]) throw new Error('Cannot update value at index ' + index + '. No input element exists with that index!');\n    this.values[index] = this.inputEls[index].value ? parsedDomFormat.getValues(this.inputEls[index].value) : null;\n    return this;\n  };\n\n  /**\n   * Disable the calendar functionality.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.disable = function disable(index) {\n\n    var i = index || 0;\n    var len = index !== undefined ? index + 1 : this.els.length;\n    var toggle = void 0;\n\n    for (; i < len; i++) {\n      this._isDisabled[i] = true;\n      this.els[i].setAttribute('disabled', '');\n      toggle = this.els[i].querySelector('.spark-date__calendar-toggle');\n      if (toggle) toggle.setAttribute('disabled', '');\n    }\n\n    this.close();\n\n    return this;\n  };\n\n  /**\n   * Enable the calendar functionality.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype.enable = function enable(index) {\n\n    var i = index || 0;\n    var len = index !== undefined ? index + 1 : this.els.length;\n    var toggle = void 0;\n\n    for (; i < len; i++) {\n      this._isDisabled[i] = false;\n      this.els[i].removeAttribute('disabled', '');\n      toggle = this.els[i].querySelector('.spark-date__calendar-toggle');\n      if (toggle) toggle.removeAttribute('disabled');\n    }\n\n    return this;\n  };\n\n  /**\n   * Render the calendar or calendars into the popover.\n   * @param {Object} params\n   */\n\n\n  CalendarPopover.prototype.render = function render(params) {\n\n    params = params || {};\n\n    // If we don't have a popover yet, create it.\n    if (!this.popover) {\n      this._createPopover();\n    }\n\n    var content = void 0;\n\n    // Clear the cache so that we don't show out-of-date values.\n    if (params.clearCache) {\n      this._renderCache = {};\n    }\n\n    // Create the visible days, weeks, months or years\n    if (this.viewRange === 'year') content = this._renderYears();else if (this.viewRange === 'week') content = this._renderWeeks();else if (this.viewRange === 'day') content = this._renderDays();else content = this._renderMonths();\n\n    this._insertContent(content, params);\n\n    // Update attributes\n    this._updateAttributes();\n\n    return this;\n  };\n\n  /**\n   * Cleans up event listeners and removes helpers.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  CalendarPopover.prototype.remove = function remove(leaveElement) {\n    this.popover.remove();\n    return _BaseComponent.prototype.remove.call(this, leaveElement);\n  };\n\n  /**\n   * Move to the next set of dates.\n   */\n\n\n  CalendarPopover.prototype.next = function next() {\n    if (this._atMax) return this;\n    this._setDatesToShow(1);\n    this.render({\n      append: 1\n    });\n    return this;\n  };\n\n  /**\n   * Move to the previous set of dates.\n   */\n\n\n  CalendarPopover.prototype.previous = function previous() {\n    if (this._atMin) return this;\n    this._setDatesToShow(-1);\n    this.render({\n      prepend: 1\n    });\n    return this;\n  };\n\n  /**\n   * Show a specific date on the calendar.\n   * @param {Object} params\n   */\n\n\n  CalendarPopover.prototype.showDate = function showDate(params) {\n\n    // Open if we're closed.\n    if (this.activeIndex === null) {\n      this.open();\n    }\n\n    var month = params.month || null;\n    var year = params.year || null;\n    var day = params.day || null;\n\n    // Nothing to do.\n    if (!month && !year && !day) {\n      return this;\n    }\n\n    var showing = this._datesToShow[this.activeIndex].clone();\n    var noun = this.viewRange.charAt(0).toUpperCase() + this.viewRange.slice(1);\n\n    // Only change the values we were given\n    if (year) {\n      showing.year = year;\n    }\n    if (month) {\n      showing.month = month;\n    }\n    if (day) {\n      showing.day = day;\n    }\n\n    // Check min\n    var min = this.mins[this.activeIndex];\n    if (min && showing['before' + noun](min)) {\n      showing = min.clone();\n    }\n\n    // Check max\n    var max = this.maxes[this.activeIndex];\n    if (max && showing['after' + noun](max)) {\n      showing = max.clone();\n    }\n    this._datesToShow[this.activeIndex] = showing;\n\n    // Populate the rest of the dates\n    this._setDatesToShow();\n\n    return this.render();\n  };\n\n  /**\n   * Render the appropriate number of years.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderYears = function _renderYears() {\n    throw new Error('Displaying years in the calendar is not yet supported!');\n  };\n\n  /**\n   * Render the appropriate number of weeks.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderWeeks = function _renderWeeks() {\n    throw new Error('Displaying weeks in the calendar is not yet supported!');\n  };\n\n  /**\n   * Render the appropriate number of days.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderDays = function _renderDays() {\n    throw new Error('Displaying days in the calendar is not yet supported!');\n  };\n\n  /**\n   * Render the appropriate number of months.\n   * @return {Array}\n   */\n\n\n  CalendarPopover.prototype._renderMonths = function _renderMonths() {\n\n    var months = [];\n    var i = 0;\n    var len = this._datesToShow.length;\n    var current = _date2.default.now();\n\n    for (; i < len; i++) {\n      months.push(this._renderMonth(this._datesToShow[i], current));\n    }\n\n    return months;\n  };\n\n  /**\n   * Render a month.\n   * @param {Object} date\n   * @param {Object} current\n   * @return {Element}\n   */\n\n\n  CalendarPopover.prototype._renderMonth = function _renderMonth(date, current) {\n\n    // A unique key for this month used for caching\n    var key = date.year + '-' + date.month;\n\n    // Ensure we have a cache\n    this._renderCache = this._renderCache || {};\n\n    // Return a cached instance\n    if (this._renderCache[key]) {\n      return this._renderCache[key];\n    }\n\n    // Create the element\n    var el = document.createElement('div');\n    var html = '';\n    el.className = 'spark-calendar__month ' + this._getMonthClassNames(date);\n\n    // Add the title or dropdowns.\n    html += '<div class=\"spark-calendar__month-title\">';\n    if (this.quickJump && this.visibleCounts[this.activeIndex] === 1) {\n      html += this._renderMonthQuickJump(date);\n    } else {\n      html += date.monthName + ' ' + date.year;\n    }\n    html += '</div>';\n\n    // Add the days of the week headings\n    html += this._renderMonthDaysOfWeek();\n\n    // Add the days\n    html += this._renderMonthDays(date, current);\n\n    el.innerHTML = html;\n\n    // Store in the cache and return\n    return this._renderCache[key] = el;\n  };\n\n  /**\n   * Render the select inputs used for jumping ahead/backward several months.\n   * @param {Object} date\n   */\n\n\n  CalendarPopover.prototype._renderMonthQuickJump = function _renderMonthQuickJump(date) {\n\n    var el = document.createElement('div');\n    var years = void 0;\n    var months = void 0;\n\n    // Min and max year to show\n    var min = this.mins[this.activeIndex] ? this.mins[this.activeIndex].clone() : null;\n    var max = this.maxes[this.activeIndex] ? this.maxes[this.activeIndex].clone() : null;\n\n    // No min, go 50 years back\n    if (!min) {\n      min = date.clone();\n      min.year = min.year - 50;\n    }\n\n    // No max, go 50 years forward\n    if (!max) {\n      max = date.clone();\n      max.year = max.year + 50;\n    }\n\n    // Get the months to show.\n    var monthOpts = _date2.default.getMonthNames().map(function (val, i) {\n\n      // Don't show a month that is out of the valid range.\n      if (min.year === max.year && (i + 1 < min.month || i + 1 > max.month)) {\n        return null;\n      }\n\n      return {\n        value: i + 1,\n        text: val\n      };\n    }).filter(function (i) {\n      return i;\n    });\n\n    // Min and max are the same month, so just show text.\n    if (!monthOpts.length || monthOpts.length === 1) {\n      months = document.createElement('span');\n      months.innerHTML = date.monthName + ' ';\n    } else {\n\n      // Build a select list of months\n      months = document.createElement('label');\n      (0, _addClass2.default)(months, 'spark-select spark-calendar__select');\n      months.appendChild((0, _buildSelect2.default)({\n        selected: date.month,\n        attributes: {\n          class: 'spark-select__input',\n          name: 'month'\n        },\n        options: monthOpts\n      }));\n    }\n\n    // Min and max year are the same, so just show text.\n    if (min.year === max.year) {\n      years = document.createElement('span');\n      years.innerHTML = date.year;\n    } else {\n\n      // Build a select list of years\n      years = document.createElement('label');\n      (0, _addClass2.default)(years, 'spark-select spark-calendar__select');\n      years.appendChild((0, _buildSelect2.default)({\n        selected: date.year,\n        attributes: {\n          class: 'spark-select__input',\n          name: 'year'\n        },\n        options: (0, _range2.default)(max.year, min.year - 1)\n      }));\n    }\n\n    (0, _appendChildren2.default)(el, [months, years]);\n\n    return el.innerHTML;\n  };\n\n  /**\n   * Render the days of week row for a month calendar.\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._renderMonthDaysOfWeek = function _renderMonthDaysOfWeek() {\n\n    var daysOfWeek = _date2.default.getDayNames();\n    var i = 0;\n    var len = daysOfWeek.length;\n    var str = '<div class=\"spark-calendar__days-of-week\">';\n\n    for (; i < len; i++) {\n      str += '<span class=\"spark-calendar__day-of-week\">' + daysOfWeek[i][0] + '</span>';\n    }\n\n    return str += '</div>';\n  };\n\n  /**\n   * Render the days of week row for a month calendar.\n   * @param {Object} date\n   * @param {Object} current\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._renderMonthDays = function _renderMonthDays(date, current) {\n\n    var dayOfWeek = date.monthStart.dayOfWeek;\n    var startOfWeek = dayOfWeek > 1 ? date.monthStart.weekStart : null;\n    var monthEnd = date.monthEnd;\n    var weeks = 6;\n    var i = 0;\n    var j = 0;\n    var str = '<div class=\"spark-calendar__days\">';\n    var day = 0;\n    var month = startOfWeek ? startOfWeek.month : date.month;\n    var year = startOfWeek ? startOfWeek.year : date.year;\n    var isCurrentMonth = current.year === date.year && current.month === date.month;\n\n    // If we have days that come before the first of the month, the days will start as\n    // inactive. We use a 1 here to indicate the date is inactive and _before_\n    // the start of the month.\n    var inactive = startOfWeek ? 1 : null;\n\n    for (; i < weeks; i++) {\n      for (; j < 7; j++) {\n\n        day = startOfWeek ? startOfWeek.day + j : day + 1;\n        str += this._renderMonthDay(day, month, year, isCurrentMonth, current, inactive);\n\n        if (startOfWeek && j + 1 >= dayOfWeek - 1) {\n          startOfWeek = null;\n          inactive = null;\n          day = 0;\n          month = date.month;\n          year = date.year;\n          isCurrentMonth = current.year === date.year && current.month === date.month;\n        } else if (day >= monthEnd.day && i > 0) {\n\n          // Inactive days that come _after_ the last of the month are denoted with a 2.\n          // _renderMonthDay handles 1s and 2s differently, but both add the inactive class.\n          inactive = 2;\n          isCurrentMonth = false;\n\n          day = 0;\n          month++;\n\n          if (month > 12) {\n            year++;\n            month = 1;\n          }\n        }\n      }\n      j = 0;\n    }\n\n    return str += '</div>';\n  };\n\n  /**\n   * Render a day of the month.\n   * @param {Number} day\n   * @param {Number} month\n   * @param {Number} year\n   * @param {Boolean} isCurrentMonth\n   * @param {Object} current\n   * @param {Boolean} inactive\n   */\n\n\n  CalendarPopover.prototype._renderMonthDay = function _renderMonthDay(day, month, year, isCurrentMonth, current, inactive) {\n\n    var date = _date2.default.create({\n      year: year,\n      month: month,\n      day: day\n    });\n    var str = '<a';\n    var disabled = inactive || this._isDayDisabled(date);\n\n    str += !disabled ? ' data-date=\"' + parsedDomFormat.getString(date) + '\"' : '';\n    str += inactive ? ' data-direction=\"' + (inactive === 2 ? 'next' : 'previous') + '\"' : '';\n    str += ' class=\"spark-calendar__day';\n    str += isCurrentMonth && current.day === day && current.month === month && current.year === year ? ' spark-calendar__day--today' : '';\n    str += inactive ? ' spark-calendar__day--inactive' : '';\n    str += disabled ? ' spark-calendar__day--disabled' : '';\n    str += this._isDaySelected(date) ? ' spark-calendar__day--selected' : '';\n    str += this._isDayRangeStart(date) ? ' spark-calendar__range-start' : '';\n    str += this._isDayRangeMiddle(date) ? ' spark-calendar__range-middle' : '';\n    str += this._isDayRangeEnd(date) ? ' spark-calendar__range-end' : '';\n    str += this._isDayRangeLast(date) ? ' spark-calendar__range-last' : '';\n    str += '\"';\n    str += ' href=\"#\"><span>';\n    str += day;\n    str += this._getDayInfo(date);\n    str += '</span></a>';\n\n    return str;\n  };\n\n  /**\n   * Render the children into the content.\n   * @param {Array} content\n   */\n\n\n  CalendarPopover.prototype._insertContent = function _insertContent(content, params) {\n\n    this._currentContent = this._currentContent || [];\n\n    params = params || {};\n\n    var keep = void 0;\n    var i = 0;\n    var len = void 0;\n\n    // If we've been asked to prepend or append, add the new elements in front,\n    // save the number of old elements we're sliding out, animate,\n    // then clean up.\n    if (this.animate) {\n\n      if (params.prepend) {\n\n        // Get the last elements to keep\n        keep = this._currentContent.slice(-params.prepend);\n        len = keep.length;\n        for (; i < len; i++) {\n          content.push(keep[i]);\n        }\n\n        this.calendarEl.setAttribute('data-prepend-count', len);\n\n        this._animateContent(function () {\n\n          this.calendarEl.removeAttribute('data-prepend-count');\n\n          this._animateContent(function () {\n            content = content.slice(0, -params.prepend);\n            this._insertContent(content);\n          }, this.animationDuration);\n        }, 10);\n      }\n      // Same but appending\n      else if (params.append) {\n\n          // Get the first elements to keep\n          keep = this._currentContent.slice(0, params.append);\n          len = keep.length;\n          for (; i < len; i++) {\n            content.unshift(keep[i]);\n          }\n\n          this.calendarEl.setAttribute('data-append-count', len);\n\n          this._animateContent(function () {\n\n            (0, _addClass2.default)(this.calendarEl, 'no-animate');\n            content = content.slice(params.append);\n            this._insertContent(content);\n            this.calendarEl.removeAttribute('data-append-count');\n\n            this._animateContent(function () {\n              (0, _removeClass2.default)(this.calendarEl, 'no-animate');\n            }, 10);\n          }, this.animationDuration);\n        }\n    }\n\n    (0, _appendChildren2.default)(this.calendarContentEl, this._currentContent = content, true);\n  };\n\n  /**\n   * Is a given day selected?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDaySelected = function _isDaySelected(date) {\n    return this.values && date.equal(this.values);\n  };\n\n  /**\n   * Is a given day the start of a range?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeStart = function _isDayRangeStart(date) {\n    return this.inputEls.length > 1 && this.values && date.equal(this.values[0]);\n  };\n\n  /**\n   * Is a given day the middle of a range?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeMiddle = function _isDayRangeMiddle(date) {\n    return this.inputEls.length > 1 && this.values && this.values.length > 1 && date.equal(this.values.slice(1, -1));\n  };\n\n  /**\n   * Is a given day the end of a range?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeEnd = function _isDayRangeEnd(date) {\n    return this.inputEls.length > 1 && this.values && this.values.length > 1 && date.equal(this.values[this.values.length - 1]);\n  };\n\n  /**\n   * Is a given day currently the last\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayRangeLast = function _isDayRangeLast(date) {\n\n    var i = this.values.length - 1;\n\n    for (; i > 0; i--) {\n\n      // We have a value and it's not the same as the date.\n      if (this.values[i]) {\n        if (!date.equal(this.values[i])) {\n          return false;\n        }\n        break;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Is a given day disabled?\n   * @param {Object} date\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._isDayDisabled = function _isDayDisabled(date) {\n    return this.daysDisabled && this.daysDisabled[date.year] && this.daysDisabled[date.year][date.month] && this.daysDisabled[date.year][date.month].indexOf(date.day) !== -1 || this.mins[this.activeIndex] && date.before(this.mins[this.activeIndex], true) || this.maxes[this.activeIndex] && date.after(this.maxes[this.activeIndex], true);\n  };\n\n  /**\n   * Get any \"info\" for a given day.\n   * @param {Object} date\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._getDayInfo = function _getDayInfo(date) {\n    return this.daysInfo && this.daysInfo[date.year] && this.daysInfo[date.year][date.month] && this.daysInfo[date.year][date.month][date.day] ? '<span class=\"spark-calendar__day-note\">' + this.daysInfo[date.year][date.month][date.day] + '</span>' : '';\n  };\n\n  /**\n   * Get the class names for a month.\n   * @param {Object} date\n   * @return {String}\n   */\n\n\n  CalendarPopover.prototype._getMonthClassNames = function _getMonthClassNames(date) {\n\n    var cls = [];\n\n    // Do we have a value in this month?\n    if (date.equalMonth(this.values)) {\n      cls.push('has-value');\n    }\n\n    // Does this month have the start, middle or end of a range?\n    if (this._isRange && this.els.length > 1) {\n\n      var start = date.equalMonth(this.values[0]);\n      var end = date.equalMonth(this.values[this.values.length - 1]);\n      var middle = date.equalMonth(this.values.slice(1, -1));\n      var valBefore = date.afterMonth(this.values);\n      var valAfter = date.beforeMonth(this.values);\n      var afterEnd = this.values[this.values.length - 1] && date.after(this.values[this.values.length - 1]);\n\n      if (start) {\n        cls.push('range-start');\n      }\n      if (end) {\n        cls.push('range-end');\n      }\n      if (middle) {\n        cls.push('range-middle');\n      }\n      if (valBefore) {\n        cls.push('value-before');\n      }\n      if (valAfter) {\n        cls.push('value-after');\n      }\n      if (afterEnd) {\n        cls.push('after-range-end');\n      }\n    }\n\n    return cls.join(' ');\n  };\n\n  /**\n   * Create the calendar.\n   */\n\n\n  CalendarPopover.prototype._createCalendar = function _createCalendar() {\n    var el = document.createElement('div');\n    (0, _addClass2.default)(el, 'spark-calendar');\n    el.innerHTML = '<nav class=\"spark-calendar__nav\"><button class=\"spark-calendar__previous spark-icon-chevron-left\" title=\"Previous\"></button><button class=\"spark-calendar__next spark-icon-chevron-right\" title=\"Next\"></button></nav><div class=\"spark-calendar__overflow\"><div class=\"spark-calendar__content\"></div></div>';\n    this.calendarEl = el;\n    this.calendarContentEl = el.querySelector('.spark-calendar__content');\n    this.calendarOverflowEl = el.querySelector('.spark-calendar_overflow');\n  };\n\n  /**\n   * Create the popover.\n   */\n\n\n  CalendarPopover.prototype._createPopover = function _createPopover() {\n\n    this.popover = new _popover2.default(document.createElement('div'), {\n      anchorX: 'center',\n      anchorY: 'bottom',\n      contentEl: this.calendarEl,\n      onClose: this._onPopoverClose.bind(this),\n      onOpen: this._onPopoverOpen.bind(this)\n    });\n  };\n\n  /**\n   * Cache elements.\n   */\n\n\n  CalendarPopover.prototype._cacheElements = function _cacheElements() {\n\n    this.inputEls = [];\n\n    var i = 0;\n    var len = this.els.length;\n    var input = void 0;\n\n    for (; i < len; i++) {\n      input = this.els[i].nodeName.toLowerCase() === 'input' ? this.els[i] : this.els[i].querySelector('input[type=\"date\"]');\n      this.inputEls[i] = input;\n    }\n  };\n\n  /**\n   * Cache elements specific to the calendar.\n   */\n\n\n  CalendarPopover.prototype._cacheCalendarElements = function _cacheCalendarElements() {\n    this.nextButtonEl = this.calendarEl.querySelector('.spark-calendar__next');\n    this.previousButtonEl = this.calendarEl.querySelector('.spark-calendar__previous');\n  };\n\n  /**\n   * Parse parameters from the elements.\n   */\n\n\n  CalendarPopover.prototype._parseParams = function _parseParams() {\n\n    this._parseInputElsParams();\n\n    this._isRange = this.els.length > 1 ? true : false;\n    this.autoAdvance = this.autoAdvance !== null ? this.autoAdvance : (0, _parseAttribute.boolean)(this.els[0], 'data-auto-advance', true);\n    this.autoClose = this.autoClose !== null ? this.autoClose : (0, _parseAttribute.boolean)(this.els[0], 'data-auto-close', true);\n    this.closeDelay = this.closeDelay !== null ? this.closeDelay : (0, _parseAttribute.number)(this.els[0], 'data-close-delay', 500);\n    this.quickJump = this.quickJump !== null ? this.quickJump : (0, _parseAttribute.boolean)(this.els[0], 'data-quick-jump', false);\n    this.viewRange = this.viewRange !== null ? this.viewRange : (0, _parseAttribute.string)(this.els[0], 'data-view-range', 'month');\n    this.animate = this.animate !== null ? this.animate : (0, _parseAttribute.boolean)(this.els[0], 'data-animate', true);\n    this.animationDuration = this.animationDuration !== null ? this.animationDuration : (0, _parseAttribute.number)(this.els[0], 'data-animation-duration', 100);\n    this.showOnFocus = this.showOnFocus !== null ? this.showOnFocus : (0, _parseAttribute.boolean)(this.els[0], 'data-show-on-focus', false);\n  };\n\n  /**\n   * Parse the min, max, value and visible counts from the elements if we can.\n   * @return {Number|Boolean}\n   */\n\n\n  CalendarPopover.prototype._parseInputElsParams = function _parseInputElsParams() {\n\n    var els = this.inputEls;\n\n    if (!els) {\n      return;\n    }\n\n    var i = 0;\n    var len = els.length;\n    var mins = [];\n    var maxes = [];\n    var values = [];\n    var visibleCounts = [];\n    var disableds = [];\n\n    for (; i < len; i++) {\n\n      if (!els[i]) {\n        continue;\n      }\n\n      if (this.mins && this.mins[i]) mins[i] = _typeof(this.mins[i]) === 'object' ? this.mins[i] : parsedDomFormat.getValues(this.mins[i]);else if (els[i].getAttribute('min')) mins[i] = parsedDomFormat.getValues(els[i].getAttribute('min'));\n\n      if (this.maxes && this.maxes[i]) maxes[i] = _typeof(this.maxes[i]) === 'object' ? this.maxes[i] : parsedDomFormat.getValues(this.maxes[i]);else if (els[i].getAttribute('max')) maxes[i] = parsedDomFormat.getValues(els[i].getAttribute('max'));\n\n      if (this.values && this.values[i]) values[i] = _typeof(this.values[i]) === 'object' ? this.values[i] : parsedDomFormat.getValues(this.values[i]);else if (els[i].value) values[i] = parsedDomFormat.getValues(els[i].value);\n\n      disableds[i] = (0, _parseAttribute.boolean)(els[i], 'disabled', false);\n\n      if (!this.visibleCounts) visibleCounts[i] = parseInt(els[i].getAttribute('data-visible-count'), 10) || 1;\n    }\n\n    this.mins = mins;\n    this.minVisible = _date2.default.earliest(mins);\n    this.maxes = maxes;\n    this.maxVisible = _date2.default.latest(maxes);\n    this.values = values;\n    this._isDisabled = disableds;\n    if (visibleCounts.length) this.visibleCounts = visibleCounts;\n  };\n\n  /**\n   * Get the dates we should be showing. Start with the first value or today's date.\n   */\n\n\n  CalendarPopover.prototype._initDatesToShow = function _initDatesToShow() {\n\n    var arr = [];\n    var i = 0;\n    var len = this.values.length;\n\n    // Get the date for the current index\n    if (this.values[this.activeIndex]) {\n      arr.push(this.values[this.activeIndex].clone());\n    }\n\n    // Get the first date\n    for (; i < len && !arr.length; i++) {\n      if (this.values[i]) {\n        arr.push(this.values[i].clone());\n      }\n    }\n\n    // If we didn't get a date, use the min\n    for (i = 0, len = this.mins.length; i < len && !arr.length; i++) {\n      if (this.mins[i]) {\n        arr.push(this.mins[i].clone());\n      }\n    }\n\n    // If we still didn't get a date, add today's date.\n    if (!arr.length) {\n      arr.push(_date2.default.now());\n    }\n\n    this._datesToShow = arr;\n\n    this._setDatesToShow();\n  };\n\n  /**\n   * Set the dates to show.\n   * @param {Number} change Optional The direction to change\n   */\n\n\n  CalendarPopover.prototype._setDatesToShow = function _setDatesToShow(change) {\n\n    var arr = this._datesToShow;\n    var visibleCount = this._currentBreakpoint === 'xs' || this._currentBreakpoint === 'sm' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1;\n    var i = 0;\n    var noun = this.viewRange.charAt(0).toUpperCase() + this.viewRange.slice(1);\n\n    // If we have more dates to show than we're supposed to show, remove the excess.\n    // This happens when visible count changes between renders\n    if (arr.length > visibleCount) {\n      arr.splice(visibleCount);\n    }\n\n    // If we are incrementing or decrementing the starting month\n    if (change) {\n\n      // Empty the rest of the dates from the array\n      arr = this._datesToShow = arr.splice(0, 1);\n\n      // Decrement\n      if (change < 0) {\n        for (; i > change; i--) {\n          arr[0] = arr[0]['previous' + noun];\n        }\n      } else {\n        for (; i < change; i++) {\n          arr[0] = arr[0]['next' + noun];\n        }\n      }\n    }\n\n    // Check bounds\n    this._atMin = this._checkMinDateVisible(noun, arr);\n    this._atMax = this._checkMaxDateVisible(noun, arr);\n\n    var addDate = void 0;\n    var lastSelected = void 0;\n    var action = void 0;\n    i = 0;\n\n    // Add additional dates\n    while (arr.length < visibleCount) {\n\n      // If at the max, prepend\n      // If we're in the last input and it has a value and it's a different month than the first value, prepend\n      // If at the min, append\n      // If an item we're adding is before the min, discard it and append an item after the last in the arr\n      // If an item we're adding is after the max, discard it and prepend an item before the first in the arr\n\n      lastSelected = !change && this.activeIndex === this.values.length - 1 && this.values[this.values.length - 1] && this.values[0] && !this.values[this.values.length - 1]['equal' + noun](this.values, true);\n\n      // If we're showing the max date or we have the last input selected and it has a value, add dates before.\n      if (this._atMax || lastSelected) {\n\n        addDate = arr[i]['previous' + noun];\n        action = 'unshift';\n\n        if (addDate['before' + noun](this.minVisible)) {\n          addDate = arr[i]['next' + noun];\n          action = 'push';\n        }\n      } else {\n\n        addDate = arr[i]['next' + noun];\n        action = 'push';\n\n        if (addDate['after' + noun](this.maxVisible)) {\n          addDate = arr[i]['previous' + noun];\n          action = 'unshift';\n        }\n      }\n\n      if (action === 'push') {\n        arr.push(addDate);\n        i = arr.length - 1;\n      } else {\n        arr.unshift(addDate);\n        i = 0;\n      }\n    }\n\n    // Check bounds again\n    this._atMin = this._checkMinDateVisible(noun, arr);\n    this._atMax = this._checkMaxDateVisible(noun, arr);\n\n    // Update the navigation to reflect the _atMin or _atMax state\n    this._updateNav();\n  };\n\n  /**\n   * Check for the min value in an array of values.\n   * @param {Object} min\n   * @param {String} noun The type of date to check\n   * @param {Array} arr\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._checkMinDateVisible = function _checkMinDateVisible(noun, arr) {\n\n    if (!this.minVisible) {\n      return;\n    }\n\n    var min = this.minVisible;\n\n    if (min && (arr[0]['equal' + noun](min) || arr[0]['before' + noun](min))) {\n      arr[0] = min;\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Check for the max value in an array of values.\n   * @param {Object} max\n   * @param {String} noun The type of date to check\n   * @param {Array} arr\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._checkMaxDateVisible = function _checkMaxDateVisible(noun, arr) {\n\n    if (!this.maxVisible) {\n      return;\n    }\n\n    var max = this.maxVisible;\n\n    if (max && arr[arr.length - 1] && (arr[arr.length - 1]['equal' + noun](max) || arr[arr.length - 1]['after' + noun](max))) {\n      arr[arr.length - 1] = max;\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Check that the values are in bounds and, optinoally, in sequential order.\n   * If checking for sequence, remove those which aren't.\n   * @param {Number} setIndex The index of the value most recently set. This shouldn't be removed.\n   * @return {Boolean} Did any values change?\n   */\n\n\n  CalendarPopover.prototype._checkValues = function _checkValues(setIndex, skipRangeCheck) {\n\n    // Check boundaries\n    var changed = this._checkMinMaxValues();\n\n    // Sequential range items check\n    if (this._isRange && !skipRangeCheck) {\n\n      var i = this.values.length - 1;\n\n      for (; i >= 0; i--) {\n        if (this.values[i] && this.values[i - 1] && this.values[i].beforeDay(this.values[i - 1], true)) {\n          if (i === setIndex) {\n            this.setValue(null, i - 1, true);\n          } else {\n            this.setValue(null, i, true);\n          }\n          changed = true;\n        }\n      }\n    }\n\n    return changed;\n  };\n\n  /**\n   * Check minimum/maximum values.\n   * @return {Boolean}\n   */\n\n\n  CalendarPopover.prototype._checkMinMaxValues = function _checkMinMaxValues() {\n\n    var i = 0;\n    var len = this.values.length;\n    var changed = false;\n\n    for (; i < len; i++) {\n      if (this.maxes && this.maxes[i] && this.values[i] && this.values[i].after(this.maxes[i], true)) {\n        this.values[i] = this.maxes[i].clone();\n        changed = true;\n      } else if (this.mins && this.mins[i] && this.values[i] && this.values[i].before(this.mins[i], true)) {\n        this.values[i] = this.mins[i].clone();\n        changed = true;\n      }\n    }\n\n    return changed;\n  };\n\n  /**\n   * Enqueue animations to be run. (Not really animations since those happen w/ CSS. More\n   * of a manager of timeouts).\n   * @param {Function} cb\n   * @param {Number} duration\n   */\n\n\n  CalendarPopover.prototype._animateContent = function _animateContent(cb, duration) {\n    this._animationQueue = this._animationQueue || [];\n    this._animationQueue.push({\n      cb: cb,\n      d: duration\n    });\n    this._runAnimation();\n  };\n\n  /**\n   * Run the first queued animation. When complete, run the next animation.\n   */\n\n\n  CalendarPopover.prototype._runAnimation = function _runAnimation() {\n\n    if (!this._animationTimer) {\n\n      var a = this._animationQueue.shift();\n\n      if (a) {\n\n        this._animationTimer = setTimeout(function () {\n          a.cb.call(this);\n          this._animationTimer = null;\n          this._runAnimation();\n        }.bind(this), a.d);\n      }\n    }\n  };\n\n  /**\n   * Update attributes on the element and its children.\n   */\n\n\n  CalendarPopover.prototype._updateAttributes = function _updateAttributes() {\n    this.calendarEl.setAttribute('data-visible-count', this._currentBreakpoint === 'xs' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1);\n    this._updateNav();\n  };\n\n  /**\n   * Update the navigation to reflect the ability to move forward and backward.\n   */\n\n\n  CalendarPopover.prototype._updateNav = function _updateNav() {\n\n    if (this.previousButtonEl) {\n      if (this._atMin) this.previousButtonEl.setAttribute('disabled', true);else this.previousButtonEl.removeAttribute('disabled');\n    }\n\n    if (this.nextButtonEl) {\n      if (this._atMax) this.nextButtonEl.setAttribute('disabled', true);else this.nextButtonEl.removeAttribute('disabled');\n    }\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  CalendarPopover.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n\n    this._onInputChangeBound = this._onInputChange.bind(this);\n    this._onSelectChangeBound = this._onSelectChange.bind(this);\n    this._onInputFocusBound = this._onInputFocus.bind(this);\n    this._onClickBound = this._onClick.bind(this);\n    this._onCalendarClickBound = this._onCalendarClick.bind(this);\n\n    this._onCalendarMouseOverBound = this._onCalendarMouseOver.bind(this);\n    this._onCalendarMouseOutBound = this._onCalendarMouseOut.bind(this);\n\n    this._onResizeBound = this._onResize.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  CalendarPopover.prototype._addEventListeners = function _addEventListeners() {\n\n    var i = 0;\n    var len = this.els.length;\n\n    for (; i < len; i++) {\n      this.els[i].addEventListener('click', this._onClickBound);\n      this.inputEls[i].addEventListener('change', this._onInputChangeBound);\n      this.inputEls[i].addEventListener('focus', this._onInputFocusBound);\n    }\n\n    this.calendarEl.addEventListener('mouseover', this._onCalendarMouseOverBound);\n    this.calendarEl.addEventListener('mouseout', this._onCalendarMouseOutBound);\n    this.calendarEl.addEventListener('click', this._onCalendarClickBound);\n\n    this.calendarEl.addEventListener('change', this._onSelectChangeBound);\n\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('orientationchange', this._onResizeBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  CalendarPopover.prototype._removeEventListeners = function _removeEventListeners() {\n\n    var i = 0;\n    var len = this.els.length;\n\n    for (; i < len; i++) {\n      this.els[i].removeEventListener('click', this._onClickBound);\n      this.inputEls[i].removeEventListener('change', this._onInputChangeBound);\n      this.inputEls[i].removeEventListener('focus', this._onInputFocusBound);\n    }\n\n    this.calendarEl.removeEventListener('mouseover', this._onCalendarMouseOverBound);\n    this.calendarEl.removeEventListener('mouseout', this._onCalendarMouseOutBound);\n    this.calendarEl.removeEventListener('click', this._onCalendarClickBound);\n\n    this.calendarEl.removeEventListener('change', this._onSelectChangeBound);\n\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('orientationchange', this._onResizeBound);\n  };\n\n  /**\n   * Focus on the next input if there is one.\n   */\n\n\n  CalendarPopover.prototype._focusNext = function _focusNext() {\n\n    var index = void 0;\n\n    // If we don't have any null values, don't do anything.\n    if ((index = this.values.indexOf(null)) === -1) {\n      return;\n    }\n\n    if (this.activeIndex < this.els.length - 1) {\n      this.open(this.activeIndex + 1);\n    } else {\n      this.open(index);\n    }\n  };\n\n  /**\n   * Close if we're on the last input and we have values.\n   */\n\n\n  CalendarPopover.prototype._closeOnLast = function _closeOnLast() {\n    if (this.values.indexOf(null) === -1) {\n      this.close({\n        delay: this.closeDelay\n      });\n    }\n  };\n\n  /**\n   * Make the toggle icon a fill icon.\n   */\n\n\n  CalendarPopover.prototype._fillToggle = function _fillToggle() {\n\n    var toggle = void 0;\n\n    if (this.els[this.activeIndex] && (toggle = this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle [class*=\"spark-icon\"]'))) {\n      (0, _addClass2.default)(toggle, 'spark-icon--fill');\n    }\n  };\n\n  /**\n   * Make the toggle icon a line icon.\n   */\n\n\n  CalendarPopover.prototype._unfillToggle = function _unfillToggle() {\n\n    var toggle = void 0;\n\n    if (this.els[this.activeIndex] && (toggle = this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle [class*=\"spark-icon\"]'))) {\n      (0, _removeClass2.default)(toggle, 'spark-icon--fill');\n    }\n  };\n\n  /**\n   * Activate the element associated with the calendar.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype._activateElement = function _activateElement(index) {\n    var el = this.els[index];\n    if (el) (0, _addClass2.default)(el, 'active');\n  };\n\n  /**\n   * Deactivate the element associated with the calendar.\n   * @param {Number} index\n   */\n\n\n  CalendarPopover.prototype._deactivateElement = function _deactivateElement(index) {\n    var el = this.els[index];\n    if (el && !this.values[index] && !(0, _hasClass2.default)(el, 'focus') && !(0, _hasClass2.default)(el, 'has-partial-value')) {\n      (0, _removeClass2.default)(el, 'active');\n    }\n  };\n\n  /**\n   * Check the size of the popover and see if we should be showing the XS treatment.\n   */\n\n\n  CalendarPopover.prototype._checkSize = function _checkSize() {\n\n    var bp = (0, _breakpoint.get)(window.outerWidth);\n\n    // Don't do anything if the breakpoint hasn't changed.\n    if (this._currentBreakpoint === bp) return;\n\n    // Store the breakpoint\n    this._currentBreakpoint = bp;\n\n    // Re-render the date range\n    this._setDatesToShow();\n    this.render(true);\n    this.popover.update();\n  };\n\n  /**\n   * Scroll the active input element into view.\n   */\n\n\n  CalendarPopover.prototype._scrollToInput = function _scrollToInput() {\n    var el = this.els[this.activeIndex];\n    if (el) (0, _scrollTo2.default)(el);\n  };\n\n  /**\n   * Update the hover classes.\n   * @param {Element} hoverStarts\n   * @param {Element} hoverEnds\n   */\n\n\n  CalendarPopover.prototype._updateHoverClasses = function _updateHoverClasses(hoverStarts, hoverEnds) {\n\n    this._hoverStarts = this._hoverStarts || [];\n    this._hoverEnds = this._hoverEnds || [];\n\n    hoverStarts = hoverStarts instanceof Array ? hoverStarts : hoverStarts ? [hoverStarts] : [];\n    hoverEnds = hoverEnds instanceof Array ? hoverEnds : hoverEnds ? [hoverEnds] : [];\n\n    var allStarts = [];\n    var curStarts = [];\n    var newStarts = [];\n    var allEnds = [];\n    var curEnds = [];\n    var newEnds = [];\n\n    hoverStarts.forEach(function (el) {\n\n      var index = this._hoverStarts.indexOf(el);\n\n      // Already hovered.\n      if (index !== -1) {\n        curStarts.push(el);\n      }\n      // Not already hovered. Ready to add the class.\n      else if (el) {\n          newStarts.push(el);\n          (0, _addClass2.default)(el, 'hover-start');\n        }\n    }, this);\n\n    allStarts = Array.prototype.concat.call([], curStarts, newStarts);\n\n    this._hoverStarts.forEach(function (el) {\n      if (allStarts.indexOf(el) === -1) {\n        (0, _removeClass2.default)(el, 'hover-start');\n      }\n    }, this);\n\n    hoverEnds.forEach(function (el) {\n\n      var index = this._hoverEnds.indexOf(el);\n\n      // Already hovered.\n      if (index !== -1) {\n        curEnds.push(el);\n      }\n      // Not already hovered. Ready to add the class.\n      else if (el) {\n          newEnds.push(el);\n          (0, _addClass2.default)(el, 'hover-end');\n        }\n    }, this);\n\n    allEnds = Array.prototype.concat.call([], curEnds, newEnds);\n\n    this._hoverEnds.forEach(function (el) {\n      if (allEnds.indexOf(el) === -1) {\n        (0, _removeClass2.default)(el, 'hover-end');\n      }\n    }, this);\n\n    this._hoverStarts = allStarts;\n    this._hoverEnds = allEnds;\n  };\n\n  /**\n   * When an element is clicked, if the toggle was the target, open the popover.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onClick = function _onClick(e) {\n\n    if ((0, _getParent2.default)(e.target, '.spark-date__calendar-toggle', this.els)) {\n\n      var el = (0, _getParent2.default)(e.target, '.spark-date', this.els);\n      var index = this.els.indexOf(el);\n\n      e.preventDefault();\n\n      // Open on the next tick. Otherwise we also receive the window click close event.\n      this.open(index, {\n        delay: 1\n      });\n    }\n  };\n\n  /**\n   * When the calendar is hovered, do some highlighting if we're showing a range.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOver = function _onCalendarMouseOver(e) {\n    if (this.viewRange === 'month') this._onCalendarMouseOverMonths(e.target);\n  };\n\n  /**\n   * Set hover states for days.\n   * @param  {Element} target\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOverMonths = function _onCalendarMouseOverMonths(target) {\n\n    if (!this._isRange) {\n      return;\n    }\n\n    var day = (0, _getParent2.default)(target, '.spark-calendar__day');\n\n    if (!day) {\n      this._updateHoverClasses();\n      return;\n    }\n\n    var month = (0, _getParent2.default)(target, '.spark-calendar__month');\n    var mHasClass = function (c) {\n      return (0, _hasClass2.default)(month, c);\n    }.bind(this);\n    var newStart = [];\n    var newEnd = [];\n    var daySel = void 0;\n\n    // Only do highlights if we don't already have a value for this index.\n    if (!this.values[this.activeIndex]) {\n\n      // A month with a value before it but no value of its own, hover starts\n      // from the first day to the hovered day.\n      if (mHasClass('value-before') && !mHasClass('after-range-end') && !mHasClass('has-value') && !mHasClass('value-after')) {\n\n        newStart.push(month.querySelector('.spark-calendar__day:not(.spark-calendar__day--inactive):not(.spark-calendar__day--disabled)'));\n        newEnd.push(day);\n\n        // Add a hover range to a previous month.\n        var prevMonth = month;\n        while ((prevMonth = (0, _getSiblingBefore2.default)(prevMonth, '.spark-calendar__month')) && !(0, _hasClass2.default)(prevMonth, 'value-after') && ((0, _hasClass2.default)(prevMonth, 'has-value') || (0, _hasClass2.default)(prevMonth, 'value-before'))) {\n\n          daySel = prevMonth.querySelectorAll('.spark-calendar__day--selected');\n          daySel = daySel[daySel.length - 1];\n          daySel = daySel || prevMonth.querySelector('.spark-calendar__day');\n\n          if (daySel) {\n            newStart.push(daySel);\n            daySel = prevMonth.querySelectorAll('.spark-calendar__day');\n            daySel = daySel[daySel.length - 1];\n            newEnd.push(daySel);\n          }\n        }\n      }\n      // A month with a value, highlight either from the hovered day to\n      // the selection or from the selection to the day.\n      else if (mHasClass('has-value') && !mHasClass('value-before') && !mHasClass('value-after') && ((newStart = (0, _getSiblingBefore2.default)(day, '.spark-calendar__day--selected')) || (newEnd = (0, _getSiblingAfter2.default)(day, '.spark-calendar__day--selected')))) {\n\n          if (newStart) {\n            newStart = [newStart];\n            newEnd = [day];\n          } else {\n            newEnd = [newEnd];\n            newStart = [day];\n          }\n\n          if ((0, _hasClass2.default)(newEnd[0], 'spark-calendar__range-start') || (0, _hasClass2.default)(newStart[0], 'spark-calendar__range-end')) {\n            newStart = [];\n            newEnd = [];\n          }\n        }\n        // A month with a middle range should highlight before\n        else if (mHasClass('has-value') && mHasClass('range-middle') && mHasClass('value-before')) {\n            daySel = (0, _getSiblingBefore2.default)(day, '.spark-calendar__day--selected');\n            if (daySel) {\n              newStart = [daySel];\n              newEnd = [day];\n            }\n          }\n    }\n\n    this._updateHoverClasses(newStart, newEnd);\n  };\n\n  /**\n   * When the calendar is hovered, undo some highlighting if we're showing a range.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOut = function _onCalendarMouseOut(e) {\n    if (this.viewRange === 'month') this._onCalendarMouseOutMonths(e.target);\n  };\n\n  /**\n   * Clear hover states for days.\n   * @param  {Element} target\n   */\n\n\n  CalendarPopover.prototype._onCalendarMouseOutMonths = function _onCalendarMouseOutMonths(target) {\n\n    var day = (0, _getParent2.default)(target, '.spark-calendar__day');\n    var days = (0, _getParent2.default)(target, '.spark-calendar__days');\n    var month = (0, _getParent2.default)(target, '.spark-calendar__month');\n\n    (0, _removeClass2.default)(day, 'hover');\n    (0, _removeClass2.default)(days, 'hover');\n    (0, _removeClass2.default)(month, 'hover');\n    (0, _removeClass2.default)(this.calendarEl, 'hover');\n  };\n\n  /**\n   * When the calendar is clicked, handle navigation clicks and date selections.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onCalendarClick = function _onCalendarClick(e) {\n\n    var nav = (0, _getParent2.default)(e.target, '.spark-calendar__nav', this.calendarEl);\n    var day = void 0;\n    var dir = void 0;\n\n    // Navigation clicks\n    if (nav) {\n\n      // Previous\n      if ((0, _getParent2.default)(e.target, '.spark-calendar__previous', nav)) {\n        this.previous();\n      }\n      // Next\n      else if ((0, _getParent2.default)(e.target, '.spark-calendar__next', nav)) {\n          this.next();\n        }\n    }\n    // Day click\n    else if (day = (0, _getParent2.default)(e.target, '.spark-calendar__day')) {\n\n        e.preventDefault();\n        e.stopPropagation();\n\n        // Disabled day moves can move us to the next month\n        if ((0, _hasClass2.default)(day, 'spark-calendar__day--disabled')) {\n          dir = day.getAttribute('data-direction');\n          if (dir === 'next') this.next();else if (dir === 'previous') this.previous();\n        }\n        // Enabled day sets the value\n        else {\n            this.setValue(day.getAttribute('data-date'), this.activeIndex);\n            if (this.autoAdvance) this._focusNext();\n            if (this.autoClose) this._closeOnLast();\n          }\n      }\n  };\n\n  /**\n   * When the popover opens, set the toggle state.\n   */\n\n\n  CalendarPopover.prototype._onPopoverOpen = function _onPopoverOpen() {\n    this._fillToggle();\n    this._checkSize();\n    if (this._currentBreakpoint === 'xs') this._scrollToInput();\n  };\n\n  /**\n   * When the popover closes, reset the active state.\n   */\n\n\n  CalendarPopover.prototype._onPopoverClose = function _onPopoverClose() {\n    this._unfillToggle();\n    this._updateHoverClasses();\n    this._deactivateElement(this.activeIndex);\n    this.activeIndex = null;\n  };\n\n  /**\n   * When the input that corresponds to this instance changes. Allows us to listen\n   * and respond to changes made by other components (Calendar Popover, for example).\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onInputChange = function _onInputChange(e) {\n\n    var index = this.inputEls.indexOf(e.target);\n\n    if (this._inputsChanging && this._inputsChanging.indexOf(index) !== -1) return;\n\n    this.setValue(e.target.value, index);\n  };\n\n  /**\n   * When an input receives focus, if we are supposed to automatically show\n   * on focus do so.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onInputFocus = function _onInputFocus(e) {\n    if (!this.showOnFocus) return;\n    var index = this.inputEls.indexOf(e.target);\n    if (index !== -1) this.open(index);\n  };\n\n  /**\n   * When one of the calendar quick jump select inputs changes.\n   * We have to set the value of the select input back to its original\n   * value or else it will be out of sync when the currently active\n   * month is shown again.\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onSelectChange = function _onSelectChange(e) {\n\n    var name = e.target.name;\n    var val = e.target.value;\n    var curVal = this._datesToShow[this.activeIndex][name];\n    var obj = {};\n\n    obj[name] = val;\n    this.showDate(obj);\n    e.target.value = curVal;\n  };\n\n  /**\n   * When the window resizes, determine if we're at the XS breakpoint so we\n   * can do some mobile-esque stuff!\n   * @param {Object} e\n   */\n\n\n  CalendarPopover.prototype._onResize = function _onResize() {\n    if (this.activeIndex !== null) this._checkSize();\n  };\n\n  return CalendarPopover;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nCalendarPopover.prototype._whitelistedParams = ['els', 'visibleCounts', 'autoAdvance', 'autoClose', 'closeDelay', 'mins', 'maxes', 'values', 'daysDisabled', 'daysInfo', 'quickJump', 'calendarEl', 'viewRange', 'animate', 'animationDuration', 'showOnFocus', 'onChange'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nCalendarPopover.prototype.defaults = {\n  els: null,\n  inputEls: null,\n  calendarEl: null,\n  calendarContentEl: null,\n  calendarOverflowEl: null,\n  visibleCounts: null,\n  activeIndex: null,\n  mins: null,\n  minVisible: null,\n  maxes: null,\n  maxVisible: null,\n  values: null,\n  daysDisabled: null,\n  daysInfo: null,\n  viewRange: null,\n  autoAdvance: null,\n  autoClose: null,\n  quickJump: null,\n  closeDelay: null,\n  nextButtonEl: null,\n  previousButtonEl: null,\n  animate: null,\n  animationDuration: null,\n  showOnFocus: null,\n  onChange: null,\n  _isDisabled: false,\n  _isRange: null,\n  _hoverStarts: null,\n  _hoverEnds: null,\n  _currentBreakpoint: null,\n  _animationQueue: null,\n  _currentContent: null,\n  _datesToShow: null,\n  _monthsShowing: null,\n  _atMin: false,\n  _atMax: false,\n  _inputsChanging: false,\n  _openCloseTimer: null,\n  _renderCache: null,\n  _onClickBound: null,\n  _onCalendarMouseOverBound: null,\n  _onCalendarMouseOutBound: null,\n  _onCalendarClickBound: null,\n  _onSelectChangeBound: null,\n  _onInputChangeBound: null,\n  _onInputFocusBound: null,\n  _onResizeBound: null\n};\n\nexports.default = CalendarPopover;\nmodule.exports = exports['default'];\n//# sourceMappingURL=calendar-popover.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _hasParent = require('../helpers/traversal/has-parent');\n\nvar _hasParent2 = _interopRequireDefault(_hasParent);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nvar _affix = require('../helpers/position/affix');\n\nvar _affix2 = _interopRequireDefault(_affix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Popover\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Show and hide a popover. Should do some sanity checks on positioning as well.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Popover(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Default anchoring of the content's x and y-axis relative to the button.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorX: 'center', // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorY: 'center' // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar Popover = function (_BaseComponent) {\n  _inherits(Popover, _BaseComponent);\n\n  function Popover(el) {\n    var _ret;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Popover);\n\n    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params));\n\n    if (!el) return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    return _this;\n  }\n\n  /**\n   * Open.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.open = function open() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // If there is a timer running for the close event, clear it so it\n    // doesn't close stuff during open.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // If the element we anchor the popover to is fixed, we need to know\n    // so that the affixed content can also be fixed.\n    this._checkFixedPosition();\n\n    // Update an existing affixed instance.\n    if (this.affix) {\n      this.affix.targetEl = params.affixTo || this.affix.targetEl;\n      this.affix.update();\n    }\n    // Affix the content to the toggle\n    else {\n        this.affix = new _affix2.default({\n          el: this.contentEl,\n          targetEl: params.affixTo || this.el,\n          caretEl: this.caretEl,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          isFixed: this.isFixed\n        });\n      }\n\n    // Listen for clicks on the window\n    this._addWindowEventListeners();\n\n    this.isActive = true;\n\n    // Dispatch a custom event so content inside the popover can respond\n    var e = document.createEvent('Event');\n    e.initEvent('spark.visible-children', true, true);\n    this.contentEl.dispatchEvent(e);\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Callbacks\n    (params.complete || noop)();\n    (this.onOpen || noop)();\n\n    return this;\n  };\n\n  /**\n   * Close.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.close = function close() {\n    var _this2 = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // Not open, so don't close.\n    if (!this.affix) return this;\n\n    // If there is a timer running for the close event, clear it so we don't run close stuff twice.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // Stop listening to window clicks.\n    this._removeWindowEventListeners();\n\n    this.isActive = false;\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Close after the animation has completed\n    this.closeTimer = setTimeout(function () {\n      _this2._finishClose(params);\n    }, 250);\n\n    return this;\n  };\n\n  /**\n   * Toggle the open state.\n   */\n\n\n  Popover.prototype.toggle = function toggle() {\n    return this[this.isActive ? 'close' : 'open']();\n  };\n\n  /**\n   * Set the content. Optionally append instead of replacing.\n   * @param {Element|Array|NodeList} content\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.setContent = function setContent(content, params) {\n    params = params || {};\n    (0, _appendChildren2.default)(this.contentEl, content.length ? content : [content], !(params.append || false));\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Popover.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._addEventListeners();\n\n    if (this.affix) this.affix.update();\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Popover.prototype._cacheElements = function _cacheElements(el) {\n\n    // If a content element was already passed, make sure it has a popover content class\n    if (this.contentEl) {\n      (0, _addClass2.default)(this.contentEl, 'spark-popover__content');\n    }\n\n    this.el = el;\n    this.toggleEl = this.el.querySelector('.spark-popover__toggle, [data-role=\"toggle\"]') || this.el;\n    this.contentEl = this.contentEl || this.el.querySelector('.spark-popover__content, [class*=\"spark-popover__content--\"]') || this._createContentEl();\n    this.caretEl = this.contentEl.querySelector('.spark-popover__caret') || this._createCaretEl();\n    this.isActive = (0, _hasClass2.default)(this.toggleEl, 'popover-active');\n  };\n\n  /**\n   * Parse config values from the element.\n   */\n\n\n  Popover.prototype._parseParams = function _parseParams() {\n\n    this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-y', null);\n    this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-x', null);\n\n    // No anchors defined\n    if (!this.anchorY && !this.anchorX) {\n\n      // Left\n      if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--left')) {\n        this.anchorY = 'middle';\n        this.anchorX = 'left';\n      }\n      // Right\n      else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--right')) {\n          this.anchorY = 'middle';\n          this.anchorX = 'right';\n        }\n        // Top\n        else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--top')) {\n            this.anchorY = 'top';\n            this.anchorX = 'center';\n          }\n          // Bottom\n          else {\n              this.anchorY = 'bottom';\n              this.anchorX = 'center';\n            }\n    }\n  };\n\n  /**\n   * Check to see if the button triggering the popover is fixed.\n   * If so, then popover needs to be fixed as well.\n   */\n\n\n  Popover.prototype._checkFixedPosition = function _checkFixedPosition() {\n\n    var parent = this.el;\n\n    while (parent && parent !== document) {\n      var style = getComputedStyle(parent);\n      if (style.position === 'fixed') {\n        return this.isFixed = true;\n      }\n      parent = parent.parentNode;\n    }\n\n    return this.isFixed = false;\n  };\n\n  /**\n   * Update classes for the open or close state.\n   */\n\n\n  Popover.prototype._updateAttributes = function _updateAttributes() {\n    (0, _toggleClass2.default)(this.el, 'popover-active', this.isActive);\n    (0, _toggleClass2.default)(this.contentEl, 'active', this.isActive);\n    (0, _toggleClass2.default)(this.toggleEl, 'active', this.isActive);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Popover.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onClickBound = this._onClick.bind(this);\n    this._onContentClickBound = this._onContentClick.bind(this);\n    this._onWindowClickBound = this._onWindowClick.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Popover.prototype._addEventListeners = function _addEventListeners() {\n    this.el.addEventListener('click', this._onClickBound);\n    this.contentEl.addEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Popover.prototype._removeEventListeners = function _removeEventListeners() {\n    this.el.removeEventListener('click', this._onClickBound);\n    this.contentEl.removeEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Add event listeners to the window.\n   */\n\n\n  Popover.prototype._addWindowEventListeners = function _addWindowEventListeners() {\n    this._removeWindowEventListeners();\n    window.addEventListener('click', this._onWindowClickBound);\n  };\n\n  /**\n   * Remove window event listeners.\n   */\n\n\n  Popover.prototype._removeWindowEventListeners = function _removeWindowEventListeners() {\n    window.removeEventListener('click', this._onWindowClickBound);\n  };\n\n  /**\n   * Create a content element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createContentEl = function _createContentEl() {\n    var el = document.createElement('div');\n    (0, _addClass2.default)(el, 'spark-popover__content');\n    el.setAttribute('role', 'tooltip');\n    return el;\n  };\n\n  /**\n   * Create the caret element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createCaretEl = function _createCaretEl() {\n    var el = document.createElement('div');\n    el.className = 'spark-popover__caret';\n    this.contentEl.appendChild(el);\n    return el;\n  };\n\n  /**\n   * Complete the close event by moving the element back and destroying the affix.\n   * @param  {Object} params\n   */\n\n\n  Popover.prototype._finishClose = function _finishClose() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    this.closeTimer = null;\n\n    // Move the content back to the parent\n    this.el.appendChild(this.contentEl);\n\n    this.affix.remove({ keepEl: true });\n    this.affix = null;\n\n    (params.complete || noop)();\n    (this.onClose || noop)();\n  };\n\n  /**\n   * When we are clicked, toggle the popover-active state.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onClick = function _onClick(e) {\n\n    // If this is the toggle element, toggle.\n    if (e.target === this.toggleEl || (0, _hasParent2.default)(e.target, this.toggleEl)) {\n      e.preventDefault();\n      this.toggle();\n      return;\n    }\n  };\n\n  /**\n   * When the toggle is clicked, close if it's a link. If it's content, don't do anything but stop\n   * the event from bubbling.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onContentClick = function _onContentClick(e) {\n\n    // If this is a link, close.\n    if ((0, _getParent2.default)(e.target, '.spark-popover__list-link', this.contentEl) || (0, _getParent2.default)(e.target, '.spark-popover__close', this.contentEl)) {\n      this.close();\n      return;\n    }\n  };\n\n  /**\n   * When the window is clicked and it's not part of the popover, close the popover.\n   * @param {Objec} e\n   */\n\n\n  Popover.prototype._onWindowClick = function _onWindowClick(e) {\n\n    if (e.target !== this.el && !(0, _hasParent2.default)(e.target, this.el) && !(0, _hasParent2.default)(e.target, this.contentEl)) {\n      this.close();\n    }\n  };\n\n  return Popover;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nPopover.prototype._whitelistedParams = ['anchorX', 'anchorY', 'toggleEl', 'contentEl', 'onOpen', 'onClose'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nPopover.prototype.defaults = {\n  el: null,\n  toggleEl: null,\n  contentEl: null,\n  caretEl: null,\n  affix: null,\n  isActive: false,\n  isPaused: false,\n  isFixed: false,\n  anchorX: null,\n  anchorY: null,\n  closeTimer: null,\n  onOpen: null,\n  onClose: null,\n  _onClickBound: null,\n  _onContentClickBound: null,\n  _onWindowClickBound: null,\n  _onWindowResizeBound: null,\n  _onWindowScrollBound: null\n};\n\nexports.default = Popover;\nmodule.exports = exports['default'];\n//# sourceMappingURL=popover.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Request Animation\n * Request animation frame polyfill.\n * @module helpers/animation/request.js\n */\nvar request = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function () {\n\n  var fps = 60;\n  var del = 1000 / fps;\n  var start = Date.now();\n  var prev = start;\n\n  return function requestAnimationFrame(callback) {\n\n    var requestTime = Date.now();\n    var timeout = Math.max(0, del - (requestTime - prev));\n    var timeToCall = requestTime + timeout;\n\n    prev = timeToCall;\n\n    return window.setTimeout(function onAnimationFrame() {\n      callback(timeToCall - start);\n    }, timeout);\n  };\n}();\n\nexports.default = request;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=request.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset = require('../dom/offset');\n\nvar _offset2 = _interopRequireDefault(_offset);\n\nvar _tween = require('./tween');\n\nvar _tween2 = _interopRequireDefault(_tween);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Scroll To\n * Scroll the window to a specific element or position.\n * @param {Object} params\n *\n * @module helpers/animation/scroll-to.js\n */\n\nfunction scrollTo(params) {\n\n  params = params || {};\n\n  var offset = void 0;\n  var x = void 0;\n  var y = void 0;\n  var target = params.target || window;\n  var startX = target !== window ? target.scrollLeft : target.pageXOffset;\n  var startY = target !== window ? target.scrollTop : target.pageYOffset;\n\n  if (params instanceof HTMLElement) {\n    offset = (0, _offset2.default)(params);\n    x = offset.left;\n    y = offset.top;\n    params = arguments[1] || {};\n  } else {\n    x = params.x || 0;\n    y = params.y || 0;\n  }\n\n  (0, _tween2.default)({\n    target: target,\n    prop: 'scrollTo',\n    start: [startX, startY],\n    end: [x, y],\n    duration: params.duration,\n    callback: params.callback\n  });\n}\n\nexports.default = scrollTo;\nmodule.exports = exports['default'];\n//# sourceMappingURL=scroll-to.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _request = require('./request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {};\n\n/**\n * Tween from one value to another.\n * @param {Object} params\n * @return {Long}\n */\n/**\n * # Tween\n * Tween between two values.\n * @module helpers/animation/tween.js\n */\n\nfunction tween(params) {\n\n  params = params || {};\n\n  var begin;\n  var obj = params.target;\n\n  if (!obj) {\n    throw new Error('Cannot tween without a target!');\n  }\n\n  var prop = typeof params.prop === 'string' ? [params.prop] : params.prop;\n  var start = typeof params.start === 'number' ? [params.start] : params.start;\n  var end = typeof params.end === 'number' ? [params.end] : params.end;\n  var duration = params.duration || 250;\n  var callback = params.callback || noop;\n\n  // Ensure we have the same number of start and end properties.\n  if (start.length !== end.length) {\n    throw new Error('Cannot tween two different sets of parameters!');\n  }\n\n  var f = function f(ts) {\n\n    // Keep track of when we start\n    if (!begin) begin = ts;\n\n    // Progress\n    var prog = ts - begin;\n\n    // Percentage complete\n    var per = Math.min(prog / duration, 1);\n\n    // Adjust the values for the percentage complete.\n    var args = [];\n    var i = 0;\n    var len = start.length;\n    for (; i < len; i++) {\n      args[i] = start[i] + (end[i] - start[i]) * per;\n    }\n\n    // Apply the values for each property.\n    i = 0;\n    len = prop.length;\n    var arg;\n    for (; i < len; i++) {\n\n      // If this is the last property but we have more arguments, set them all.\n      arg = i + 1 === len && args.length - 1 > i ? args.slice(i) : args[i];\n\n      if (typeof obj[prop[i]] === 'function') {\n        obj[prop[i]].apply(obj, arg);\n      } else {\n        obj[prop[i]] = arg;\n      }\n    }\n\n    // Keep going if we have more to do.\n    if (prog < duration) (0, _request2.default)(f);else callback();\n  };\n\n  return (0, _request2.default)(f);\n}\n\nexports.default = tween;\nmodule.exports = exports['default'];\n//# sourceMappingURL=tween.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Date helper\n * General helpers for working with dates.\n *\n * @module helpers/date/date.js\n */\n\nvar monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nvar monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];\nvar dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nvar dayNamesShort = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'];\nvar adjustedDayNames = [];\nvar adjustedDayNamesShort = [];\nvar weekStartsOn = 0;\n\nvar dateHelper = {\n\n  /**\n   * Transform a date into an object of date values.\n   * @param {Date} date\n   * @return {Object}\n   */\n  create: function create(date) {\n\n    date = date instanceof Date ? date : new Date(date.year, date.month - 1, date.day);\n\n    var inst = Object.create(dateHelper);\n    inst._date = date;\n    inst._cache = {};\n\n    return inst;\n  },\n\n  /**\n   * Get a year.\n   * @return {Number}\n   */\n  get year() {\n    this._instanceCheck('year');\n    return this._date.getFullYear();\n  },\n\n  /**\n   * Set a year.\n   * @param {Number} y\n   */\n  set year(y) {\n    this._instanceCheck('year');\n    this._clearCache();\n    return this._date.setFullYear(y);\n  },\n\n  /**\n   * Get a month.\n   * @return {Number} 1-12\n   */\n  get month() {\n    this._instanceCheck('month');\n    return this._date.getMonth() + 1;\n  },\n\n  /**\n   * Set a month.\n   * @param {Number} m 1-12\n   */\n  set month(m) {\n    this._instanceCheck('month');\n    this._clearCache();\n    return this._date.setMonth(m - 1);\n  },\n\n  /**\n   * Get a day.\n   * @return {Number} 1-31\n   */\n  get day() {\n    this._instanceCheck('day');\n    return this._date.getDate();\n  },\n\n  /**\n   * Set a day.\n   * @param {Number} d 1-31\n   */\n  set day(d) {\n    this._instanceCheck('day');\n    this._clearCache();\n    return this._date.setDate(d);\n  },\n\n  /**\n   * Sets the day, month and year values at once.\n   * @param {Object} params\n   */\n  set: function set(params) {\n    params = params || {};\n    this.year = params.year || this.year;\n    this.month = params.month || this.month;\n    this.day = params.day || this.day;\n  },\n\n  /**\n   * Get the full name of the month.\n   * @param {Number} num\n   * @return {String}\n   */\n  getMonthName: function getMonthName(num) {\n    return monthNames[num - 1];\n  },\n\n  /**\n   * Get the month name.\n   * @return {String}\n   */\n  get monthName() {\n    this._instanceCheck('monthName');\n    return dateHelper.getMonthName(this.month);\n  },\n\n  /**\n   * Get the list of month names.\n   * @return {Array}\n   */\n  getMonthNames: function getMonthNames() {\n    return monthNames;\n  },\n\n  /**\n   * Get the short name of the month.\n   * @param {Number} num\n   * @return {String}\n   */\n  getMonthNameShort: function getMonthNameShort(num) {\n    return monthNamesShort[num - 1];\n  },\n\n  /**\n   * Get the month name.\n   * @return {String}\n   */\n  get monthNameShort() {\n    this._instanceCheck('monthName');\n    return dateHelper.getMonthNameShort(this.month);\n  },\n\n  /**\n   * Get the list of short month names.\n   * @return {Array}\n   */\n  getMonthNamesShort: function getMonthNamesShort() {\n    return monthNamesShort;\n  },\n\n  /**\n   * Set the month names.\n   * @param {Array} names\n   */\n  setMonthNames: function setMonthNames(names) {\n    if (names.length === 12) monthNames = names;\n  },\n\n  /**\n   * Set the short month names.\n   * @param {Array} names\n   */\n  setMonthNamesShort: function setMonthNamesShort(names) {\n    if (names.length === 12) monthNamesShort = names;\n  },\n\n  /**\n   * Get the day of the week for a given day.\n   * @param {Object} date\n   * @return {Number} 1-7\n   */\n  getDayOfWeek: function getDayOfWeek(date) {\n    var day = (date instanceof Date ? date : new Date(date.year, date.month - 1, date.day)).getDay() - weekStartsOn;\n    return (day < 0 ? 7 - Math.abs(day) : day) + 1;\n  },\n\n  /**\n   * Get the day of the week.\n   * @return {Number}\n   */\n  get dayOfWeek() {\n    return dateHelper.getDayOfWeek(this._date);\n  },\n\n  /**\n   * Get the full name of a day of the week.\n   * @param {Number} num\n   * @return {String}\n   */\n  getDayName: function getDayName(num) {\n    return dayNames[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];\n  },\n\n  /**\n   * Get the day name.\n   * @return {String}\n   */\n  get dayName() {\n    this._instanceCheck('dayName');\n    return dateHelper.getDayName(this.dayOfWeek);\n  },\n\n  /**\n   * Get the full name of the days of the week.\n   * @return {Array}\n   */\n  getDayNames: function getDayNames() {\n    return adjustedDayNames.length ? adjustedDayNames : dayNames;\n  },\n\n  /**\n   * Get the short name of the day.\n   * @param {Number} num\n   * @return {String}\n   */\n  getDayNameShort: function getDayNameShort(num) {\n    return dayNamesShort[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];\n  },\n\n  /**\n   * Get the short day name.\n   * @return {String}\n   */\n  get dayNameShort() {\n    this._instanceCheck('dayNameShort');\n    return dateHelper.getDayNameShort(this.dayOfWeek);\n  },\n\n  /**\n   * Get the full name of the days of the week.\n   * @return {Array}\n   */\n  getDayNamesShort: function getDayNamesShort() {\n    return adjustedDayNamesShort.length ? adjustedDayNamesShort : dayNamesShort;\n  },\n\n  /**\n   * Set the day names.\n   * @param {Array} names\n   */\n  setDayNames: function setDayNames(names) {\n    if (names.length === 7) dayNames = names;\n  },\n\n  /**\n   * Set the short day names.\n   * @param {Array} names\n   */\n  setDayNamesShort: function setDayNamesShort(names) {\n    if (names.length === 7) dayNamesShort = names;\n  },\n\n  /**\n   * Get the index of the first day of the week.\n   * @return {Number}\n   */\n  getWeekStartsOn: function getWeekStartsOn() {\n    return weekStartsOn;\n  },\n\n  /**\n   * Set the index of the first day of the week.\n   * @param {Number} index\n   * @return {String}\n   */\n  setWeekStartsOn: function setWeekStartsOn(number) {\n\n    weekStartsOn = number;\n\n    if (number) {\n      adjustedDayNames = dayNames.slice(weekStartsOn);\n      adjustedDayNames = adjustedDayNames.concat(dayNames.slice(0, weekStartsOn));\n      adjustedDayNamesShort = dayNamesShort.slice(weekStartsOn);\n      adjustedDayNamesShort = adjustedDayNamesShort.concat(dayNamesShort.slice(0, weekStartsOn));\n    } else {\n      adjustedDayNames = [];\n      adjustedDayNamesShort = [];\n    }\n  },\n\n  /**\n   * Get the current date.\n   * @return {Object}\n   */\n  now: function now() {\n    return dateHelper.create(new Date());\n  },\n\n  /**\n   * Get the next year after the given date.\n   * This obviously isn't very complicated, but it exists\n   * for parity with how we get the week, day and month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextYear: function getNextYear(date) {\n    return dateHelper.create(new Date(date.year + 1, date.month - 1, date.day));\n  },\n\n  /**\n   * Get the year following this.\n   * @return {Object}\n   */\n  get nextYear() {\n    this._instanceCheck('nextYear');\n    return this._cache.nextYear || (this._cache.nextYear = dateHelper.getNextYear(this));\n  },\n\n  /**\n   * Get the first day of the week for a given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getWeekStart: function getWeekStart(date) {\n    var inst = dateHelper.create(new Date(date.year, date.month - 1, date.day - dateHelper.getDayOfWeek(date) + 1));\n    inst.weekStartsOn = weekStartsOn;\n    return inst;\n  },\n\n  /**\n   * Get the start of the week for this date.\n   * @return {Object}\n   */\n  get weekStart() {\n    this._instanceCheck('weekStart');\n    return this._cache.weekStart && this._cache.weekStart.weekStartsOn === weekStartsOn ? this._cache.weekStart : this._cache.weekStart = dateHelper.getWeekStart(this);\n  },\n\n  /**\n   * Get the first day of the month for a given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getMonthStart: function getMonthStart(date) {\n    var inst = dateHelper.create(new Date(date.year, date.month - 1, 1));\n    return inst;\n  },\n\n  /**\n   * Get the start of the month for this date.\n   * @return {Object}\n   */\n  get monthStart() {\n    this._instanceCheck('monthStart');\n    return this._cache.monthStart || (this._cache.monthStart = dateHelper.getMonthStart(this));\n  },\n\n  /**\n   * Get the next week after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextWeek: function getNextWeek(date) {\n    var start = dateHelper.getWeekStart(date);\n    return dateHelper.create(new Date(start.year, start.month - 1, start.day + 7));\n  },\n\n  /**\n   * Get the week following this.\n   * @return {Object}\n   */\n  get nextWeek() {\n    this._instanceCheck('nextWeek');\n    return this._cache.nextWeek || (this._cache.nextWeek = dateHelper.getNextWeek(this));\n  },\n\n  /**\n   * Get the next day after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextDay: function getNextDay(date) {\n    return dateHelper.create(new Date(date.year, date.month - 1, date.day + 1));\n  },\n\n  /**\n   * Get the day following this.\n   * @return {Object}\n   */\n  get nextDay() {\n    this._instanceCheck('nextDay');\n    return this._cache.nextDay || (this._cache.nextDay = dateHelper.getNextDay(this));\n  },\n\n  /**\n   * Get the next month after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getNextMonth: function getNextMonth(date) {\n    // Date() has a *bug/feature* if last day of month is 31 when calculating the next month.\n    // Need to account for that so that it doesn't round up the date/month.\n\n    if (date.day === 31 && date.month !== 1 && date.month !== 7 && date.month !== 12) {\n      // Adjust for months ending in 31 followed by months ending in 30\n      return dateHelper.create(new Date(date.year, date.month, date.day - 1));\n    } else if (date.day > 28 && date.month === 1) {\n      // fix for last day of February\n      return dateHelper.create(new Date(date.year, date.month + 1, 0));\n    } else {\n      return dateHelper.create(new Date(date.year, date.month, date.day));\n    }\n  },\n\n  /**\n   * Get the month following this.\n   * @return {Object}\n   */\n  get nextMonth() {\n    this._instanceCheck('nextMonth');\n    return this._cache.nextMonth || (this._cache.nextMonth = dateHelper.getNextMonth(this));\n  },\n\n  /**\n   * Get the previous year after the given date.\n   * This obviously isn't very complicated, but it exists\n   * for parity with how we get the week, day and month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousYear: function getPreviousYear(date) {\n    return dateHelper.create(new Date(date.year - 1, date.month - 1, date.day));\n  },\n\n  /**\n   * Get the year preceding this.\n   * @return {Object}\n   */\n  get previousYear() {\n    this._instanceCheck('previousYear');\n    return this._cache.previousYear || (this._cache.previousYear = dateHelper.getPreviousYear(this));\n  },\n\n  /**\n   * Get the previous week after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousWeek: function getPreviousWeek(date) {\n    var start = dateHelper.getWeekStart(date);\n    var inst = dateHelper.create(new Date(start.year, start.month - 1, start.day - 7));\n    inst.weekStartsOn = weekStartsOn;\n    return inst;\n  },\n\n  /**\n   * Get the week preceding this.\n   * @return {Object}\n   */\n  get previousWeek() {\n    this._instanceCheck('previousWeek');\n    return this._cache.previousWeek || (this._cache.previousWeek = dateHelper.getPreviousWeek(this));\n  },\n\n  /**\n   * Get the previous day after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousDay: function getPreviousDay(date) {\n    return dateHelper.create(new Date(date.year, date.month - 1, date.day - 1));\n  },\n\n  /**\n   * Get the day preceding this.\n   * @return {Object}\n   */\n  get previousDay() {\n    this._instanceCheck('previousDay');\n    return this._cache.previousDay || (this._cache.previousDay = dateHelper.getPreviousDay(this));\n  },\n\n  /**\n   * Get the previous month after the given date.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getPreviousMonth: function getPreviousMonth(date) {\n    // Date() has a *bug/feature* if last day of month is 31 when calculating the previous month.\n    // Need to account for that so that it doesn't round up the date/month.\n\n    if (date.day === 31 && date.month !== 1 && date.month !== 3 && date.month !== 8) {\n      // Adjust for months ending in 31 that follow months ending in 30\n      return dateHelper.create(new Date(date.year, date.month - 2, date.day - 1));\n    } else if (date.day > 28 && date.month === 3) {\n      // Adjust for last day of February\n      return dateHelper.create(new Date(date.year, date.month - 1, 0));\n    } else {\n      return dateHelper.create(new Date(date.year, date.month - 2, date.day));\n    }\n  },\n\n  /**\n   * Get the month preceding this.\n   * @return {Object}\n   */\n  get previousMonth() {\n    this._instanceCheck('previousMonth');\n    return this._cache.previousMonth || (this._cache.previousMonth = dateHelper.getPreviousMonth(this));\n  },\n\n  /**\n   * Get the last day of the month.\n   * @param {Object} date\n   * @return {Object}\n   */\n  getMonthEnd: function getMonthEnd(date) {\n    return dateHelper.create(new Date(date.year, date.month, 0));\n  },\n\n  /**\n   * Get the last day of the month.\n   * @return {Object}\n   */\n  get monthEnd() {\n    this._instanceCheck('monthEnd');\n    return this._cache.monthEnd || (this._cache.monthEnd = dateHelper.getMonthEnd(this));\n  },\n\n  /**\n   * Does a given day equal another? Or is it present in a list of others?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equal: function equal(date, compare, full) {\n    return this.equalDay(date, compare, full);\n  },\n\n  /**\n   * Does a given day equal another? Or is it present in a list of others?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalDay: function equalDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (compare[i] && date.year === compare[i].year && date.month === compare[i].month && date.day === compare[i].day) matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalWeek: function equalWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.equalDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalMonth: function equalMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year !== compare[i].year || date.year === compare[i].year && date.month !== compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year equal to another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  equalYear: function equalYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year !== compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a date before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  before: function before(date, compare, full) {\n    return this.beforeDay(date, compare, full);\n  },\n\n  /**\n   * Is a given date before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeDay: function beforeDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date._date >= compare[i]._date) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeWeek: function beforeWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.beforeDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeMonth: function beforeMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year > compare[i].year || date.year === compare[i].year && date.month >= compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year before another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  beforeYear: function beforeYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year >= compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a date after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  after: function after(date, compare, full) {\n    return this.afterDay(date, compare, full);\n  },\n\n  /**\n   * Is a given date after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterDay: function afterDay(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date._date <= compare[i]._date) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a week after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterWeek: function afterWeek(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || !date.weekStart.afterDay(compare[i].weekStart)) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a month after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterMonth: function afterMonth(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year < compare[i].year || date.year === compare[i].year && date.month <= compare[i].month) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Is a year after another?\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full Return a successful match only if all matches are found.\n   * @return {Boolean}\n   */\n  afterYear: function afterYear(date, compare, full) {\n\n    var args = this._checkComparisonArgs(date, compare, full);\n    date = args[0];\n    compare = args[1];\n    full = args[2];\n\n    var i = 0;\n    var len = compare.length;\n    var matches = 0;\n\n    for (; i < len; i++) {\n      if (!compare[i] || date.year <= compare[i].year) continue;else matches++;\n    }\n\n    return full ? matches === len : !!matches;\n  },\n\n  /**\n   * Get the earliest date in an array.\n   * @return {Object}\n   */\n  earliest: function earliest(arr) {\n\n    var i = 0;\n    var len = arr.length;\n    var e = void 0;\n\n    for (; i < len; i++) {\n      if (!e || arr[i].before(e)) e = arr[i];\n    }\n\n    return e;\n  },\n\n  /**\n   * Get the latest date in an array.\n   * @return {Object}\n   */\n  latest: function latest(arr) {\n\n    var i = 0;\n    var len = arr.length;\n    var l = void 0;\n\n    for (; i < len; i++) {\n      if (!l || arr[i].after(l)) l = arr[i];\n    }\n\n    return l;\n  },\n\n  /**\n   * Clone a date instance.\n   * @param {Object} date\n   * @return {Object}\n   */\n  clone: function clone(date) {\n\n    // If we weren't passed a date, use this instance.\n    if (!date && this._date && this._date instanceof Date && dateHelper.isPrototypeOf(this)) {\n      date = this;\n    }\n\n    // No date, can't clone.\n    if (!date) {\n      throw new Error('Must pass a date to clone or call on an instance.');\n    }\n\n    return dateHelper.create(new Date(date._date.valueOf()));\n  },\n\n  /**\n   * If a comparison function is called on an instance, properly\n   * assign the vars.\n   * @param {Object} date\n   * @param {Object|Array} compare\n   * @param {Boolean} full\n   */\n  _checkComparisonArgs: function _checkComparisonArgs(date, compare, full) {\n\n    if (compare === undefined || typeof compare === 'boolean') {\n\n      if (!dateHelper.isPrototypeOf(this)) {\n        throw new Error('Cannot compare only one date!');\n      }\n\n      full = compare;\n      compare = date;\n      date = this;\n    }\n\n    compare = compare instanceof Array ? compare : [compare];\n\n    return [date, compare, full];\n  },\n\n  /**\n   * Check to see if we have an instance of the date object.\n   * @param  {String} prop\n   */\n  _instanceCheck: function _instanceCheck(prop) {\n    if (!this._date || !(this._date instanceof Date) || !dateHelper.isPrototypeOf(this)) throw new Error('Cannot access the property \"' + prop + '\" of the date helper with creating an instance!');\n  },\n\n  /**\n   * Clear the cache.\n   */\n  _clearCache: function _clearCache() {\n    this._instanceCheck('clearCache');\n    this._cache = {};\n  }\n};\n\nexports.default = dateHelper;\nmodule.exports = exports['default'];\n//# sourceMappingURL=date.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _pad = require('../util/pad');\n\nvar _pad2 = _interopRequireDefault(_pad);\n\nvar _date = require('./date');\n\nvar _date2 = _interopRequireDefault(_date);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Map characters to their special meanings.\n * @type {Object}\n */\n/**\n * # Parse Date Format\n * Given a date format string, break it down into pieces.\n *\n * @example\n * parseDateFormat('MM-DD-YYYY');\n *\n * @module helpers/date/parse-format.js\n */\n\nvar map = {\n  d: 'day',\n  m: 'month',\n  y: 'year',\n  '-': 'divider',\n  '/': 'divider',\n  ' ': 'space'\n};\n\n/**\n * Given a format and a string, get the day, month and year values from that string.\n * @param {Object} format\n * @return {Function}\n */\nfunction getValues(format) {\n\n  return function (value) {\n\n    var i = 0;\n    var index = 0;\n    var len = format.length;\n    var values = {};\n\n    // Loop through all format pieces\n    for (; i < len; i++) {\n\n      // Only worry about date values\n      if (['day', 'month', 'year'].indexOf(format[i].name) !== -1) {\n\n        // If the passed value doesn't contain a format piece, it's invalid.\n        if (value.length < index + format[i].length) return;\n\n        values[format[i].name] = parseInt(value.substr(index, format[i].length), 10);\n      }\n      index += format[i].length;\n    }\n\n    return _date2.default.create(values);\n  };\n}\n\n/**\n * Create a formatted date string given an object of values.\n * @param {Object} format\n * @return {Function}\n */\nfunction getString(format) {\n\n  /**\n   * @param {Object} vals\n   * @return {String}\n   */\n  return function (vals) {\n\n    var i = 0;\n    var len = format.length;\n    var str = '';\n\n    for (; i < len; i++) {\n\n      // Numbers\n      if (vals[format[i].name]) {\n        str += (0, _pad2.default)(vals[format[i].name], format[i].length);\n      }\n      // Dividers\n      else {\n          str += format[i].value;\n        }\n    }\n\n    return str;\n  };\n}\n\n/**\n * @param {String} format\n * @return {Object}\n */\nfunction parseDateFormat(format) {\n\n  var f = format.toLowerCase();\n  var i = 0;\n  var len = f.length;\n\n  var obj = {\n    parts: []\n  };\n\n  for (; i < len; i++) {\n\n    // If there is a matching character mapping and the last part was of the same name, increment its length\n    // and add to its content.\n    if (map[f[i]] && obj.parts.length && obj.parts[obj.parts.length - 1].name === map[f[i]]) {\n      obj.parts[obj.parts.length - 1].length++;\n      obj.parts[obj.parts.length - 1].value += format[i];\n      continue;\n    }\n\n    obj.parts.push({\n      name: map[f[i]] ? map[f[i]] : '',\n      value: format[i],\n      length: 1\n    });\n  }\n\n  // Add a way to convert the parsed date into a regex-ish string that works with the Typeahead implementation.\n  obj.getValues = getValues(obj.parts);\n  obj.getString = getString(obj.parts);\n\n  return obj;\n}\n\nexports.default = parseDateFormat;\nmodule.exports = exports['default'];\n//# sourceMappingURL=parse-format.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Breakpoint Helpers\n * Find the active breakpoint.\n *\n * @param {Number} width\n *\n * @module helpers/dom/breakpoint.js\n */\n\n/**\n * Breakpoints being used in the CSS.\n * @type {Object}\n */\nvar defaultBreakpoints = {\n  xs: {\n    min: 0,\n    max: 543\n  },\n  sm: {\n    min: 544,\n    max: 795\n  },\n  md: {\n    min: 796,\n    max: 1047\n  },\n  lg: {\n    min: 1048,\n    max: 1799\n  },\n  xl: {\n    min: 1800,\n    max: Infinity\n  }\n};\n\nfunction get(width, breakpoints) {\n\n  breakpoints = breakpoints || defaultBreakpoints;\n\n  var i = void 0;\n\n  for (i in breakpoints) {\n    if (width >= breakpoints[i].min && width <= breakpoints[i].max) {\n      return i;\n    }\n  }\n}\n\nexports.get = get;\n//# sourceMappingURL=breakpoint.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Offset Position\n * Get the offset position of the element.\n *\n * @param {Element} el\n * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.\n * @return {Object}\n *\n * @module helpers/dom/offset.js\n */\nfunction offset(el, viewPortOffset) {\n\n  var rect = {\n    top: 0,\n    left: 0\n  };\n\n  // Native implementation\n  if (el.getBoundingClientRect) {\n\n    var bounding = el.getBoundingClientRect();\n    rect.left = bounding.left;\n    rect.top = bounding.top;\n\n    if (!viewPortOffset) {\n      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;\n      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;\n    }\n  } else {\n    var x = 0,\n        y = 0;\n    do {\n      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);\n      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);\n    } while (el = el.offsetParent);\n\n    rect.left = x;\n    rect.top = y;\n  }\n\n  return rect;\n}\n\nexports.default = offset;\nmodule.exports = exports['default'];\n//# sourceMappingURL=offset.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trigger Event\n * Trigger a DOM event on an element.\n *\n * @param {Element} el\n * @param {String} name\n *\n * @module helpers/dom/trigger-event.js\n */\nfunction triggerEvent(el, name) {\n\n  var event = void 0;\n\n  if (document.createEvent) {\n    event = document.createEvent('HTMLEvents');\n    event.initEvent(name, true, true);\n    event.eventName = name;\n    el.dispatchEvent(event);\n  } else {\n    event = document.createEventObject();\n    event.eventType = name;\n    event.eventName = name;\n    el.fireEvent('on' + event.eventType, event);\n  }\n}\n\nexports.default = triggerEvent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trigger-event.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Build Select\n * Build a select input.\n *\n * @param {Object} params\n *\n * @example\n * buildSelect({\n *   attributes: {\n *     name: 'test',\n *     class: 'spark-select__field'\n *   },\n *   options: [1, 2, 3, 4, 5, 6]\n * });\n *\n * @example\n * buildSelect({\n *   attributes: {\n *     name: 'test',\n *     class: 'spark-select__field',\n *     'data-attr': 'thing',\n *      multiple: true\n *   },\n *   selected: [2, 4],\n *   options: [\n *     {text: 'One', value: 1},\n *     {text: 'Two', value: 2},\n *     {text: 'Three', value: 3},\n *     {text: 'Four', value: 4},\n *     {text: 'Five', value: 5},\n *   ]\n * });\n *\n * @module helpers/form/build-select.js\n */\n\nfunction buildSelect(params) {\n\n  var el = document.createElement('select');\n  var html = '';\n  var attrs = params.attributes;\n  var selected = params.selected instanceof Array ? params.selected : params.selected ? [params.selected] : [];\n  var opts = params.options;\n\n  var i = void 0;\n  var len = opts.length;\n\n  // Set attributes\n  for (i in attrs) {\n    el.setAttribute(i, attrs[i]);\n  }\n\n  // Add options\n  for (i = 0; i < len; i++) {\n    if (_typeof(opts[i]) === 'object') {\n      html += '<option value=\"' + opts[i].value + '\" ' + (selected.indexOf(opts[i].value) !== -1 ? 'selected' : '') + '>' + opts[i].text + '</option>';\n    } else {\n      html += '<option value=\"' + opts[i] + '\" ' + (selected.indexOf(opts[i]) !== -1 ? 'selected' : '') + '>' + opts[i] + '</option>';\n    }\n  }\n\n  el.innerHTML = html;\n\n  return el;\n}\n\nexports.default = buildSelect;\nmodule.exports = exports['default'];\n//# sourceMappingURL=build-select.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction appendChildren(el, children, empty) {\n\n  empty = empty === undefined ? false : empty;\n\n  if (empty) {\n    el.textContent = '';\n  }\n\n  var domList = children instanceof window.HTMLCollection;\n\n  if (domList) {\n    while (children.length) {\n      el.appendChild(children[0]);\n    }\n  } else {\n    (0, _each2.default)(children, function (c) {\n      if (c) {\n        el.appendChild(c);\n      }\n    });\n  }\n} /**\n   * # Append Children\n   * Append an array of children to a node.\n   *\n   * @param {Element} el\n   * @param {Array} children\n   * @param {Boolean} empty Empty the node before adding children?\n   *\n   * @module helpers/manipulation/append-children.js\n   */\n\nexports.default = appendChildren;\nmodule.exports = exports['default'];\n//# sourceMappingURL=append-children.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset2 = require('../dom/offset');\n\nvar _offset3 = _interopRequireDefault(_offset2);\n\nvar _boxPosition = require('./box-position');\n\nvar _boxPosition2 = _interopRequireDefault(_boxPosition);\n\nvar _debounce = require('../util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Affix\n                                                                                                                                                           * Affix one element to another.\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Affix({\n                                                                                                                                                           *   el: el,\n                                                                                                                                                           *   targetEl: el2,\n                                                                                                                                                           *   caretEl: el3,\n                                                                                                                                                           *   anchorY: 'top', // 'middle', 'bottom'\n                                                                                                                                                           *   anchorX: 'left', // 'center', 'right'\n                                                                                                                                                           * })\n                                                                                                                                                           *\n                                                                                                                                                           * @module helpers/position/affix.js\n                                                                                                                                                           */\n\nvar Affix = function () {\n\n  /**\n   * Store the reference elements and position.\n   * @param  {Object} params\n   */\n  function Affix() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Affix);\n\n    this.el = params.el;\n    this.targetEl = params.targetEl;\n    this.caretEl = params.caretEl;\n    this.anchorY = params.anchorY || 'top';\n    this.anchorX = params.anchorX || 'center';\n    this.isFixed = params.isFixed || false;\n\n    this._addEventListeners();\n    this._insertEl();\n    this._setPosition();\n    this._updateDebounced = (0, _debounce2.default)(this.update.bind(this), 500);\n  }\n\n  /**\n   * Stop listening and clean up event listeners\n   * @param {Object} params Optional\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.remove = function remove() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!params.keepEl) this._removeEl();\n    this._removeEventListeners();\n    return this;\n  };\n\n  /**\n   * Update the position.\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.update = function update() {\n    this._setPosition();\n    return this;\n  };\n\n  /**\n   * Listen for window resizes to update the position.\n   */\n\n\n  Affix.prototype._addEventListeners = function _addEventListeners() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Remove event listeners\n   */\n\n\n  Affix.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Insert the element into the DOM.\n   */\n\n\n  Affix.prototype._insertEl = function _insertEl() {\n    this.el.setAttribute('data-affixed', '');\n    this._getRootEl().appendChild(this.el);\n  };\n\n  /**\n   * Remove the element from the DOM.\n   */\n\n\n  Affix.prototype._removeEl = function _removeEl() {\n    this.el.parentNode.removeChild(this.el);\n    this.el.removeAttribute('data-affixed');\n  };\n\n  /**\n   * Set the position of the target element.\n   */\n\n\n  Affix.prototype._setPosition = function _setPosition() {\n\n    // Fixed position\n    this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');\n\n    // Target element properties\n\n    var _offset = (0, _offset3.default)(this.targetEl, this.isFixed),\n        targetTop = _offset.top,\n        targetLeft = _offset.left;\n\n    var targetWidth = this.targetEl.offsetWidth;\n    var targetHeight = this.targetEl.offsetHeight;\n\n    // Element to affix properties\n    var elWidth = this.el.offsetWidth;\n    var elHeight = this.el.offsetHeight;\n\n    // Maxes\n    var docHeight = document.documentElement.offsetHeight;\n    var docWidth = document.documentElement.offsetWidth;\n\n    // Get the values\n\n    var _calculatePosition2 = this._calculatePosition({\n      anchorX: this.anchorX,\n      anchorY: this.anchorY,\n      targetTop: targetTop,\n      targetLeft: targetLeft,\n      elHeight: elHeight,\n      elWidth: elWidth,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      minX: 0,\n      minY: 0,\n      maxX: docWidth - elWidth,\n      maxY: Math.max(docHeight - elHeight, 0)\n    }),\n        elTop = _calculatePosition2.elTop,\n        elLeft = _calculatePosition2.elLeft;\n\n    // Position the caret\n\n\n    var _positionCaret2 = this._positionCaret({\n      elLeft: elLeft,\n      elTop: elTop,\n      elWidth: elWidth,\n      elHeight: elHeight,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      targetLeft: targetLeft,\n      targetTop: targetTop\n    }),\n        extraLeft = _positionCaret2.extraLeft,\n        extraTop = _positionCaret2.extraTop;\n\n    // Set the position\n\n\n    this.el.style.left = elLeft + extraLeft + 'px';\n    this.el.style.top = elTop + extraTop + 'px';\n  };\n\n  /**\n   * Get the proper top position for an anchor direction.\n   * @param  {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._calculatePosition = function _calculatePosition(p) {\n\n    // Keep track of what we're trying to do here, so on subsequent, nested calls to this\n    // method we can see what has already been tried.\n    p.previousAttempts = (p.previousAttempts || 0) + 1;\n    p.previousChecks = p.previousChecks || [];\n\n    var finalCheck = p.previousAttempts > 3;\n    var top = void 0;\n    var left = void 0;\n\n    // Y-axis check\n    switch (p.anchorY) {\n      case 'bottom':\n        top = p.targetTop + p.targetHeight;\n        break;\n      case 'middle':\n        top = p.targetTop - (p.elHeight - p.targetHeight) / 2;\n        break;\n      default:\n        top = p.targetTop - p.elHeight;\n        break;\n    }\n\n    // Under min\n    if (top < p.minY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {\n        p.previousChecks.push('underY');\n        p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      } else {\n        top = p.minY;\n      }\n    }\n\n    // Don't check for being too tall because causing a vertical scroll\n    // bar down is okay and this saves us from some real positioning hell.\n    /*if (top > p.maxY) {\n       if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {\n        p.previousChecks.push('overY');\n        p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      // On a final check, bottom wins because at least we can scroll\n      else if (!(finalCheck && p.anchorY === 'bottom')) {\n        top = p.maxY;\n      }\n    }*/\n\n    // X-axis check\n    switch (p.anchorX) {\n      case 'right':\n        left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);\n        break;\n      case 'center':\n        left = p.targetLeft - (p.elWidth - p.targetWidth) / 2;\n        break;\n      default:\n        left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);\n        break;\n    }\n\n    // Under min\n    if (left < p.minX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {\n        p.previousChecks.push('underX');\n        p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.minX;\n      }\n    }\n\n    // Over max\n    if (left > p.maxX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {\n        p.previousChecks.push('overX');\n        p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.maxX;\n      }\n    }\n\n    // One element is covering another. Try to fix that, but bail out after four tries.\n    if ((0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: left, top: top }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop }) === 'overlap') {\n\n      p.isOverlapping = true;\n\n      // Try Y\n      if (p.repositionY !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionY = !p.repositionY;\n\n        // First try to put above, then try to put below.\n        p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n      // Try X\n      else if (p.repositionX !== false) {\n\n          // Will start undefined, then true, then false. This limits us to entering\n          // this loop twice, once to try moving in each direction.\n          p.repositionX = !p.repositionX;\n\n          // First try to put above, then try to put below.\n          p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);\n\n          // Give us one more shot at positioning\n          p.previousAttempts--;\n\n          return this._calculatePosition(p);\n        }\n    }\n\n    return { elTop: top, elLeft: left, anchorX: p.anchorX, anchorY: p.anchorY };\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorY = function _getNewAnchorY(underMin, anchorY, anchorX) {\n\n    // If the x-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorX === 'center' || anchorY === 'middle') {\n      return underMin ? 'bottom' : 'top';\n    } else {\n      return 'middle';\n    }\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorX = function _getNewAnchorX(underMin, anchorX, anchorY) {\n\n    // If the y-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorY === 'middle' || anchorX === 'center') {\n      return underMin ? 'left' : 'right';\n    } else {\n      return 'center';\n    }\n  };\n\n  /**\n   * Set the position of the caret.\n   * @param {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._positionCaret = function _positionCaret() {\n    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    if (!this.caretEl) return;\n\n    var caretPosition = (0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: p.elLeft, top: p.elTop }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop });\n\n    var caretDimensions = this.caretEl.getBoundingClientRect();\n    var caretWidth = caretDimensions.width;\n    var caretHeight = caretDimensions.height;\n    var left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + p.targetWidth / 2));\n    var top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + p.targetHeight / 2));\n\n    this.caretEl.style.left = Math.round(left) + 'px';\n    this.caretEl.style.top = Math.round(top) + 'px';\n\n    var extraLeft = 0;\n    var extraTop = 0;\n\n    this.caretEl.setAttribute('data-position', caretPosition);\n\n    switch (caretPosition) {\n      case 'above':\n        extraTop = -caretWidth / 2;\n        break;\n      case 'below':\n        extraTop = caretWidth / 2;\n        break;\n      case 'left':\n        extraLeft = -caretHeight / 2;\n        break;\n      default:\n        extraLeft = caretHeight / 2;\n        break;\n    }\n\n    return {\n      extraLeft: extraLeft,\n      extraTop: extraTop\n    };\n  };\n\n  /**\n   * Get the root element. Want to check if there's a top-level form for working\n   * with ASP .NET pages.\n   */\n\n\n  Affix.prototype._getRootEl = function _getRootEl() {\n    var form = document.querySelector('body > form');\n    return form && form.getAttribute('data-affixed') === null ? form : document.body;\n  };\n\n  /**\n   * On resize, update the position.\n   */\n\n\n  Affix.prototype._onResize = function _onResize() {\n    this.update();\n  };\n\n  /**\n   * When the window scrolls, ensure the proper position of the popover.\n   */\n\n\n  Affix.prototype._onScroll = function _onScroll() {\n    this._updateDebounced();\n  };\n\n  return Affix;\n}();\n\nexports.default = Affix;\nmodule.exports = exports['default'];\n//# sourceMappingURL=affix.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (a, b) {\n\n  var aXSpan = a.left + a.width;\n  var aYSpan = a.top + a.height;\n  var bXSpan = b.left + b.width;\n  var bYSpan = b.top + b.height;\n\n  if (aXSpan <= b.left) return 'left'; // a is fully left of b\n  if (a.left >= bXSpan) return 'right'; // a is fully right of b\n  if (aYSpan <= b.top) return 'above'; // a is fully above b\n  if (a.top >= bYSpan) return 'below'; // a is fully below b\n\n  return 'overlap'; // boxes overlap\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Box Position\n                                      * How is one element positioned relative to another?\n                                      *\n                                      * @example\n                                      * boxPosition(\n                                      * {width: 100, height: 300, left: 0, top: 0},\n                                      * {width: 200, height: 50, left: 100, top: 40}\n                                      * )\n                                      *\n                                      * @module helpers/position/box-position.js\n                                      *\n                                      * @param {Object} a\n                                      * @param {Object} b\n                                      * @return {String}\n                                      */\n//# sourceMappingURL=box-position.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParent(parent, query, limitEl) {\n\n  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];\n\n  while (parent) {\n\n    if ((0, _matches2.default)(parent, query)) {\n      return parent;\n    }\n\n    if (limitEl.indexOf(parent) !== -1) {\n      return false;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n} /**\n   * # Get Parent\n   * See if an element has another element for a parent.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Array|Element} limitEl The last element we should check.\n   * @return {Boolean|Element}\n   *\n   * @module helpers/traversal/get-parent.js\n   */\n\nexports.default = getParent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getSiblingAfter(el, query) {\n\n  while (el = el.nextElementSibling) {\n    if ((0, _matches2.default)(el, query)) {\n      return el;\n    }\n  }\n\n  return null;\n} /**\n   * # Get Sibling After\n   * Get a nearest sibling after the given element which matches\n   * the given query selector.\n   *\n   * @param {Element} el\n   * @param {String} query\n   * @return {Element|Null}\n   *\n   * @module helpers/traversal/get-sibling-after.js\n   */\n\nexports.default = getSiblingAfter;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-sibling-after.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getSiblingBefore(el, query) {\n\n  while (el = el.previousElementSibling) {\n    if ((0, _matches2.default)(el, query)) {\n      return el;\n    }\n  }\n\n  return null;\n} /**\n   * # Get Sibling Before\n   * Get a nearest sibling before the given element which matches\n   * the given query selector.\n   *\n   * @param {Element} el\n   * @param {String} query\n   * @return {Element|Null}\n   *\n   * @module helpers/traversal/get-sibling-before.js\n   */\n\nexports.default = getSiblingBefore;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-sibling-before.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Has Parent\n * See if an element has another element for a parent.\n *\n * @param {Element} child\n * @param {Element} possibleParent\n * @return {Boolean}\n *\n * @module helpers/traversal/has-parent.js\n */\nfunction hasParent(child, possibleParent) {\n\n  var parent = child.parentNode;\n\n  while (parent) {\n\n    if (parent === possibleParent) {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n}\n\nexports.default = hasParent;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=has-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Matches\n * See if an element matches a query selector.\n *\n * @param {Element} el\n * @param {String} query\n * @return {Boolean}\n *\n * @module helpers/traversal/matches.js\n */\nvar vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);\n\nfunction matches(el, query) {\n\n  if (vendorMatch) return vendorMatch.call(el, query);\n\n  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] === el) return true;\n  }\n\n  return false;\n}\n\nexports.default = matches;\nmodule.exports = exports['default'];\n//# sourceMappingURL=matches.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Pad\n * Pad a number with leading zeros\n *\n * @param {Number} n\n * @param {Number} w\n * @param {String} c Optional String to pad with\n *\n * @example\n * pad(4, 2);\n *\n * @module helpers/util/pad.js\n */\nfunction pad(n, w, c) {\n  c = c || '0';\n  n = n + '';\n  return n.length >= w ? n : new Array(w - n.length + 1).join(c) + n;\n}\n\nexports.default = pad;\nmodule.exports = exports['default'];\n//# sourceMappingURL=pad.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Range\n * Create a range of numbers.\n *\n * @param {Number} start\n * @param {Number} stop\n * @param {Number} step Optional\n * @return {Array}\n *\n * @module helpers/util/range.js\n */\nfunction createRange(start, stop, step) {\n  if (stop == null) {\n    stop = start || 0;\n    start = 0;\n  }\n  if (!step) {\n    step = stop < start ? -1 : 1;\n  }\n\n  var length = Math.max(Math.ceil((stop - start) / step), 0);\n  var range = new Array(length);\n\n  for (var idx = 0; idx < length; idx++, start += step) {\n    range[idx] = start;\n  }\n\n  return range;\n}\n\nexports.default = createRange;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=range.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9jYWxlbmRhci1wb3BvdmVyLmpzIiwianMvZGlzdC9jb21wb25lbnRzL3BvcG92ZXIuanMiLCJqcy9kaXN0L2hlbHBlcnMvYW5pbWF0aW9uL3JlcXVlc3QuanMiLCJqcy9kaXN0L2hlbHBlcnMvYW5pbWF0aW9uL3Njcm9sbC10by5qcyIsImpzL2Rpc3QvaGVscGVycy9hbmltYXRpb24vdHdlZW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvZGF0ZS9kYXRlLmpzIiwianMvZGlzdC9oZWxwZXJzL2RhdGUvcGFyc2UtZm9ybWF0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9hZGQtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2JyZWFrcG9pbnQuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2hhcy1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vb2Zmc2V0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS90cmlnZ2VyLWV2ZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL2Zvcm0vYnVpbGQtc2VsZWN0LmpzIiwianMvZGlzdC9oZWxwZXJzL21hbmlwdWxhdGlvbi9hcHBlbmQtY2hpbGRyZW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYWZmaXguanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYm94LXBvc2l0aW9uLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtc2libGluZy1hZnRlci5qcyIsImpzL2Rpc3QvaGVscGVycy90cmF2ZXJzYWwvZ2V0LXNpYmxpbmctYmVmb3JlLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvcGFkLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvcmFuZ2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC90cmltLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEJhc2UgQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGJhc2UgY2xhc3MgZm9yIFNwYXJrIEpTIGNvbXBvbmVudHMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9iYXNlLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgYW5kIGNhY2hlIGVsZW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZShlbCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgaWYgKHBhcmFtcy5lbFJlcXVpcmVkICYmICFlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMgfHwge30sIHRydWUpO1xuICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgKHRoaXMuX2NhY2hlRWxlbWVudHMgfHwgbm9vcCkuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoIWxlYXZlRWxlbWVudCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cblxuICAgIHRoaXMudW5zZXRQYXJhbXModGhpcy5kZWZhdWx0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXG4gICAgaWYgKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwgfHwgdGhpcy5lbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9hZGRFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgaGFzaCBvZiBwYXJhbWV0ZXJzIGlmIHRoZXkncmUgd2hpdGVsaXN0ZWQgb3Igd2UncmUgdG9sZCB0byBmb3JjZSB0aGUgc2V0LlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gc2V0IGluaXRpYWwgdmFsdWVzIGFzIHdlbGwgYXMgc2V0IHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2Ugc2V0dGluZyBldmVuIGlmIHRoZSBwYXJhbSBpcyBub3Qgd2hpdGVsaXN0ZWQuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gc2V0UGFyYW1zKHBhcmFtcywgZm9yY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShwYXJhbXMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBpZiAoX3RoaXMuX3doaXRlbGlzdGVkUGFyYW1zLmluZGV4T2YoaykgIT09IC0xIHx8IGZvcmNlKSB7XG4gICAgICAgIF90aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNldCBhbGwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBvYmplY3QgdG8gdW5zZXQgdGhlIHBhcmFtcyBmcm9tLiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudW5zZXRQYXJhbXMgPSBmdW5jdGlvbiB1bnNldFBhcmFtcyhrZXlzLCBzY29wZSkge1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICBzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgZGVsZXRlIHNjb3BlW2tdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cbkJhc2UucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFtdO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CYXNlLnByb3RvdHlwZS5kZWZhdWx0cyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfcG9wb3ZlciA9IHJlcXVpcmUoJy4vcG9wb3ZlcicpO1xuXG52YXIgX3BvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9wb3Zlcik7XG5cbnZhciBfcGFyc2VGb3JtYXQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RhdGUvcGFyc2UtZm9ybWF0Jyk7XG5cbnZhciBfcGFyc2VGb3JtYXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VGb3JtYXQpO1xuXG52YXIgX2RhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RhdGUvZGF0ZScpO1xuXG52YXIgX2RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGF0ZSk7XG5cbnZhciBfYnVpbGRTZWxlY3QgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Zvcm0vYnVpbGQtc2VsZWN0Jyk7XG5cbnZhciBfYnVpbGRTZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnVpbGRTZWxlY3QpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX2FwcGVuZENoaWxkcmVuID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYW5pcHVsYXRpb24vYXBwZW5kLWNoaWxkcmVuJyk7XG5cbnZhciBfYXBwZW5kQ2hpbGRyZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kQ2hpbGRyZW4pO1xuXG52YXIgX2dldFBhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQnKTtcblxudmFyIF9nZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UGFyZW50KTtcblxudmFyIF90cmlnZ2VyRXZlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS90cmlnZ2VyLWV2ZW50Jyk7XG5cbnZhciBfdHJpZ2dlckV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaWdnZXJFdmVudCk7XG5cbnZhciBfYnJlYWtwb2ludCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2JyZWFrcG9pbnQnKTtcblxudmFyIF9zY3JvbGxUbyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYW5pbWF0aW9uL3Njcm9sbC10bycpO1xuXG52YXIgX3Njcm9sbFRvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbFRvKTtcblxudmFyIF9nZXRTaWJsaW5nQmVmb3JlID0gcmVxdWlyZSgnLi4vaGVscGVycy90cmF2ZXJzYWwvZ2V0LXNpYmxpbmctYmVmb3JlJyk7XG5cbnZhciBfZ2V0U2libGluZ0JlZm9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRTaWJsaW5nQmVmb3JlKTtcblxudmFyIF9nZXRTaWJsaW5nQWZ0ZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtc2libGluZy1hZnRlcicpO1xuXG52YXIgX2dldFNpYmxpbmdBZnRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRTaWJsaW5nQWZ0ZXIpO1xuXG52YXIgX3JhbmdlID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL3JhbmdlJyk7XG5cbnZhciBfcmFuZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZ2UpO1xuXG52YXIgX3BhcnNlQXR0cmlidXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vcGFyc2UtYXR0cmlidXRlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIENhbGVuZGFyIFBvcG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhIGNhbGVuZGFyIGZyb20gd2hpY2ggZGF0ZXMgY2FuIGJlIHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXcgQ2FsZW5kYXJQb3BvdmVyKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvY2FsZW5kYXItcG9wb3Zlci5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgZG9tRGF0ZUZvcm1hdCA9ICdZWVlZLU1NLUREJztcbnZhciBwYXJzZWREb21Gb3JtYXQgPSAoMCwgX3BhcnNlRm9ybWF0Mi5kZWZhdWx0KShkb21EYXRlRm9ybWF0KTtcblxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEVsZW1lbnQoKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZWwuY2xhc3NOYW1lID0gJ3NwYXJrLWlucHV0IHNwYXJrLWRhdGUnO1xuICBlbC5pbm5lckhUTUwgPSAnPGlucHV0IGNsYXNzPVwic3BhcmstaW5wdXRfX2ZpZWxkXCIgdHlwZT1cImRhdGVcIj48c3BhbiBjbGFzcz1cInNwYXJrLWxhYmVsXCI+PC9zcGFuPic7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgcHJvcGVyIHBhcmFtcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtc1xuICogQHJldHVybiB7T2JqZWN9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW5pdFBhcmFtcyhlbCwgcGFyYW1zKSB7XG5cbiAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb3IgYXJyYXktbGlrZSAoTm9kZUxpc3QpLFxuICAvLyB3ZSB3aWxsIGJlIHdvcmtpbmcgd2l0aCBhIHJhbmdlLlxuICBpZiAoZWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ2xlbmd0aCcpKSB7XG4gICAgcGFyYW1zLmVscyA9IGVsO1xuICB9XG4gIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlIGEgZGVmYXVsdCBlbGVtZW50XG4gIC8vIHNpbmNlIHRoZSB1c2VyIE1VU1QgcHJvdmlkZSBhZGRpdGlvbmFsIHBhcmFtcyBidXQgdGhlIGVsZW1lbnRcbiAgLy8gaXMgb3B0aW9uYWwuIERvaW5nIGl0IHRoaXMgd2F5IHRvIGtlZXAgdGhlIGFyaXR5IHRoZSBzYW1lXG4gIC8vIGFzIG90aGVyIGNvbXBvbmVudHMuXG4gIGVsc2UgaWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHBhcmFtcyA9IGVsIHx8IHt9O1xuICAgICAgcGFyYW1zLmVscyA9IFtjcmVhdGVEZWZhdWx0RWxlbWVudCgpXTtcbiAgICB9XG4gICAgLy8gQSBzaW5nbGUgZWxlbWVudCBpcyBwYXNzZWQuXG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmFtcy5lbHMgPSBbZWxdO1xuICAgICAgfVxuXG4gIHBhcmFtcy52aXNpYmxlQ291bnRzID0gcGFyYW1zLnZpc2libGVDb3VudHMgfHwgKHBhcmFtcy52aXNpYmxlQ291bnQgPyBbcGFyYW1zLnZpc2libGVDb3VudF0gOiBudWxsKTtcbiAgcGFyYW1zLm1pbnMgPSBwYXJhbXMubWlucyB8fCAocGFyYW1zLm1pbiA/IFtwYXJhbXMubWluXSA6IFtdKTtcbiAgcGFyYW1zLm1heGVzID0gcGFyYW1zLm1heGVzIHx8IChwYXJhbXMubWF4ID8gW3BhcmFtcy5tYXhdIDogW10pO1xuICBwYXJhbXMudmFsdWVzID0gcGFyYW1zLnZhbHVlcyB8fCAocGFyYW1zLnZhbHVlID8gW3BhcmFtcy52YWx1ZV0gOiBbXSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxudmFyIENhbGVuZGFyUG9wb3ZlciA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ2FsZW5kYXJQb3BvdmVyLCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENhbGVuZGFyIFBvcG92ZXIgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuICBmdW5jdGlvbiBDYWxlbmRhclBvcG92ZXIoZWwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxlbmRhclBvcG92ZXIpO1xuXG4gICAgcGFyYW1zID0gcGFyc2VJbml0UGFyYW1zKGVsLCBwYXJhbXMpO1xuXG4gICAgaWYgKCEoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQmFzZUNvbXBvbmVudC5jYWxsKHRoaXMsIGVsLCBwYXJhbXMpKSwgX3RoaXMpKSB7XG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNhbGVuZGFyIGVsZW1lbnQgaWYgd2Ugd2VyZW4ndCBwYXNzZWQgb25lLlxuICAgIChfdGhpcy5jYWxlbmRhckVsID8gbm9vcCA6IF90aGlzLl9jcmVhdGVDYWxlbmRhcikuY2FsbChfdGhpcyk7XG4gICAgX3RoaXMuX2NhY2hlQ2FsZW5kYXJFbGVtZW50cygpO1xuXG4gICAgX3RoaXMuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCk7XG4gICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgX3RoaXMuX2luaXREYXRlc1RvU2hvdygpO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcblxuICAgIGlmIChlbCkge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuZWxzID0gZWwgaW5zdGFuY2VvZiBBcnJheSA/IGVsIDogW2VsXTtcbiAgICAgIHRoaXMuX2NhY2hlRWxlbWVudHMoKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdERhdGVzVG9TaG93KCk7XG5cbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHRoaXMuX2NoZWNrU2l6ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBjYWxlbmRhciB3aWRnZXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBPcHRpb25hbCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gdGllIGFjdGlvbnMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cbiAgICBpZiAodGhpcy5faXNEaXNhYmxlZFtpbmRleF0pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX3VuZmlsbFRvZ2dsZSgpO1xuXG4gICAgLy8gQWxsb3cgZm9yIG9ubHkgcGFyYW1zIHRvIGJlIHBhc3NlZFxuICAgIGlmICgodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbmRleCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgcGFyYW1zID0gaW5kZXg7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBvcGVuXG4gICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGFuIGFscmVhZHkgYWN0aXZlIGl0ZW0sIGNsb3NlIGl0XG4gICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2RlYWN0aXZhdGVFbGVtZW50KHRoaXMuYWN0aXZlSW5kZXgpO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFueSB0aW1lcnMgd2hpY2ggbWF5IGJlIHJ1bm5pbmcgdG8gY2xvc2Ugb3Igb3BlbiB0aGlzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX29wZW5DbG9zZVRpbWVyKTtcblxuICAgIC8vIFNldCB0aGUgbmV3IGluZGV4XG4gICAgdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4O1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBvcG92ZXIgeWV0LCBjcmVhdGUgaXQuXG4gICAgaWYgKCF0aGlzLnBvcG92ZXIpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcG92ZXIoKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgZGF0ZXMgdG8gc2hvdyBmb3IgdGhpcyB2aWV3LlxuICAgIHRoaXMuX2luaXREYXRlc1RvU2hvdygpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBjYWNoZWQgdmFsdWVzIGFyZSBpbiBsaW5lIHdpdGggdGhlIGlucHV0IHZhbHVlcy5cbiAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuXG4gICAgLy8gQ3JlYXRlIGEgY2FsZW5kYXIgb3IgY2FsZW5kYXJzIGluc2lkZSB0aGUgcG9wb3ZlclxuICAgIHRoaXMucmVuZGVyKHtcbiAgICAgIGNsZWFyQ2FjaGU6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIEZpbmFsbHksIHNob3cgdGhlIHBvcG92ZXIgYWZ0ZXIgYSBkZWxheSBvciBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIHRoaXMuX29wZW5DbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBvcG92ZXIub3Blbih7XG4gICAgICAgIGFmZml4VG86IHRoaXMuZWxzW2luZGV4XS5xdWVyeVNlbGVjdG9yKCcuc3BhcmstZGF0ZV9fY2FsZW5kYXItdG9nZ2xlJylcbiAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKSwgcGFyYW1zLmRlbGF5IHx8IDApO1xuXG4gICAgLy8gQWN0aXZhdGUgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudFxuICAgIHRoaXMuX2FjdGl2YXRlRWxlbWVudChpbmRleCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIGNhbGVuZGFyIHdpZGdldC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZShwYXJhbXMpIHtcblxuICAgIHRoaXMuX3VuZmlsbFRvZ2dsZSgpO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gQ2FuJ3QgY2xvc2UgaWYgd2UgYXJlbid0IG9yIGhhdmVuJ3QgeWV0IG9wZW5lZC5cbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA9PT0gbnVsbCB8fCAhdGhpcy5wb3BvdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBEZWFjdGl2ZSB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50XG4gICAgdGhpcy5fZGVhY3RpdmF0ZUVsZW1lbnQodGhpcy5hY3RpdmVJbmRleCk7XG5cbiAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgY2xvc2Ugb3Igb3BlbiBldmVudHMgd2hpY2ggYXJlIHF1ZXVlZFxuICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuQ2xvc2VUaW1lcik7XG5cbiAgICAvLyBDbG9zZSBhZnRlciBhIGRlbGF5LCBvciBvbiB0aGUgbmV4dCB0aWNrXG4gICAgdGhpcy5hY3RpdmVJbmRleCA9IG51bGw7XG4gICAgdGhpcy5fb3BlbkNsb3NlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9wb3Zlci5jbG9zZSgpO1xuICAgIH0uYmluZCh0aGlzKSwgcGFyYW1zLmRlbGF5IHx8IDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcnxFbGVtZW50fSBpbmRleCBPcHRpb25hbFxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXggfHwgMF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGF0ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfEVsZW1lbnR9IGluZGV4XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFJhbmdlQ2hlY2sgT3B0aW9uYWwgRG9uJ3QgY2hlY2sgZm9yIHNlcXVlbnRpYWwgcmFuZ2UgdmFsdWVzLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgaW5kZXgsIHNraXBSYW5nZUNoZWNrKSB7XG5cbiAgICB2YXIgb2JqID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXModmFsdWUpO1xuICAgIHZhciBlbCA9IHZvaWQgMDtcblxuICAgIC8vIElmIHdlIGFyZSBwYXNzZWQgYW4gZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGluZGV4LCB1c2UgdGhhdC5cbiAgICBpZiAoaW5kZXggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgZWwgPSBpbmRleDtcbiAgICAgIGluZGV4ID0gdGhpcy5pbnB1dEVscy5pbmRleE9mKGVsKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBmaW5kIHRoZSBlbGVtZW50IGluIG91ciBsaXN0LlxuICAgIGVsc2Uge1xuICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG4gICAgICAgIGVsID0gdGhpcy5pbnB1dEVsc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHN0b3JlZCB2YWx1ZVxuICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IG9iajtcblxuICAgIC8vIElmIHdlIGFyZSB3b3JraW5nIHdpdGggYSByYW5nZSwgbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlcyBhcmUgaW4gb3JkZXIuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl9jaGVja1ZhbHVlcyhpbmRleCwgc2tpcFJhbmdlQ2hlY2spO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgdmFsdWUgb24gdGhlIGlucHV0IGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgIC8vIGxvb3Agc2luY2Ugd2UgbGlzdGVuIHRvIHRoZSBjaGFuZ2UgZXZlbnQgb24gdGhlIGlucHV0LiBXZSBoYXZlIHRvIHRyaWdnZXIgaXRcbiAgICAvLyBzbyB0aGF0IG90aGVyIGNvbXBvbmVudHMgbGlzdGVuaW5nIHRvIGl0IGdldCB0aGUgdXBkYXRlLlxuICAgIGVsLnZhbHVlID0gdmFsdWUgJiYgb2JqID09PSB2YWx1ZSA/IHBhcnNlZERvbUZvcm1hdC5nZXRTdHJpbmcodmFsdWUpIDogdmFsdWUgfHwgJyc7XG5cbiAgICB0aGlzLl9pbnB1dHNDaGFuZ2luZyA9IHRoaXMuX2lucHV0c0NoYW5naW5nIHx8IFtdO1xuICAgIGlmICh0aGlzLl9pbnB1dHNDaGFuZ2luZy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2lucHV0c0NoYW5naW5nLnB1c2goaW5kZXgpO1xuXG4gICAgICAoMCwgX3RyaWdnZXJFdmVudDIuZGVmYXVsdCkoZWwsICdjaGFuZ2UnKTtcbiAgICAgICh0aGlzLm9uQ2hhbmdlIHx8IG5vb3ApKGVsLCBlbC52YWx1ZSwgdGhpcyk7XG5cbiAgICAgIHZhciBwb3MgPSB0aGlzLl9pbnB1dHNDaGFuZ2luZy5pbmRleE9mKGluZGV4KTtcbiAgICAgIHRoaXMuX2lucHV0c0NoYW5naW5nLnNwbGljZShwb3MsIDEpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKHtcbiAgICAgIGNsZWFyQ2FjaGU6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgc2VsZWN0ZWQgdmFsdWVzLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuY2xlYXJWYWx1ZXMgPSBmdW5jdGlvbiBjbGVhclZhbHVlcygpIHtcblxuICAgIHZhciBlbHMgPSB0aGlzLmlucHV0RWxzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZWxzLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuY2xlYXJWYWx1ZShpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLmNsZWFyVmFsdWUgPSBmdW5jdGlvbiBjbGVhclZhbHVlKCkge1xuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMgfHwgW107XG4gICAgaWYgKCF0aGlzLmlucHV0RWxzW2luZGV4XSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2xlYXIgdmFsdWUgYXQgaW5kZXggJyArIGluZGV4ICsgJy4gTm8gaW5wdXQgZWxlbWVudCBleGlzdHMgd2l0aCB0aGF0IGluZGV4IScpO1xuICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHRoaXMuaW5wdXRFbHNbaW5kZXhdLnZhbHVlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGFrZSB0aGUgZGF0ZSB2YWx1ZXMgZnJvbSB0aGUgaW5wdXRzIGFuZCBzZXQgdGhlbSBhcyBkYXRlcyBvbiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS51cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbiB1cGRhdGVWYWx1ZXMoKSB7XG5cbiAgICB2YXIgZWxzID0gdGhpcy5pbnB1dEVscztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGVscy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlIHRoZSBkYXRlIHZhbHVlcyBmcm9tIHRoZSBpbnB1dHMgYW5kIHNldCB0aGVtIGFzIGRhdGVzIG9uIHRoZSBjYWxlbmRhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS51cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKCkge1xuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMgfHwgW107XG4gICAgaWYgKCF0aGlzLmlucHV0RWxzW2luZGV4XSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIHZhbHVlIGF0IGluZGV4ICcgKyBpbmRleCArICcuIE5vIGlucHV0IGVsZW1lbnQgZXhpc3RzIHdpdGggdGhhdCBpbmRleCEnKTtcbiAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB0aGlzLmlucHV0RWxzW2luZGV4XS52YWx1ZSA/IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXModGhpcy5pbnB1dEVsc1tpbmRleF0udmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgY2FsZW5kYXIgZnVuY3Rpb25hbGl0eS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZShpbmRleCkge1xuXG4gICAgdmFyIGkgPSBpbmRleCB8fCAwO1xuICAgIHZhciBsZW4gPSBpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggKyAxIDogdGhpcy5lbHMubGVuZ3RoO1xuICAgIHZhciB0b2dnbGUgPSB2b2lkIDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLl9pc0Rpc2FibGVkW2ldID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWxzW2ldLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJyk7XG4gICAgICB0b2dnbGUgPSB0aGlzLmVsc1tpXS5xdWVyeVNlbGVjdG9yKCcuc3BhcmstZGF0ZV9fY2FsZW5kYXItdG9nZ2xlJyk7XG4gICAgICBpZiAodG9nZ2xlKSB0b2dnbGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBjYWxlbmRhciBmdW5jdGlvbmFsaXR5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShpbmRleCkge1xuXG4gICAgdmFyIGkgPSBpbmRleCB8fCAwO1xuICAgIHZhciBsZW4gPSBpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggKyAxIDogdGhpcy5lbHMubGVuZ3RoO1xuICAgIHZhciB0b2dnbGUgPSB2b2lkIDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLl9pc0Rpc2FibGVkW2ldID0gZmFsc2U7XG4gICAgICB0aGlzLmVsc1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgICAgdG9nZ2xlID0gdGhpcy5lbHNbaV0ucXVlcnlTZWxlY3RvcignLnNwYXJrLWRhdGVfX2NhbGVuZGFyLXRvZ2dsZScpO1xuICAgICAgaWYgKHRvZ2dsZSkgdG9nZ2xlLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBjYWxlbmRhciBvciBjYWxlbmRhcnMgaW50byB0aGUgcG9wb3Zlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBvcG92ZXIgeWV0LCBjcmVhdGUgaXQuXG4gICAgaWYgKCF0aGlzLnBvcG92ZXIpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcG92ZXIoKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcblxuICAgIC8vIENsZWFyIHRoZSBjYWNoZSBzbyB0aGF0IHdlIGRvbid0IHNob3cgb3V0LW9mLWRhdGUgdmFsdWVzLlxuICAgIGlmIChwYXJhbXMuY2xlYXJDYWNoZSkge1xuICAgICAgdGhpcy5fcmVuZGVyQ2FjaGUgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHZpc2libGUgZGF5cywgd2Vla3MsIG1vbnRocyBvciB5ZWFyc1xuICAgIGlmICh0aGlzLnZpZXdSYW5nZSA9PT0gJ3llYXInKSBjb250ZW50ID0gdGhpcy5fcmVuZGVyWWVhcnMoKTtlbHNlIGlmICh0aGlzLnZpZXdSYW5nZSA9PT0gJ3dlZWsnKSBjb250ZW50ID0gdGhpcy5fcmVuZGVyV2Vla3MoKTtlbHNlIGlmICh0aGlzLnZpZXdSYW5nZSA9PT0gJ2RheScpIGNvbnRlbnQgPSB0aGlzLl9yZW5kZXJEYXlzKCk7ZWxzZSBjb250ZW50ID0gdGhpcy5fcmVuZGVyTW9udGhzKCk7XG5cbiAgICB0aGlzLl9pbnNlcnRDb250ZW50KGNvbnRlbnQsIHBhcmFtcyk7XG5cbiAgICAvLyBVcGRhdGUgYXR0cmlidXRlc1xuICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZXMoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIGFuZCByZW1vdmVzIGhlbHBlcnMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IExlYXZlIHRoZSBlbGVtZW50IGludGFjdC5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcbiAgICB0aGlzLnBvcG92ZXIucmVtb3ZlKCk7XG4gICAgcmV0dXJuIF9CYXNlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBsZWF2ZUVsZW1lbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIHRoZSBuZXh0IHNldCBvZiBkYXRlcy5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmICh0aGlzLl9hdE1heCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fc2V0RGF0ZXNUb1Nob3coMSk7XG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgYXBwZW5kOiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdG8gdGhlIHByZXZpb3VzIHNldCBvZiBkYXRlcy5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgaWYgKHRoaXMuX2F0TWluKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9zZXREYXRlc1RvU2hvdygtMSk7XG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgcHJlcGVuZDogMVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IGEgc3BlY2lmaWMgZGF0ZSBvbiB0aGUgY2FsZW5kYXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLnNob3dEYXRlID0gZnVuY3Rpb24gc2hvd0RhdGUocGFyYW1zKSB7XG5cbiAgICAvLyBPcGVuIGlmIHdlJ3JlIGNsb3NlZC5cbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuXG4gICAgdmFyIG1vbnRoID0gcGFyYW1zLm1vbnRoIHx8IG51bGw7XG4gICAgdmFyIHllYXIgPSBwYXJhbXMueWVhciB8fCBudWxsO1xuICAgIHZhciBkYXkgPSBwYXJhbXMuZGF5IHx8IG51bGw7XG5cbiAgICAvLyBOb3RoaW5nIHRvIGRvLlxuICAgIGlmICghbW9udGggJiYgIXllYXIgJiYgIWRheSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNob3dpbmcgPSB0aGlzLl9kYXRlc1RvU2hvd1t0aGlzLmFjdGl2ZUluZGV4XS5jbG9uZSgpO1xuICAgIHZhciBub3VuID0gdGhpcy52aWV3UmFuZ2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0aGlzLnZpZXdSYW5nZS5zbGljZSgxKTtcblxuICAgIC8vIE9ubHkgY2hhbmdlIHRoZSB2YWx1ZXMgd2Ugd2VyZSBnaXZlblxuICAgIGlmICh5ZWFyKSB7XG4gICAgICBzaG93aW5nLnllYXIgPSB5ZWFyO1xuICAgIH1cbiAgICBpZiAobW9udGgpIHtcbiAgICAgIHNob3dpbmcubW9udGggPSBtb250aDtcbiAgICB9XG4gICAgaWYgKGRheSkge1xuICAgICAgc2hvd2luZy5kYXkgPSBkYXk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgbWluXG4gICAgdmFyIG1pbiA9IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XTtcbiAgICBpZiAobWluICYmIHNob3dpbmdbJ2JlZm9yZScgKyBub3VuXShtaW4pKSB7XG4gICAgICBzaG93aW5nID0gbWluLmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgbWF4XG4gICAgdmFyIG1heCA9IHRoaXMubWF4ZXNbdGhpcy5hY3RpdmVJbmRleF07XG4gICAgaWYgKG1heCAmJiBzaG93aW5nWydhZnRlcicgKyBub3VuXShtYXgpKSB7XG4gICAgICBzaG93aW5nID0gbWF4LmNsb25lKCk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGVzVG9TaG93W3RoaXMuYWN0aXZlSW5kZXhdID0gc2hvd2luZztcblxuICAgIC8vIFBvcHVsYXRlIHRoZSByZXN0IG9mIHRoZSBkYXRlc1xuICAgIHRoaXMuX3NldERhdGVzVG9TaG93KCk7XG5cbiAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgeWVhcnMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlclllYXJzID0gZnVuY3Rpb24gX3JlbmRlclllYXJzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlzcGxheWluZyB5ZWFycyBpbiB0aGUgY2FsZW5kYXIgaXMgbm90IHlldCBzdXBwb3J0ZWQhJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIHdlZWtzLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJXZWVrcyA9IGZ1bmN0aW9uIF9yZW5kZXJXZWVrcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BsYXlpbmcgd2Vla3MgaW4gdGhlIGNhbGVuZGFyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBkYXlzLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJEYXlzID0gZnVuY3Rpb24gX3JlbmRlckRheXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwbGF5aW5nIGRheXMgaW4gdGhlIGNhbGVuZGFyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBtb250aHMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlck1vbnRocyA9IGZ1bmN0aW9uIF9yZW5kZXJNb250aHMoKSB7XG5cbiAgICB2YXIgbW9udGhzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLl9kYXRlc1RvU2hvdy5sZW5ndGg7XG4gICAgdmFyIGN1cnJlbnQgPSBfZGF0ZTIuZGVmYXVsdC5ub3coKTtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1vbnRocy5wdXNoKHRoaXMuX3JlbmRlck1vbnRoKHRoaXMuX2RhdGVzVG9TaG93W2ldLCBjdXJyZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbnRocztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgbW9udGguXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50XG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcmVuZGVyTW9udGggPSBmdW5jdGlvbiBfcmVuZGVyTW9udGgoZGF0ZSwgY3VycmVudCkge1xuXG4gICAgLy8gQSB1bmlxdWUga2V5IGZvciB0aGlzIG1vbnRoIHVzZWQgZm9yIGNhY2hpbmdcbiAgICB2YXIga2V5ID0gZGF0ZS55ZWFyICsgJy0nICsgZGF0ZS5tb250aDtcblxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgY2FjaGVcbiAgICB0aGlzLl9yZW5kZXJDYWNoZSA9IHRoaXMuX3JlbmRlckNhY2hlIHx8IHt9O1xuXG4gICAgLy8gUmV0dXJuIGEgY2FjaGVkIGluc3RhbmNlXG4gICAgaWYgKHRoaXMuX3JlbmRlckNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJDYWNoZVtrZXldO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBodG1sID0gJyc7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NwYXJrLWNhbGVuZGFyX19tb250aCAnICsgdGhpcy5fZ2V0TW9udGhDbGFzc05hbWVzKGRhdGUpO1xuXG4gICAgLy8gQWRkIHRoZSB0aXRsZSBvciBkcm9wZG93bnMuXG4gICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19tb250aC10aXRsZVwiPic7XG4gICAgaWYgKHRoaXMucXVpY2tKdW1wICYmIHRoaXMudmlzaWJsZUNvdW50c1t0aGlzLmFjdGl2ZUluZGV4XSA9PT0gMSkge1xuICAgICAgaHRtbCArPSB0aGlzLl9yZW5kZXJNb250aFF1aWNrSnVtcChkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaHRtbCArPSBkYXRlLm1vbnRoTmFtZSArICcgJyArIGRhdGUueWVhcjtcbiAgICB9XG4gICAgaHRtbCArPSAnPC9kaXY+JztcblxuICAgIC8vIEFkZCB0aGUgZGF5cyBvZiB0aGUgd2VlayBoZWFkaW5nc1xuICAgIGh0bWwgKz0gdGhpcy5fcmVuZGVyTW9udGhEYXlzT2ZXZWVrKCk7XG5cbiAgICAvLyBBZGQgdGhlIGRheXNcbiAgICBodG1sICs9IHRoaXMuX3JlbmRlck1vbnRoRGF5cyhkYXRlLCBjdXJyZW50KTtcblxuICAgIGVsLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAvLyBTdG9yZSBpbiB0aGUgY2FjaGUgYW5kIHJldHVyblxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJDYWNoZVtrZXldID0gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc2VsZWN0IGlucHV0cyB1c2VkIGZvciBqdW1waW5nIGFoZWFkL2JhY2t3YXJkIHNldmVyYWwgbW9udGhzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbmRlck1vbnRoUXVpY2tKdW1wID0gZnVuY3Rpb24gX3JlbmRlck1vbnRoUXVpY2tKdW1wKGRhdGUpIHtcblxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciB5ZWFycyA9IHZvaWQgMDtcbiAgICB2YXIgbW9udGhzID0gdm9pZCAwO1xuXG4gICAgLy8gTWluIGFuZCBtYXggeWVhciB0byBzaG93XG4gICAgdmFyIG1pbiA9IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XSA/IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XS5jbG9uZSgpIDogbnVsbDtcbiAgICB2YXIgbWF4ID0gdGhpcy5tYXhlc1t0aGlzLmFjdGl2ZUluZGV4XSA/IHRoaXMubWF4ZXNbdGhpcy5hY3RpdmVJbmRleF0uY2xvbmUoKSA6IG51bGw7XG5cbiAgICAvLyBObyBtaW4sIGdvIDUwIHllYXJzIGJhY2tcbiAgICBpZiAoIW1pbikge1xuICAgICAgbWluID0gZGF0ZS5jbG9uZSgpO1xuICAgICAgbWluLnllYXIgPSBtaW4ueWVhciAtIDUwO1xuICAgIH1cblxuICAgIC8vIE5vIG1heCwgZ28gNTAgeWVhcnMgZm9yd2FyZFxuICAgIGlmICghbWF4KSB7XG4gICAgICBtYXggPSBkYXRlLmNsb25lKCk7XG4gICAgICBtYXgueWVhciA9IG1heC55ZWFyICsgNTA7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBtb250aHMgdG8gc2hvdy5cbiAgICB2YXIgbW9udGhPcHRzID0gX2RhdGUyLmRlZmF1bHQuZ2V0TW9udGhOYW1lcygpLm1hcChmdW5jdGlvbiAodmFsLCBpKSB7XG5cbiAgICAgIC8vIERvbid0IHNob3cgYSBtb250aCB0aGF0IGlzIG91dCBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICBpZiAobWluLnllYXIgPT09IG1heC55ZWFyICYmIChpICsgMSA8IG1pbi5tb250aCB8fCBpICsgMSA+IG1heC5tb250aCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBpICsgMSxcbiAgICAgICAgdGV4dDogdmFsXG4gICAgICB9O1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSk7XG5cbiAgICAvLyBNaW4gYW5kIG1heCBhcmUgdGhlIHNhbWUgbW9udGgsIHNvIGp1c3Qgc2hvdyB0ZXh0LlxuICAgIGlmICghbW9udGhPcHRzLmxlbmd0aCB8fCBtb250aE9wdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBtb250aHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBtb250aHMuaW5uZXJIVE1MID0gZGF0ZS5tb250aE5hbWUgKyAnICc7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gQnVpbGQgYSBzZWxlY3QgbGlzdCBvZiBtb250aHNcbiAgICAgIG1vbnRocyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShtb250aHMsICdzcGFyay1zZWxlY3Qgc3BhcmstY2FsZW5kYXJfX3NlbGVjdCcpO1xuICAgICAgbW9udGhzLmFwcGVuZENoaWxkKCgwLCBfYnVpbGRTZWxlY3QyLmRlZmF1bHQpKHtcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdGUubW9udGgsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBjbGFzczogJ3NwYXJrLXNlbGVjdF9faW5wdXQnLFxuICAgICAgICAgIG5hbWU6ICdtb250aCdcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uczogbW9udGhPcHRzXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gTWluIGFuZCBtYXggeWVhciBhcmUgdGhlIHNhbWUsIHNvIGp1c3Qgc2hvdyB0ZXh0LlxuICAgIGlmIChtaW4ueWVhciA9PT0gbWF4LnllYXIpIHtcbiAgICAgIHllYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgeWVhcnMuaW5uZXJIVE1MID0gZGF0ZS55ZWFyO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIEJ1aWxkIGEgc2VsZWN0IGxpc3Qgb2YgeWVhcnNcbiAgICAgIHllYXJzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHllYXJzLCAnc3Bhcmstc2VsZWN0IHNwYXJrLWNhbGVuZGFyX19zZWxlY3QnKTtcbiAgICAgIHllYXJzLmFwcGVuZENoaWxkKCgwLCBfYnVpbGRTZWxlY3QyLmRlZmF1bHQpKHtcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdGUueWVhcixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGNsYXNzOiAnc3Bhcmstc2VsZWN0X19pbnB1dCcsXG4gICAgICAgICAgbmFtZTogJ3llYXInXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6ICgwLCBfcmFuZ2UyLmRlZmF1bHQpKG1heC55ZWFyLCBtaW4ueWVhciAtIDEpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgKDAsIF9hcHBlbmRDaGlsZHJlbjIuZGVmYXVsdCkoZWwsIFttb250aHMsIHllYXJzXSk7XG5cbiAgICByZXR1cm4gZWwuaW5uZXJIVE1MO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGRheXMgb2Ygd2VlayByb3cgZm9yIGEgbW9udGggY2FsZW5kYXIuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJNb250aERheXNPZldlZWsgPSBmdW5jdGlvbiBfcmVuZGVyTW9udGhEYXlzT2ZXZWVrKCkge1xuXG4gICAgdmFyIGRheXNPZldlZWsgPSBfZGF0ZTIuZGVmYXVsdC5nZXREYXlOYW1lcygpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZGF5c09mV2Vlay5sZW5ndGg7XG4gICAgdmFyIHN0ciA9ICc8ZGl2IGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX2RheXMtb2Ytd2Vla1wiPic7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdHIgKz0gJzxzcGFuIGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX2RheS1vZi13ZWVrXCI+JyArIGRheXNPZldlZWtbaV1bMF0gKyAnPC9zcGFuPic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ciArPSAnPC9kaXY+JztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBkYXlzIG9mIHdlZWsgcm93IGZvciBhIG1vbnRoIGNhbGVuZGFyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcmVuZGVyTW9udGhEYXlzID0gZnVuY3Rpb24gX3JlbmRlck1vbnRoRGF5cyhkYXRlLCBjdXJyZW50KSB7XG5cbiAgICB2YXIgZGF5T2ZXZWVrID0gZGF0ZS5tb250aFN0YXJ0LmRheU9mV2VlaztcbiAgICB2YXIgc3RhcnRPZldlZWsgPSBkYXlPZldlZWsgPiAxID8gZGF0ZS5tb250aFN0YXJ0LndlZWtTdGFydCA6IG51bGw7XG4gICAgdmFyIG1vbnRoRW5kID0gZGF0ZS5tb250aEVuZDtcbiAgICB2YXIgd2Vla3MgPSA2O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIHN0ciA9ICc8ZGl2IGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX2RheXNcIj4nO1xuICAgIHZhciBkYXkgPSAwO1xuICAgIHZhciBtb250aCA9IHN0YXJ0T2ZXZWVrID8gc3RhcnRPZldlZWsubW9udGggOiBkYXRlLm1vbnRoO1xuICAgIHZhciB5ZWFyID0gc3RhcnRPZldlZWsgPyBzdGFydE9mV2Vlay55ZWFyIDogZGF0ZS55ZWFyO1xuICAgIHZhciBpc0N1cnJlbnRNb250aCA9IGN1cnJlbnQueWVhciA9PT0gZGF0ZS55ZWFyICYmIGN1cnJlbnQubW9udGggPT09IGRhdGUubW9udGg7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGRheXMgdGhhdCBjb21lIGJlZm9yZSB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoLCB0aGUgZGF5cyB3aWxsIHN0YXJ0IGFzXG4gICAgLy8gaW5hY3RpdmUuIFdlIHVzZSBhIDEgaGVyZSB0byBpbmRpY2F0ZSB0aGUgZGF0ZSBpcyBpbmFjdGl2ZSBhbmQgX2JlZm9yZV9cbiAgICAvLyB0aGUgc3RhcnQgb2YgdGhlIG1vbnRoLlxuICAgIHZhciBpbmFjdGl2ZSA9IHN0YXJ0T2ZXZWVrID8gMSA6IG51bGw7XG5cbiAgICBmb3IgKDsgaSA8IHdlZWtzOyBpKyspIHtcbiAgICAgIGZvciAoOyBqIDwgNzsgaisrKSB7XG5cbiAgICAgICAgZGF5ID0gc3RhcnRPZldlZWsgPyBzdGFydE9mV2Vlay5kYXkgKyBqIDogZGF5ICsgMTtcbiAgICAgICAgc3RyICs9IHRoaXMuX3JlbmRlck1vbnRoRGF5KGRheSwgbW9udGgsIHllYXIsIGlzQ3VycmVudE1vbnRoLCBjdXJyZW50LCBpbmFjdGl2ZSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0T2ZXZWVrICYmIGogKyAxID49IGRheU9mV2VlayAtIDEpIHtcbiAgICAgICAgICBzdGFydE9mV2VlayA9IG51bGw7XG4gICAgICAgICAgaW5hY3RpdmUgPSBudWxsO1xuICAgICAgICAgIGRheSA9IDA7XG4gICAgICAgICAgbW9udGggPSBkYXRlLm1vbnRoO1xuICAgICAgICAgIHllYXIgPSBkYXRlLnllYXI7XG4gICAgICAgICAgaXNDdXJyZW50TW9udGggPSBjdXJyZW50LnllYXIgPT09IGRhdGUueWVhciAmJiBjdXJyZW50Lm1vbnRoID09PSBkYXRlLm1vbnRoO1xuICAgICAgICB9IGVsc2UgaWYgKGRheSA+PSBtb250aEVuZC5kYXkgJiYgaSA+IDApIHtcblxuICAgICAgICAgIC8vIEluYWN0aXZlIGRheXMgdGhhdCBjb21lIF9hZnRlcl8gdGhlIGxhc3Qgb2YgdGhlIG1vbnRoIGFyZSBkZW5vdGVkIHdpdGggYSAyLlxuICAgICAgICAgIC8vIF9yZW5kZXJNb250aERheSBoYW5kbGVzIDFzIGFuZCAycyBkaWZmZXJlbnRseSwgYnV0IGJvdGggYWRkIHRoZSBpbmFjdGl2ZSBjbGFzcy5cbiAgICAgICAgICBpbmFjdGl2ZSA9IDI7XG4gICAgICAgICAgaXNDdXJyZW50TW9udGggPSBmYWxzZTtcblxuICAgICAgICAgIGRheSA9IDA7XG4gICAgICAgICAgbW9udGgrKztcblxuICAgICAgICAgIGlmIChtb250aCA+IDEyKSB7XG4gICAgICAgICAgICB5ZWFyKys7XG4gICAgICAgICAgICBtb250aCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyICs9ICc8L2Rpdj4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGF5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aFxuICAgKiBAcGFyYW0ge051bWJlcn0geWVhclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ3VycmVudE1vbnRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5hY3RpdmVcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9yZW5kZXJNb250aERheSA9IGZ1bmN0aW9uIF9yZW5kZXJNb250aERheShkYXksIG1vbnRoLCB5ZWFyLCBpc0N1cnJlbnRNb250aCwgY3VycmVudCwgaW5hY3RpdmUpIHtcblxuICAgIHZhciBkYXRlID0gX2RhdGUyLmRlZmF1bHQuY3JlYXRlKHtcbiAgICAgIHllYXI6IHllYXIsXG4gICAgICBtb250aDogbW9udGgsXG4gICAgICBkYXk6IGRheVxuICAgIH0pO1xuICAgIHZhciBzdHIgPSAnPGEnO1xuICAgIHZhciBkaXNhYmxlZCA9IGluYWN0aXZlIHx8IHRoaXMuX2lzRGF5RGlzYWJsZWQoZGF0ZSk7XG5cbiAgICBzdHIgKz0gIWRpc2FibGVkID8gJyBkYXRhLWRhdGU9XCInICsgcGFyc2VkRG9tRm9ybWF0LmdldFN0cmluZyhkYXRlKSArICdcIicgOiAnJztcbiAgICBzdHIgKz0gaW5hY3RpdmUgPyAnIGRhdGEtZGlyZWN0aW9uPVwiJyArIChpbmFjdGl2ZSA9PT0gMiA/ICduZXh0JyA6ICdwcmV2aW91cycpICsgJ1wiJyA6ICcnO1xuICAgIHN0ciArPSAnIGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX2RheSc7XG4gICAgc3RyICs9IGlzQ3VycmVudE1vbnRoICYmIGN1cnJlbnQuZGF5ID09PSBkYXkgJiYgY3VycmVudC5tb250aCA9PT0gbW9udGggJiYgY3VycmVudC55ZWFyID09PSB5ZWFyID8gJyBzcGFyay1jYWxlbmRhcl9fZGF5LS10b2RheScgOiAnJztcbiAgICBzdHIgKz0gaW5hY3RpdmUgPyAnIHNwYXJrLWNhbGVuZGFyX19kYXktLWluYWN0aXZlJyA6ICcnO1xuICAgIHN0ciArPSBkaXNhYmxlZCA/ICcgc3BhcmstY2FsZW5kYXJfX2RheS0tZGlzYWJsZWQnIDogJyc7XG4gICAgc3RyICs9IHRoaXMuX2lzRGF5U2VsZWN0ZWQoZGF0ZSkgPyAnIHNwYXJrLWNhbGVuZGFyX19kYXktLXNlbGVjdGVkJyA6ICcnO1xuICAgIHN0ciArPSB0aGlzLl9pc0RheVJhbmdlU3RhcnQoZGF0ZSkgPyAnIHNwYXJrLWNhbGVuZGFyX19yYW5nZS1zdGFydCcgOiAnJztcbiAgICBzdHIgKz0gdGhpcy5faXNEYXlSYW5nZU1pZGRsZShkYXRlKSA/ICcgc3BhcmstY2FsZW5kYXJfX3JhbmdlLW1pZGRsZScgOiAnJztcbiAgICBzdHIgKz0gdGhpcy5faXNEYXlSYW5nZUVuZChkYXRlKSA/ICcgc3BhcmstY2FsZW5kYXJfX3JhbmdlLWVuZCcgOiAnJztcbiAgICBzdHIgKz0gdGhpcy5faXNEYXlSYW5nZUxhc3QoZGF0ZSkgPyAnIHNwYXJrLWNhbGVuZGFyX19yYW5nZS1sYXN0JyA6ICcnO1xuICAgIHN0ciArPSAnXCInO1xuICAgIHN0ciArPSAnIGhyZWY9XCIjXCI+PHNwYW4+JztcbiAgICBzdHIgKz0gZGF5O1xuICAgIHN0ciArPSB0aGlzLl9nZXREYXlJbmZvKGRhdGUpO1xuICAgIHN0ciArPSAnPC9zcGFuPjwvYT4nO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBjaGlsZHJlbiBpbnRvIHRoZSBjb250ZW50LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb250ZW50XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5faW5zZXJ0Q29udGVudCA9IGZ1bmN0aW9uIF9pbnNlcnRDb250ZW50KGNvbnRlbnQsIHBhcmFtcykge1xuXG4gICAgdGhpcy5fY3VycmVudENvbnRlbnQgPSB0aGlzLl9jdXJyZW50Q29udGVudCB8fCBbXTtcblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHZhciBrZWVwID0gdm9pZCAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UndmUgYmVlbiBhc2tlZCB0byBwcmVwZW5kIG9yIGFwcGVuZCwgYWRkIHRoZSBuZXcgZWxlbWVudHMgaW4gZnJvbnQsXG4gICAgLy8gc2F2ZSB0aGUgbnVtYmVyIG9mIG9sZCBlbGVtZW50cyB3ZSdyZSBzbGlkaW5nIG91dCwgYW5pbWF0ZSxcbiAgICAvLyB0aGVuIGNsZWFuIHVwLlxuICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcblxuICAgICAgaWYgKHBhcmFtcy5wcmVwZW5kKSB7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnRzIHRvIGtlZXBcbiAgICAgICAga2VlcCA9IHRoaXMuX2N1cnJlbnRDb250ZW50LnNsaWNlKC1wYXJhbXMucHJlcGVuZCk7XG4gICAgICAgIGxlbiA9IGtlZXAubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKGtlZXBbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhckVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wcmVwZW5kLWNvdW50JywgbGVuKTtcblxuICAgICAgICB0aGlzLl9hbmltYXRlQ29udGVudChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICB0aGlzLmNhbGVuZGFyRWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXByZXBlbmQtY291bnQnKTtcblxuICAgICAgICAgIHRoaXMuX2FuaW1hdGVDb250ZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC1wYXJhbXMucHJlcGVuZCk7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgIH0sIHRoaXMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9XG4gICAgICAvLyBTYW1lIGJ1dCBhcHBlbmRpbmdcbiAgICAgIGVsc2UgaWYgKHBhcmFtcy5hcHBlbmQpIHtcblxuICAgICAgICAgIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudHMgdG8ga2VlcFxuICAgICAgICAgIGtlZXAgPSB0aGlzLl9jdXJyZW50Q29udGVudC5zbGljZSgwLCBwYXJhbXMuYXBwZW5kKTtcbiAgICAgICAgICBsZW4gPSBrZWVwLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb250ZW50LnVuc2hpZnQoa2VlcFtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jYWxlbmRhckVsLnNldEF0dHJpYnV0ZSgnZGF0YS1hcHBlbmQtY291bnQnLCBsZW4pO1xuXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZUNvbnRlbnQoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLmNhbGVuZGFyRWwsICduby1hbmltYXRlJyk7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZShwYXJhbXMuYXBwZW5kKTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydENvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyRWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFwcGVuZC1jb3VudCcpO1xuXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlQ29udGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY2FsZW5kYXJFbCwgJ25vLWFuaW1hdGUnKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICB9LCB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICgwLCBfYXBwZW5kQ2hpbGRyZW4yLmRlZmF1bHQpKHRoaXMuY2FsZW5kYXJDb250ZW50RWwsIHRoaXMuX2N1cnJlbnRDb250ZW50ID0gY29udGVudCwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIGEgZ2l2ZW4gZGF5IHNlbGVjdGVkP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2lzRGF5U2VsZWN0ZWQgPSBmdW5jdGlvbiBfaXNEYXlTZWxlY3RlZChkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzICYmIGRhdGUuZXF1YWwodGhpcy52YWx1ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRheSB0aGUgc3RhcnQgb2YgYSByYW5nZT9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9pc0RheVJhbmdlU3RhcnQgPSBmdW5jdGlvbiBfaXNEYXlSYW5nZVN0YXJ0KGRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEVscy5sZW5ndGggPiAxICYmIHRoaXMudmFsdWVzICYmIGRhdGUuZXF1YWwodGhpcy52YWx1ZXNbMF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRheSB0aGUgbWlkZGxlIG9mIGEgcmFuZ2U/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5faXNEYXlSYW5nZU1pZGRsZSA9IGZ1bmN0aW9uIF9pc0RheVJhbmdlTWlkZGxlKGRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEVscy5sZW5ndGggPiAxICYmIHRoaXMudmFsdWVzICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+IDEgJiYgZGF0ZS5lcXVhbCh0aGlzLnZhbHVlcy5zbGljZSgxLCAtMSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRheSB0aGUgZW5kIG9mIGEgcmFuZ2U/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5faXNEYXlSYW5nZUVuZCA9IGZ1bmN0aW9uIF9pc0RheVJhbmdlRW5kKGRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEVscy5sZW5ndGggPiAxICYmIHRoaXMudmFsdWVzICYmIHRoaXMudmFsdWVzLmxlbmd0aCA+IDEgJiYgZGF0ZS5lcXVhbCh0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIGEgZ2l2ZW4gZGF5IGN1cnJlbnRseSB0aGUgbGFzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2lzRGF5UmFuZ2VMYXN0ID0gZnVuY3Rpb24gX2lzRGF5UmFuZ2VMYXN0KGRhdGUpIHtcblxuICAgIHZhciBpID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG5cbiAgICAgIC8vIFdlIGhhdmUgYSB2YWx1ZSBhbmQgaXQncyBub3QgdGhlIHNhbWUgYXMgdGhlIGRhdGUuXG4gICAgICBpZiAodGhpcy52YWx1ZXNbaV0pIHtcbiAgICAgICAgaWYgKCFkYXRlLmVxdWFsKHRoaXMudmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSXMgYSBnaXZlbiBkYXkgZGlzYWJsZWQ/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5faXNEYXlEaXNhYmxlZCA9IGZ1bmN0aW9uIF9pc0RheURpc2FibGVkKGRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5kYXlzRGlzYWJsZWQgJiYgdGhpcy5kYXlzRGlzYWJsZWRbZGF0ZS55ZWFyXSAmJiB0aGlzLmRheXNEaXNhYmxlZFtkYXRlLnllYXJdW2RhdGUubW9udGhdICYmIHRoaXMuZGF5c0Rpc2FibGVkW2RhdGUueWVhcl1bZGF0ZS5tb250aF0uaW5kZXhPZihkYXRlLmRheSkgIT09IC0xIHx8IHRoaXMubWluc1t0aGlzLmFjdGl2ZUluZGV4XSAmJiBkYXRlLmJlZm9yZSh0aGlzLm1pbnNbdGhpcy5hY3RpdmVJbmRleF0sIHRydWUpIHx8IHRoaXMubWF4ZXNbdGhpcy5hY3RpdmVJbmRleF0gJiYgZGF0ZS5hZnRlcih0aGlzLm1heGVzW3RoaXMuYWN0aXZlSW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFueSBcImluZm9cIiBmb3IgYSBnaXZlbiBkYXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9nZXREYXlJbmZvID0gZnVuY3Rpb24gX2dldERheUluZm8oZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmRheXNJbmZvICYmIHRoaXMuZGF5c0luZm9bZGF0ZS55ZWFyXSAmJiB0aGlzLmRheXNJbmZvW2RhdGUueWVhcl1bZGF0ZS5tb250aF0gJiYgdGhpcy5kYXlzSW5mb1tkYXRlLnllYXJdW2RhdGUubW9udGhdW2RhdGUuZGF5XSA/ICc8c3BhbiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19kYXktbm90ZVwiPicgKyB0aGlzLmRheXNJbmZvW2RhdGUueWVhcl1bZGF0ZS5tb250aF1bZGF0ZS5kYXldICsgJzwvc3Bhbj4nIDogJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xhc3MgbmFtZXMgZm9yIGEgbW9udGguXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9nZXRNb250aENsYXNzTmFtZXMgPSBmdW5jdGlvbiBfZ2V0TW9udGhDbGFzc05hbWVzKGRhdGUpIHtcblxuICAgIHZhciBjbHMgPSBbXTtcblxuICAgIC8vIERvIHdlIGhhdmUgYSB2YWx1ZSBpbiB0aGlzIG1vbnRoP1xuICAgIGlmIChkYXRlLmVxdWFsTW9udGgodGhpcy52YWx1ZXMpKSB7XG4gICAgICBjbHMucHVzaCgnaGFzLXZhbHVlJyk7XG4gICAgfVxuXG4gICAgLy8gRG9lcyB0aGlzIG1vbnRoIGhhdmUgdGhlIHN0YXJ0LCBtaWRkbGUgb3IgZW5kIG9mIGEgcmFuZ2U/XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2UgJiYgdGhpcy5lbHMubGVuZ3RoID4gMSkge1xuXG4gICAgICB2YXIgc3RhcnQgPSBkYXRlLmVxdWFsTW9udGgodGhpcy52YWx1ZXNbMF0pO1xuICAgICAgdmFyIGVuZCA9IGRhdGUuZXF1YWxNb250aCh0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXSk7XG4gICAgICB2YXIgbWlkZGxlID0gZGF0ZS5lcXVhbE1vbnRoKHRoaXMudmFsdWVzLnNsaWNlKDEsIC0xKSk7XG4gICAgICB2YXIgdmFsQmVmb3JlID0gZGF0ZS5hZnRlck1vbnRoKHRoaXMudmFsdWVzKTtcbiAgICAgIHZhciB2YWxBZnRlciA9IGRhdGUuYmVmb3JlTW9udGgodGhpcy52YWx1ZXMpO1xuICAgICAgdmFyIGFmdGVyRW5kID0gdGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV0gJiYgZGF0ZS5hZnRlcih0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBjbHMucHVzaCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgY2xzLnB1c2goJ3JhbmdlLWVuZCcpO1xuICAgICAgfVxuICAgICAgaWYgKG1pZGRsZSkge1xuICAgICAgICBjbHMucHVzaCgncmFuZ2UtbWlkZGxlJyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsQmVmb3JlKSB7XG4gICAgICAgIGNscy5wdXNoKCd2YWx1ZS1iZWZvcmUnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxBZnRlcikge1xuICAgICAgICBjbHMucHVzaCgndmFsdWUtYWZ0ZXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZnRlckVuZCkge1xuICAgICAgICBjbHMucHVzaCgnYWZ0ZXItcmFuZ2UtZW5kJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNscy5qb2luKCcgJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY2FsZW5kYXIuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY3JlYXRlQ2FsZW5kYXIgPSBmdW5jdGlvbiBfY3JlYXRlQ2FsZW5kYXIoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsICdzcGFyay1jYWxlbmRhcicpO1xuICAgIGVsLmlubmVySFRNTCA9ICc8bmF2IGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX25hdlwiPjxidXR0b24gY2xhc3M9XCJzcGFyay1jYWxlbmRhcl9fcHJldmlvdXMgc3BhcmstaWNvbi1jaGV2cm9uLWxlZnRcIiB0aXRsZT1cIlByZXZpb3VzXCI+PC9idXR0b24+PGJ1dHRvbiBjbGFzcz1cInNwYXJrLWNhbGVuZGFyX19uZXh0IHNwYXJrLWljb24tY2hldnJvbi1yaWdodFwiIHRpdGxlPVwiTmV4dFwiPjwvYnV0dG9uPjwvbmF2PjxkaXYgY2xhc3M9XCJzcGFyay1jYWxlbmRhcl9fb3ZlcmZsb3dcIj48ZGl2IGNsYXNzPVwic3BhcmstY2FsZW5kYXJfX2NvbnRlbnRcIj48L2Rpdj48L2Rpdj4nO1xuICAgIHRoaXMuY2FsZW5kYXJFbCA9IGVsO1xuICAgIHRoaXMuY2FsZW5kYXJDb250ZW50RWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstY2FsZW5kYXJfX2NvbnRlbnQnKTtcbiAgICB0aGlzLmNhbGVuZGFyT3ZlcmZsb3dFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYWxlbmRhcl9vdmVyZmxvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHBvcG92ZXIuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY3JlYXRlUG9wb3ZlciA9IGZ1bmN0aW9uIF9jcmVhdGVQb3BvdmVyKCkge1xuXG4gICAgdGhpcy5wb3BvdmVyID0gbmV3IF9wb3BvdmVyMi5kZWZhdWx0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCB7XG4gICAgICBhbmNob3JYOiAnY2VudGVyJyxcbiAgICAgIGFuY2hvclk6ICdib3R0b20nLFxuICAgICAgY29udGVudEVsOiB0aGlzLmNhbGVuZGFyRWwsXG4gICAgICBvbkNsb3NlOiB0aGlzLl9vblBvcG92ZXJDbG9zZS5iaW5kKHRoaXMpLFxuICAgICAgb25PcGVuOiB0aGlzLl9vblBvcG92ZXJPcGVuLmJpbmQodGhpcylcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FjaGUgZWxlbWVudHMuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY2FjaGVFbGVtZW50cyA9IGZ1bmN0aW9uIF9jYWNoZUVsZW1lbnRzKCkge1xuXG4gICAgdGhpcy5pbnB1dEVscyA9IFtdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmVscy5sZW5ndGg7XG4gICAgdmFyIGlucHV0ID0gdm9pZCAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaW5wdXQgPSB0aGlzLmVsc1tpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnID8gdGhpcy5lbHNbaV0gOiB0aGlzLmVsc1tpXS5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiZGF0ZVwiXScpO1xuICAgICAgdGhpcy5pbnB1dEVsc1tpXSA9IGlucHV0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FjaGUgZWxlbWVudHMgc3BlY2lmaWMgdG8gdGhlIGNhbGVuZGFyLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NhY2hlQ2FsZW5kYXJFbGVtZW50cyA9IGZ1bmN0aW9uIF9jYWNoZUNhbGVuZGFyRWxlbWVudHMoKSB7XG4gICAgdGhpcy5uZXh0QnV0dG9uRWwgPSB0aGlzLmNhbGVuZGFyRWwucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhbGVuZGFyX19uZXh0Jyk7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbkVsID0gdGhpcy5jYWxlbmRhckVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYWxlbmRhcl9fcHJldmlvdXMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgcGFyYW1ldGVycyBmcm9tIHRoZSBlbGVtZW50cy5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIF9wYXJzZVBhcmFtcygpIHtcblxuICAgIHRoaXMuX3BhcnNlSW5wdXRFbHNQYXJhbXMoKTtcblxuICAgIHRoaXMuX2lzUmFuZ2UgPSB0aGlzLmVscy5sZW5ndGggPiAxID8gdHJ1ZSA6IGZhbHNlO1xuICAgIHRoaXMuYXV0b0FkdmFuY2UgPSB0aGlzLmF1dG9BZHZhbmNlICE9PSBudWxsID8gdGhpcy5hdXRvQWR2YW5jZSA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUuYm9vbGVhbikodGhpcy5lbHNbMF0sICdkYXRhLWF1dG8tYWR2YW5jZScsIHRydWUpO1xuICAgIHRoaXMuYXV0b0Nsb3NlID0gdGhpcy5hdXRvQ2xvc2UgIT09IG51bGwgPyB0aGlzLmF1dG9DbG9zZSA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUuYm9vbGVhbikodGhpcy5lbHNbMF0sICdkYXRhLWF1dG8tY2xvc2UnLCB0cnVlKTtcbiAgICB0aGlzLmNsb3NlRGVsYXkgPSB0aGlzLmNsb3NlRGVsYXkgIT09IG51bGwgPyB0aGlzLmNsb3NlRGVsYXkgOiAoMCwgX3BhcnNlQXR0cmlidXRlLm51bWJlcikodGhpcy5lbHNbMF0sICdkYXRhLWNsb3NlLWRlbGF5JywgNTAwKTtcbiAgICB0aGlzLnF1aWNrSnVtcCA9IHRoaXMucXVpY2tKdW1wICE9PSBudWxsID8gdGhpcy5xdWlja0p1bXAgOiAoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKHRoaXMuZWxzWzBdLCAnZGF0YS1xdWljay1qdW1wJywgZmFsc2UpO1xuICAgIHRoaXMudmlld1JhbmdlID0gdGhpcy52aWV3UmFuZ2UgIT09IG51bGwgPyB0aGlzLnZpZXdSYW5nZSA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUuc3RyaW5nKSh0aGlzLmVsc1swXSwgJ2RhdGEtdmlldy1yYW5nZScsICdtb250aCcpO1xuICAgIHRoaXMuYW5pbWF0ZSA9IHRoaXMuYW5pbWF0ZSAhPT0gbnVsbCA/IHRoaXMuYW5pbWF0ZSA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUuYm9vbGVhbikodGhpcy5lbHNbMF0sICdkYXRhLWFuaW1hdGUnLCB0cnVlKTtcbiAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uID0gdGhpcy5hbmltYXRpb25EdXJhdGlvbiAhPT0gbnVsbCA/IHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gOiAoMCwgX3BhcnNlQXR0cmlidXRlLm51bWJlcikodGhpcy5lbHNbMF0sICdkYXRhLWFuaW1hdGlvbi1kdXJhdGlvbicsIDEwMCk7XG4gICAgdGhpcy5zaG93T25Gb2N1cyA9IHRoaXMuc2hvd09uRm9jdXMgIT09IG51bGwgPyB0aGlzLnNob3dPbkZvY3VzIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5ib29sZWFuKSh0aGlzLmVsc1swXSwgJ2RhdGEtc2hvdy1vbi1mb2N1cycsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1pbiwgbWF4LCB2YWx1ZSBhbmQgdmlzaWJsZSBjb3VudHMgZnJvbSB0aGUgZWxlbWVudHMgaWYgd2UgY2FuLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9wYXJzZUlucHV0RWxzUGFyYW1zID0gZnVuY3Rpb24gX3BhcnNlSW5wdXRFbHNQYXJhbXMoKSB7XG5cbiAgICB2YXIgZWxzID0gdGhpcy5pbnB1dEVscztcblxuICAgIGlmICghZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBlbHMubGVuZ3RoO1xuICAgIHZhciBtaW5zID0gW107XG4gICAgdmFyIG1heGVzID0gW107XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciB2aXNpYmxlQ291bnRzID0gW107XG4gICAgdmFyIGRpc2FibGVkcyA9IFtdO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICBpZiAoIWVsc1tpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWlucyAmJiB0aGlzLm1pbnNbaV0pIG1pbnNbaV0gPSBfdHlwZW9mKHRoaXMubWluc1tpXSkgPT09ICdvYmplY3QnID8gdGhpcy5taW5zW2ldIDogcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyh0aGlzLm1pbnNbaV0pO2Vsc2UgaWYgKGVsc1tpXS5nZXRBdHRyaWJ1dGUoJ21pbicpKSBtaW5zW2ldID0gcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyhlbHNbaV0uZ2V0QXR0cmlidXRlKCdtaW4nKSk7XG5cbiAgICAgIGlmICh0aGlzLm1heGVzICYmIHRoaXMubWF4ZXNbaV0pIG1heGVzW2ldID0gX3R5cGVvZih0aGlzLm1heGVzW2ldKSA9PT0gJ29iamVjdCcgPyB0aGlzLm1heGVzW2ldIDogcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyh0aGlzLm1heGVzW2ldKTtlbHNlIGlmIChlbHNbaV0uZ2V0QXR0cmlidXRlKCdtYXgnKSkgbWF4ZXNbaV0gPSBwYXJzZWREb21Gb3JtYXQuZ2V0VmFsdWVzKGVsc1tpXS5nZXRBdHRyaWJ1dGUoJ21heCcpKTtcblxuICAgICAgaWYgKHRoaXMudmFsdWVzICYmIHRoaXMudmFsdWVzW2ldKSB2YWx1ZXNbaV0gPSBfdHlwZW9mKHRoaXMudmFsdWVzW2ldKSA9PT0gJ29iamVjdCcgPyB0aGlzLnZhbHVlc1tpXSA6IHBhcnNlZERvbUZvcm1hdC5nZXRWYWx1ZXModGhpcy52YWx1ZXNbaV0pO2Vsc2UgaWYgKGVsc1tpXS52YWx1ZSkgdmFsdWVzW2ldID0gcGFyc2VkRG9tRm9ybWF0LmdldFZhbHVlcyhlbHNbaV0udmFsdWUpO1xuXG4gICAgICBkaXNhYmxlZHNbaV0gPSAoMCwgX3BhcnNlQXR0cmlidXRlLmJvb2xlYW4pKGVsc1tpXSwgJ2Rpc2FibGVkJywgZmFsc2UpO1xuXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZUNvdW50cykgdmlzaWJsZUNvdW50c1tpXSA9IHBhcnNlSW50KGVsc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmlzaWJsZS1jb3VudCcpLCAxMCkgfHwgMTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbnMgPSBtaW5zO1xuICAgIHRoaXMubWluVmlzaWJsZSA9IF9kYXRlMi5kZWZhdWx0LmVhcmxpZXN0KG1pbnMpO1xuICAgIHRoaXMubWF4ZXMgPSBtYXhlcztcbiAgICB0aGlzLm1heFZpc2libGUgPSBfZGF0ZTIuZGVmYXVsdC5sYXRlc3QobWF4ZXMpO1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIHRoaXMuX2lzRGlzYWJsZWQgPSBkaXNhYmxlZHM7XG4gICAgaWYgKHZpc2libGVDb3VudHMubGVuZ3RoKSB0aGlzLnZpc2libGVDb3VudHMgPSB2aXNpYmxlQ291bnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGVzIHdlIHNob3VsZCBiZSBzaG93aW5nLiBTdGFydCB3aXRoIHRoZSBmaXJzdCB2YWx1ZSBvciB0b2RheSdzIGRhdGUuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5faW5pdERhdGVzVG9TaG93ID0gZnVuY3Rpb24gX2luaXREYXRlc1RvU2hvdygpIHtcblxuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcblxuICAgIC8vIEdldCB0aGUgZGF0ZSBmb3IgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICBpZiAodGhpcy52YWx1ZXNbdGhpcy5hY3RpdmVJbmRleF0pIHtcbiAgICAgIGFyci5wdXNoKHRoaXMudmFsdWVzW3RoaXMuYWN0aXZlSW5kZXhdLmNsb25lKCkpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZmlyc3QgZGF0ZVxuICAgIGZvciAoOyBpIDwgbGVuICYmICFhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlc1tpXSkge1xuICAgICAgICBhcnIucHVzaCh0aGlzLnZhbHVlc1tpXS5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGEgZGF0ZSwgdXNlIHRoZSBtaW5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLm1pbnMubGVuZ3RoOyBpIDwgbGVuICYmICFhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm1pbnNbaV0pIHtcbiAgICAgICAgYXJyLnB1c2godGhpcy5taW5zW2ldLmNsb25lKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIHN0aWxsIGRpZG4ndCBnZXQgYSBkYXRlLCBhZGQgdG9kYXkncyBkYXRlLlxuICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgYXJyLnB1c2goX2RhdGUyLmRlZmF1bHQubm93KCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGVzVG9TaG93ID0gYXJyO1xuXG4gICAgdGhpcy5fc2V0RGF0ZXNUb1Nob3coKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBkYXRlcyB0byBzaG93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIE9wdGlvbmFsIFRoZSBkaXJlY3Rpb24gdG8gY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fc2V0RGF0ZXNUb1Nob3cgPSBmdW5jdGlvbiBfc2V0RGF0ZXNUb1Nob3coY2hhbmdlKSB7XG5cbiAgICB2YXIgYXJyID0gdGhpcy5fZGF0ZXNUb1Nob3c7XG4gICAgdmFyIHZpc2libGVDb3VudCA9IHRoaXMuX2N1cnJlbnRCcmVha3BvaW50ID09PSAneHMnIHx8IHRoaXMuX2N1cnJlbnRCcmVha3BvaW50ID09PSAnc20nID8gMSA6IHRoaXMudmlzaWJsZUNvdW50c1t0aGlzLmFjdGl2ZUluZGV4XSB8fCB0aGlzLnZpc2libGVDb3VudHNbMF0gfHwgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG5vdW4gPSB0aGlzLnZpZXdSYW5nZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRoaXMudmlld1JhbmdlLnNsaWNlKDEpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBtb3JlIGRhdGVzIHRvIHNob3cgdGhhbiB3ZSdyZSBzdXBwb3NlZCB0byBzaG93LCByZW1vdmUgdGhlIGV4Y2Vzcy5cbiAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiB2aXNpYmxlIGNvdW50IGNoYW5nZXMgYmV0d2VlbiByZW5kZXJzXG4gICAgaWYgKGFyci5sZW5ndGggPiB2aXNpYmxlQ291bnQpIHtcbiAgICAgIGFyci5zcGxpY2UodmlzaWJsZUNvdW50KTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyB0aGUgc3RhcnRpbmcgbW9udGhcbiAgICBpZiAoY2hhbmdlKSB7XG5cbiAgICAgIC8vIEVtcHR5IHRoZSByZXN0IG9mIHRoZSBkYXRlcyBmcm9tIHRoZSBhcnJheVxuICAgICAgYXJyID0gdGhpcy5fZGF0ZXNUb1Nob3cgPSBhcnIuc3BsaWNlKDAsIDEpO1xuXG4gICAgICAvLyBEZWNyZW1lbnRcbiAgICAgIGlmIChjaGFuZ2UgPCAwKSB7XG4gICAgICAgIGZvciAoOyBpID4gY2hhbmdlOyBpLS0pIHtcbiAgICAgICAgICBhcnJbMF0gPSBhcnJbMF1bJ3ByZXZpb3VzJyArIG5vdW5dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IGNoYW5nZTsgaSsrKSB7XG4gICAgICAgICAgYXJyWzBdID0gYXJyWzBdWyduZXh0JyArIG5vdW5dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYm91bmRzXG4gICAgdGhpcy5fYXRNaW4gPSB0aGlzLl9jaGVja01pbkRhdGVWaXNpYmxlKG5vdW4sIGFycik7XG4gICAgdGhpcy5fYXRNYXggPSB0aGlzLl9jaGVja01heERhdGVWaXNpYmxlKG5vdW4sIGFycik7XG5cbiAgICB2YXIgYWRkRGF0ZSA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdFNlbGVjdGVkID0gdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSB2b2lkIDA7XG4gICAgaSA9IDA7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBkYXRlc1xuICAgIHdoaWxlIChhcnIubGVuZ3RoIDwgdmlzaWJsZUNvdW50KSB7XG5cbiAgICAgIC8vIElmIGF0IHRoZSBtYXgsIHByZXBlbmRcbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBsYXN0IGlucHV0IGFuZCBpdCBoYXMgYSB2YWx1ZSBhbmQgaXQncyBhIGRpZmZlcmVudCBtb250aCB0aGFuIHRoZSBmaXJzdCB2YWx1ZSwgcHJlcGVuZFxuICAgICAgLy8gSWYgYXQgdGhlIG1pbiwgYXBwZW5kXG4gICAgICAvLyBJZiBhbiBpdGVtIHdlJ3JlIGFkZGluZyBpcyBiZWZvcmUgdGhlIG1pbiwgZGlzY2FyZCBpdCBhbmQgYXBwZW5kIGFuIGl0ZW0gYWZ0ZXIgdGhlIGxhc3QgaW4gdGhlIGFyclxuICAgICAgLy8gSWYgYW4gaXRlbSB3ZSdyZSBhZGRpbmcgaXMgYWZ0ZXIgdGhlIG1heCwgZGlzY2FyZCBpdCBhbmQgcHJlcGVuZCBhbiBpdGVtIGJlZm9yZSB0aGUgZmlyc3QgaW4gdGhlIGFyclxuXG4gICAgICBsYXN0U2VsZWN0ZWQgPSAhY2hhbmdlICYmIHRoaXMuYWN0aXZlSW5kZXggPT09IHRoaXMudmFsdWVzLmxlbmd0aCAtIDEgJiYgdGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV0gJiYgdGhpcy52YWx1ZXNbMF0gJiYgIXRoaXMudmFsdWVzW3RoaXMudmFsdWVzLmxlbmd0aCAtIDFdWydlcXVhbCcgKyBub3VuXSh0aGlzLnZhbHVlcywgdHJ1ZSk7XG5cbiAgICAgIC8vIElmIHdlJ3JlIHNob3dpbmcgdGhlIG1heCBkYXRlIG9yIHdlIGhhdmUgdGhlIGxhc3QgaW5wdXQgc2VsZWN0ZWQgYW5kIGl0IGhhcyBhIHZhbHVlLCBhZGQgZGF0ZXMgYmVmb3JlLlxuICAgICAgaWYgKHRoaXMuX2F0TWF4IHx8IGxhc3RTZWxlY3RlZCkge1xuXG4gICAgICAgIGFkZERhdGUgPSBhcnJbaV1bJ3ByZXZpb3VzJyArIG5vdW5dO1xuICAgICAgICBhY3Rpb24gPSAndW5zaGlmdCc7XG5cbiAgICAgICAgaWYgKGFkZERhdGVbJ2JlZm9yZScgKyBub3VuXSh0aGlzLm1pblZpc2libGUpKSB7XG4gICAgICAgICAgYWRkRGF0ZSA9IGFycltpXVsnbmV4dCcgKyBub3VuXTtcbiAgICAgICAgICBhY3Rpb24gPSAncHVzaCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYWRkRGF0ZSA9IGFycltpXVsnbmV4dCcgKyBub3VuXTtcbiAgICAgICAgYWN0aW9uID0gJ3B1c2gnO1xuXG4gICAgICAgIGlmIChhZGREYXRlWydhZnRlcicgKyBub3VuXSh0aGlzLm1heFZpc2libGUpKSB7XG4gICAgICAgICAgYWRkRGF0ZSA9IGFycltpXVsncHJldmlvdXMnICsgbm91bl07XG4gICAgICAgICAgYWN0aW9uID0gJ3Vuc2hpZnQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3Rpb24gPT09ICdwdXNoJykge1xuICAgICAgICBhcnIucHVzaChhZGREYXRlKTtcbiAgICAgICAgaSA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyLnVuc2hpZnQoYWRkRGF0ZSk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGJvdW5kcyBhZ2FpblxuICAgIHRoaXMuX2F0TWluID0gdGhpcy5fY2hlY2tNaW5EYXRlVmlzaWJsZShub3VuLCBhcnIpO1xuICAgIHRoaXMuX2F0TWF4ID0gdGhpcy5fY2hlY2tNYXhEYXRlVmlzaWJsZShub3VuLCBhcnIpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBuYXZpZ2F0aW9uIHRvIHJlZmxlY3QgdGhlIF9hdE1pbiBvciBfYXRNYXggc3RhdGVcbiAgICB0aGlzLl91cGRhdGVOYXYoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHRoZSBtaW4gdmFsdWUgaW4gYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWluXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBub3VuIFRoZSB0eXBlIG9mIGRhdGUgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY2hlY2tNaW5EYXRlVmlzaWJsZSA9IGZ1bmN0aW9uIF9jaGVja01pbkRhdGVWaXNpYmxlKG5vdW4sIGFycikge1xuXG4gICAgaWYgKCF0aGlzLm1pblZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWluID0gdGhpcy5taW5WaXNpYmxlO1xuXG4gICAgaWYgKG1pbiAmJiAoYXJyWzBdWydlcXVhbCcgKyBub3VuXShtaW4pIHx8IGFyclswXVsnYmVmb3JlJyArIG5vdW5dKG1pbikpKSB7XG4gICAgICBhcnJbMF0gPSBtaW47XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciB0aGUgbWF4IHZhbHVlIGluIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1heFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbm91biBUaGUgdHlwZSBvZiBkYXRlIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NoZWNrTWF4RGF0ZVZpc2libGUgPSBmdW5jdGlvbiBfY2hlY2tNYXhEYXRlVmlzaWJsZShub3VuLCBhcnIpIHtcblxuICAgIGlmICghdGhpcy5tYXhWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1heCA9IHRoaXMubWF4VmlzaWJsZTtcblxuICAgIGlmIChtYXggJiYgYXJyW2Fyci5sZW5ndGggLSAxXSAmJiAoYXJyW2Fyci5sZW5ndGggLSAxXVsnZXF1YWwnICsgbm91bl0obWF4KSB8fCBhcnJbYXJyLmxlbmd0aCAtIDFdWydhZnRlcicgKyBub3VuXShtYXgpKSkge1xuICAgICAgYXJyW2Fyci5sZW5ndGggLSAxXSA9IG1heDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdGhhdCB0aGUgdmFsdWVzIGFyZSBpbiBib3VuZHMgYW5kLCBvcHRpbm9hbGx5LCBpbiBzZXF1ZW50aWFsIG9yZGVyLlxuICAgKiBJZiBjaGVja2luZyBmb3Igc2VxdWVuY2UsIHJlbW92ZSB0aG9zZSB3aGljaCBhcmVuJ3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZXRJbmRleCBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIG1vc3QgcmVjZW50bHkgc2V0LiBUaGlzIHNob3VsZG4ndCBiZSByZW1vdmVkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBEaWQgYW55IHZhbHVlcyBjaGFuZ2U/XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY2hlY2tWYWx1ZXMgPSBmdW5jdGlvbiBfY2hlY2tWYWx1ZXMoc2V0SW5kZXgsIHNraXBSYW5nZUNoZWNrKSB7XG5cbiAgICAvLyBDaGVjayBib3VuZGFyaWVzXG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLl9jaGVja01pbk1heFZhbHVlcygpO1xuXG4gICAgLy8gU2VxdWVudGlhbCByYW5nZSBpdGVtcyBjaGVja1xuICAgIGlmICh0aGlzLl9pc1JhbmdlICYmICFza2lwUmFuZ2VDaGVjaykge1xuXG4gICAgICB2YXIgaSA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXNbaV0gJiYgdGhpcy52YWx1ZXNbaSAtIDFdICYmIHRoaXMudmFsdWVzW2ldLmJlZm9yZURheSh0aGlzLnZhbHVlc1tpIC0gMV0sIHRydWUpKSB7XG4gICAgICAgICAgaWYgKGkgPT09IHNldEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKG51bGwsIGkgLSAxLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShudWxsLCBpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgbWluaW11bS9tYXhpbXVtIHZhbHVlcy5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9jaGVja01pbk1heFZhbHVlcyA9IGZ1bmN0aW9uIF9jaGVja01pbk1heFZhbHVlcygpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5tYXhlcyAmJiB0aGlzLm1heGVzW2ldICYmIHRoaXMudmFsdWVzW2ldICYmIHRoaXMudmFsdWVzW2ldLmFmdGVyKHRoaXMubWF4ZXNbaV0sIHRydWUpKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2ldID0gdGhpcy5tYXhlc1tpXS5jbG9uZSgpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5taW5zICYmIHRoaXMubWluc1tpXSAmJiB0aGlzLnZhbHVlc1tpXSAmJiB0aGlzLnZhbHVlc1tpXS5iZWZvcmUodGhpcy5taW5zW2ldLCB0cnVlKSkge1xuICAgICAgICB0aGlzLnZhbHVlc1tpXSA9IHRoaXMubWluc1tpXS5jbG9uZSgpO1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhbmltYXRpb25zIHRvIGJlIHJ1bi4gKE5vdCByZWFsbHkgYW5pbWF0aW9ucyBzaW5jZSB0aG9zZSBoYXBwZW4gdy8gQ1NTLiBNb3JlXG4gICAqIG9mIGEgbWFuYWdlciBvZiB0aW1lb3V0cykuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2FuaW1hdGVDb250ZW50ID0gZnVuY3Rpb24gX2FuaW1hdGVDb250ZW50KGNiLCBkdXJhdGlvbikge1xuICAgIHRoaXMuX2FuaW1hdGlvblF1ZXVlID0gdGhpcy5fYW5pbWF0aW9uUXVldWUgfHwgW107XG4gICAgdGhpcy5fYW5pbWF0aW9uUXVldWUucHVzaCh7XG4gICAgICBjYjogY2IsXG4gICAgICBkOiBkdXJhdGlvblxuICAgIH0pO1xuICAgIHRoaXMuX3J1bkFuaW1hdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSdW4gdGhlIGZpcnN0IHF1ZXVlZCBhbmltYXRpb24uIFdoZW4gY29tcGxldGUsIHJ1biB0aGUgbmV4dCBhbmltYXRpb24uXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fcnVuQW5pbWF0aW9uID0gZnVuY3Rpb24gX3J1bkFuaW1hdGlvbigpIHtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0aW9uVGltZXIpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzLl9hbmltYXRpb25RdWV1ZS5zaGlmdCgpO1xuXG4gICAgICBpZiAoYSkge1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5jYi5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9ydW5BbmltYXRpb24oKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBhLmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGF0dHJpYnV0ZXMgb24gdGhlIGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3VwZGF0ZUF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5jYWxlbmRhckVsLnNldEF0dHJpYnV0ZSgnZGF0YS12aXNpYmxlLWNvdW50JywgdGhpcy5fY3VycmVudEJyZWFrcG9pbnQgPT09ICd4cycgPyAxIDogdGhpcy52aXNpYmxlQ291bnRzW3RoaXMuYWN0aXZlSW5kZXhdIHx8IHRoaXMudmlzaWJsZUNvdW50c1swXSB8fCAxKTtcbiAgICB0aGlzLl91cGRhdGVOYXYoKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBuYXZpZ2F0aW9uIHRvIHJlZmxlY3QgdGhlIGFiaWxpdHkgdG8gbW92ZSBmb3J3YXJkIGFuZCBiYWNrd2FyZC5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl91cGRhdGVOYXYgPSBmdW5jdGlvbiBfdXBkYXRlTmF2KCkge1xuXG4gICAgaWYgKHRoaXMucHJldmlvdXNCdXR0b25FbCkge1xuICAgICAgaWYgKHRoaXMuX2F0TWluKSB0aGlzLnByZXZpb3VzQnV0dG9uRWwuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO2Vsc2UgdGhpcy5wcmV2aW91c0J1dHRvbkVsLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZXh0QnV0dG9uRWwpIHtcbiAgICAgIGlmICh0aGlzLl9hdE1heCkgdGhpcy5uZXh0QnV0dG9uRWwuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO2Vsc2UgdGhpcy5uZXh0QnV0dG9uRWwucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGJvdW5kIHZlcnNpb25zIG9mIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcyBhbmQgc3RvcmUgdGhlbS5cbiAgICogT3RoZXJ3aXNlIHdlIGNhbid0IHVuYmluZCBmcm9tIHRoZXNlIGV2ZW50cyBsYXRlciBiZWNhdXNlIHRoZVxuICAgKiBmdW5jdGlvbiBzaWduYXR1cmVzIHdvbid0IG1hdGNoLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCkge1xuXG4gICAgdGhpcy5fb25JbnB1dENoYW5nZUJvdW5kID0gdGhpcy5fb25JbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2VsZWN0Q2hhbmdlQm91bmQgPSB0aGlzLl9vblNlbGVjdENoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSW5wdXRGb2N1c0JvdW5kID0gdGhpcy5fb25JbnB1dEZvY3VzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DbGlja0JvdW5kID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ2FsZW5kYXJDbGlja0JvdW5kID0gdGhpcy5fb25DYWxlbmRhckNsaWNrLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdmVyQm91bmQgPSB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DYWxlbmRhck1vdXNlT3V0Qm91bmQgPSB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdXQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX29uUmVzaXplQm91bmQgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXJzIGZvciBET00gZXZlbnRzLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmVscy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmVsc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgICB0aGlzLmlucHV0RWxzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uSW5wdXRDaGFuZ2VCb3VuZCk7XG4gICAgICB0aGlzLmlucHV0RWxzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25JbnB1dEZvY3VzQm91bmQpO1xuICAgIH1cblxuICAgIHRoaXMuY2FsZW5kYXJFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdmVyQm91bmQpO1xuICAgIHRoaXMuY2FsZW5kYXJFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uQ2FsZW5kYXJNb3VzZU91dEJvdW5kKTtcbiAgICB0aGlzLmNhbGVuZGFyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNhbGVuZGFyQ2xpY2tCb3VuZCk7XG5cbiAgICB0aGlzLmNhbGVuZGFyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25TZWxlY3RDaGFuZ2VCb3VuZCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIERPTSBldmVudHMuLlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmVscy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmVsc1tpXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgICB0aGlzLmlucHV0RWxzW2ldLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uSW5wdXRDaGFuZ2VCb3VuZCk7XG4gICAgICB0aGlzLmlucHV0RWxzW2ldLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25JbnB1dEZvY3VzQm91bmQpO1xuICAgIH1cblxuICAgIHRoaXMuY2FsZW5kYXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdmVyQm91bmQpO1xuICAgIHRoaXMuY2FsZW5kYXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uQ2FsZW5kYXJNb3VzZU91dEJvdW5kKTtcbiAgICB0aGlzLmNhbGVuZGFyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNhbGVuZGFyQ2xpY2tCb3VuZCk7XG5cbiAgICB0aGlzLmNhbGVuZGFyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25TZWxlY3RDaGFuZ2VCb3VuZCk7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvY3VzIG9uIHRoZSBuZXh0IGlucHV0IGlmIHRoZXJlIGlzIG9uZS5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9mb2N1c05leHQgPSBmdW5jdGlvbiBfZm9jdXNOZXh0KCkge1xuXG4gICAgdmFyIGluZGV4ID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbnVsbCB2YWx1ZXMsIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIGlmICgoaW5kZXggPSB0aGlzLnZhbHVlcy5pbmRleE9mKG51bGwpKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA8IHRoaXMuZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMub3Blbih0aGlzLmFjdGl2ZUluZGV4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbihpbmRleCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZSBpZiB3ZSdyZSBvbiB0aGUgbGFzdCBpbnB1dCBhbmQgd2UgaGF2ZSB2YWx1ZXMuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fY2xvc2VPbkxhc3QgPSBmdW5jdGlvbiBfY2xvc2VPbkxhc3QoKSB7XG4gICAgaWYgKHRoaXMudmFsdWVzLmluZGV4T2YobnVsbCkgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsb3NlKHtcbiAgICAgICAgZGVsYXk6IHRoaXMuY2xvc2VEZWxheVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIHRoZSB0b2dnbGUgaWNvbiBhIGZpbGwgaWNvbi5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9maWxsVG9nZ2xlID0gZnVuY3Rpb24gX2ZpbGxUb2dnbGUoKSB7XG5cbiAgICB2YXIgdG9nZ2xlID0gdm9pZCAwO1xuXG4gICAgaWYgKHRoaXMuZWxzW3RoaXMuYWN0aXZlSW5kZXhdICYmICh0b2dnbGUgPSB0aGlzLmVsc1t0aGlzLmFjdGl2ZUluZGV4XS5xdWVyeVNlbGVjdG9yKCcuc3BhcmstZGF0ZV9fY2FsZW5kYXItdG9nZ2xlIFtjbGFzcyo9XCJzcGFyay1pY29uXCJdJykpKSB7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0b2dnbGUsICdzcGFyay1pY29uLS1maWxsJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIHRoZSB0b2dnbGUgaWNvbiBhIGxpbmUgaWNvbi5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl91bmZpbGxUb2dnbGUgPSBmdW5jdGlvbiBfdW5maWxsVG9nZ2xlKCkge1xuXG4gICAgdmFyIHRvZ2dsZSA9IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLmVsc1t0aGlzLmFjdGl2ZUluZGV4XSAmJiAodG9nZ2xlID0gdGhpcy5lbHNbdGhpcy5hY3RpdmVJbmRleF0ucXVlcnlTZWxlY3RvcignLnNwYXJrLWRhdGVfX2NhbGVuZGFyLXRvZ2dsZSBbY2xhc3MqPVwic3BhcmstaWNvblwiXScpKSkge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodG9nZ2xlLCAnc3BhcmstaWNvbi0tZmlsbCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxlbmRhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fYWN0aXZhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2FjdGl2YXRlRWxlbWVudChpbmRleCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxzW2luZGV4XTtcbiAgICBpZiAoZWwpICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGVsLCAnYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxlbmRhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fZGVhY3RpdmF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfZGVhY3RpdmF0ZUVsZW1lbnQoaW5kZXgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsc1tpbmRleF07XG4gICAgaWYgKGVsICYmICF0aGlzLnZhbHVlc1tpbmRleF0gJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGVsLCAnZm9jdXMnKSAmJiAhKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkoZWwsICdoYXMtcGFydGlhbC12YWx1ZScpKSB7XG4gICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgJ2FjdGl2ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdGhlIHNpemUgb2YgdGhlIHBvcG92ZXIgYW5kIHNlZSBpZiB3ZSBzaG91bGQgYmUgc2hvd2luZyB0aGUgWFMgdHJlYXRtZW50LlxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX2NoZWNrU2l6ZSA9IGZ1bmN0aW9uIF9jaGVja1NpemUoKSB7XG5cbiAgICB2YXIgYnAgPSAoMCwgX2JyZWFrcG9pbnQuZ2V0KSh3aW5kb3cub3V0ZXJXaWR0aCk7XG5cbiAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgYnJlYWtwb2ludCBoYXNuJ3QgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5fY3VycmVudEJyZWFrcG9pbnQgPT09IGJwKSByZXR1cm47XG5cbiAgICAvLyBTdG9yZSB0aGUgYnJlYWtwb2ludFxuICAgIHRoaXMuX2N1cnJlbnRCcmVha3BvaW50ID0gYnA7XG5cbiAgICAvLyBSZS1yZW5kZXIgdGhlIGRhdGUgcmFuZ2VcbiAgICB0aGlzLl9zZXREYXRlc1RvU2hvdygpO1xuICAgIHRoaXMucmVuZGVyKHRydWUpO1xuICAgIHRoaXMucG9wb3Zlci51cGRhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2Nyb2xsIHRoZSBhY3RpdmUgaW5wdXQgZWxlbWVudCBpbnRvIHZpZXcuXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fc2Nyb2xsVG9JbnB1dCA9IGZ1bmN0aW9uIF9zY3JvbGxUb0lucHV0KCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWxzW3RoaXMuYWN0aXZlSW5kZXhdO1xuICAgIGlmIChlbCkgKDAsIF9zY3JvbGxUbzIuZGVmYXVsdCkoZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGhvdmVyIGNsYXNzZXMuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaG92ZXJTdGFydHNcbiAgICogQHBhcmFtIHtFbGVtZW50fSBob3ZlckVuZHNcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl91cGRhdGVIb3ZlckNsYXNzZXMgPSBmdW5jdGlvbiBfdXBkYXRlSG92ZXJDbGFzc2VzKGhvdmVyU3RhcnRzLCBob3ZlckVuZHMpIHtcblxuICAgIHRoaXMuX2hvdmVyU3RhcnRzID0gdGhpcy5faG92ZXJTdGFydHMgfHwgW107XG4gICAgdGhpcy5faG92ZXJFbmRzID0gdGhpcy5faG92ZXJFbmRzIHx8IFtdO1xuXG4gICAgaG92ZXJTdGFydHMgPSBob3ZlclN0YXJ0cyBpbnN0YW5jZW9mIEFycmF5ID8gaG92ZXJTdGFydHMgOiBob3ZlclN0YXJ0cyA/IFtob3ZlclN0YXJ0c10gOiBbXTtcbiAgICBob3ZlckVuZHMgPSBob3ZlckVuZHMgaW5zdGFuY2VvZiBBcnJheSA/IGhvdmVyRW5kcyA6IGhvdmVyRW5kcyA/IFtob3ZlckVuZHNdIDogW107XG5cbiAgICB2YXIgYWxsU3RhcnRzID0gW107XG4gICAgdmFyIGN1clN0YXJ0cyA9IFtdO1xuICAgIHZhciBuZXdTdGFydHMgPSBbXTtcbiAgICB2YXIgYWxsRW5kcyA9IFtdO1xuICAgIHZhciBjdXJFbmRzID0gW107XG4gICAgdmFyIG5ld0VuZHMgPSBbXTtcblxuICAgIGhvdmVyU3RhcnRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2hvdmVyU3RhcnRzLmluZGV4T2YoZWwpO1xuXG4gICAgICAvLyBBbHJlYWR5IGhvdmVyZWQuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGN1clN0YXJ0cy5wdXNoKGVsKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdCBhbHJlYWR5IGhvdmVyZWQuIFJlYWR5IHRvIGFkZCB0aGUgY2xhc3MuXG4gICAgICBlbHNlIGlmIChlbCkge1xuICAgICAgICAgIG5ld1N0YXJ0cy5wdXNoKGVsKTtcbiAgICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShlbCwgJ2hvdmVyLXN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGFsbFN0YXJ0cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgY3VyU3RhcnRzLCBuZXdTdGFydHMpO1xuXG4gICAgdGhpcy5faG92ZXJTdGFydHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmIChhbGxTdGFydHMuaW5kZXhPZihlbCkgPT09IC0xKSB7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGVsLCAnaG92ZXItc3RhcnQnKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGhvdmVyRW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9ob3ZlckVuZHMuaW5kZXhPZihlbCk7XG5cbiAgICAgIC8vIEFscmVhZHkgaG92ZXJlZC5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY3VyRW5kcy5wdXNoKGVsKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vdCBhbHJlYWR5IGhvdmVyZWQuIFJlYWR5IHRvIGFkZCB0aGUgY2xhc3MuXG4gICAgICBlbHNlIGlmIChlbCkge1xuICAgICAgICAgIG5ld0VuZHMucHVzaChlbCk7XG4gICAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsICdob3Zlci1lbmQnKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgYWxsRW5kcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChbXSwgY3VyRW5kcywgbmV3RW5kcyk7XG5cbiAgICB0aGlzLl9ob3ZlckVuZHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmIChhbGxFbmRzLmluZGV4T2YoZWwpID09PSAtMSkge1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgJ2hvdmVyLWVuZCcpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5faG92ZXJTdGFydHMgPSBhbGxTdGFydHM7XG4gICAgdGhpcy5faG92ZXJFbmRzID0gYWxsRW5kcztcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBhbiBlbGVtZW50IGlzIGNsaWNrZWQsIGlmIHRoZSB0b2dnbGUgd2FzIHRoZSB0YXJnZXQsIG9wZW4gdGhlIHBvcG92ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uIF9vbkNsaWNrKGUpIHtcblxuICAgIGlmICgoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstZGF0ZV9fY2FsZW5kYXItdG9nZ2xlJywgdGhpcy5lbHMpKSB7XG5cbiAgICAgIHZhciBlbCA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1kYXRlJywgdGhpcy5lbHMpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5lbHMuaW5kZXhPZihlbCk7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gT3BlbiBvbiB0aGUgbmV4dCB0aWNrLiBPdGhlcndpc2Ugd2UgYWxzbyByZWNlaXZlIHRoZSB3aW5kb3cgY2xpY2sgY2xvc2UgZXZlbnQuXG4gICAgICB0aGlzLm9wZW4oaW5kZXgsIHtcbiAgICAgICAgZGVsYXk6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgY2FsZW5kYXIgaXMgaG92ZXJlZCwgZG8gc29tZSBoaWdobGlnaHRpbmcgaWYgd2UncmUgc2hvd2luZyBhIHJhbmdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX29uQ2FsZW5kYXJNb3VzZU92ZXIgPSBmdW5jdGlvbiBfb25DYWxlbmRhck1vdXNlT3ZlcihlKSB7XG4gICAgaWYgKHRoaXMudmlld1JhbmdlID09PSAnbW9udGgnKSB0aGlzLl9vbkNhbGVuZGFyTW91c2VPdmVyTW9udGhzKGUudGFyZ2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGhvdmVyIHN0YXRlcyBmb3IgZGF5cy5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25DYWxlbmRhck1vdXNlT3Zlck1vbnRocyA9IGZ1bmN0aW9uIF9vbkNhbGVuZGFyTW91c2VPdmVyTW9udGhzKHRhcmdldCkge1xuXG4gICAgaWYgKCF0aGlzLl9pc1JhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRheSA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KSh0YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX2RheScpO1xuXG4gICAgaWYgKCFkYXkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyQ2xhc3NlcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtb250aCA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KSh0YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX21vbnRoJyk7XG4gICAgdmFyIG1IYXNDbGFzcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkobW9udGgsIGMpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB2YXIgbmV3U3RhcnQgPSBbXTtcbiAgICB2YXIgbmV3RW5kID0gW107XG4gICAgdmFyIGRheVNlbCA9IHZvaWQgMDtcblxuICAgIC8vIE9ubHkgZG8gaGlnaGxpZ2h0cyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSB2YWx1ZSBmb3IgdGhpcyBpbmRleC5cbiAgICBpZiAoIXRoaXMudmFsdWVzW3RoaXMuYWN0aXZlSW5kZXhdKSB7XG5cbiAgICAgIC8vIEEgbW9udGggd2l0aCBhIHZhbHVlIGJlZm9yZSBpdCBidXQgbm8gdmFsdWUgb2YgaXRzIG93biwgaG92ZXIgc3RhcnRzXG4gICAgICAvLyBmcm9tIHRoZSBmaXJzdCBkYXkgdG8gdGhlIGhvdmVyZWQgZGF5LlxuICAgICAgaWYgKG1IYXNDbGFzcygndmFsdWUtYmVmb3JlJykgJiYgIW1IYXNDbGFzcygnYWZ0ZXItcmFuZ2UtZW5kJykgJiYgIW1IYXNDbGFzcygnaGFzLXZhbHVlJykgJiYgIW1IYXNDbGFzcygndmFsdWUtYWZ0ZXInKSkge1xuXG4gICAgICAgIG5ld1N0YXJ0LnB1c2gobW9udGgucXVlcnlTZWxlY3RvcignLnNwYXJrLWNhbGVuZGFyX19kYXk6bm90KC5zcGFyay1jYWxlbmRhcl9fZGF5LS1pbmFjdGl2ZSk6bm90KC5zcGFyay1jYWxlbmRhcl9fZGF5LS1kaXNhYmxlZCknKSk7XG4gICAgICAgIG5ld0VuZC5wdXNoKGRheSk7XG5cbiAgICAgICAgLy8gQWRkIGEgaG92ZXIgcmFuZ2UgdG8gYSBwcmV2aW91cyBtb250aC5cbiAgICAgICAgdmFyIHByZXZNb250aCA9IG1vbnRoO1xuICAgICAgICB3aGlsZSAoKHByZXZNb250aCA9ICgwLCBfZ2V0U2libGluZ0JlZm9yZTIuZGVmYXVsdCkocHJldk1vbnRoLCAnLnNwYXJrLWNhbGVuZGFyX19tb250aCcpKSAmJiAhKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkocHJldk1vbnRoLCAndmFsdWUtYWZ0ZXInKSAmJiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkocHJldk1vbnRoLCAnaGFzLXZhbHVlJykgfHwgKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkocHJldk1vbnRoLCAndmFsdWUtYmVmb3JlJykpKSB7XG5cbiAgICAgICAgICBkYXlTZWwgPSBwcmV2TW9udGgucXVlcnlTZWxlY3RvckFsbCgnLnNwYXJrLWNhbGVuZGFyX19kYXktLXNlbGVjdGVkJyk7XG4gICAgICAgICAgZGF5U2VsID0gZGF5U2VsW2RheVNlbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBkYXlTZWwgPSBkYXlTZWwgfHwgcHJldk1vbnRoLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1jYWxlbmRhcl9fZGF5Jyk7XG5cbiAgICAgICAgICBpZiAoZGF5U2VsKSB7XG4gICAgICAgICAgICBuZXdTdGFydC5wdXNoKGRheVNlbCk7XG4gICAgICAgICAgICBkYXlTZWwgPSBwcmV2TW9udGgucXVlcnlTZWxlY3RvckFsbCgnLnNwYXJrLWNhbGVuZGFyX19kYXknKTtcbiAgICAgICAgICAgIGRheVNlbCA9IGRheVNlbFtkYXlTZWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBuZXdFbmQucHVzaChkYXlTZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQSBtb250aCB3aXRoIGEgdmFsdWUsIGhpZ2hsaWdodCBlaXRoZXIgZnJvbSB0aGUgaG92ZXJlZCBkYXkgdG9cbiAgICAgIC8vIHRoZSBzZWxlY3Rpb24gb3IgZnJvbSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBkYXkuXG4gICAgICBlbHNlIGlmIChtSGFzQ2xhc3MoJ2hhcy12YWx1ZScpICYmICFtSGFzQ2xhc3MoJ3ZhbHVlLWJlZm9yZScpICYmICFtSGFzQ2xhc3MoJ3ZhbHVlLWFmdGVyJykgJiYgKChuZXdTdGFydCA9ICgwLCBfZ2V0U2libGluZ0JlZm9yZTIuZGVmYXVsdCkoZGF5LCAnLnNwYXJrLWNhbGVuZGFyX19kYXktLXNlbGVjdGVkJykpIHx8IChuZXdFbmQgPSAoMCwgX2dldFNpYmxpbmdBZnRlcjIuZGVmYXVsdCkoZGF5LCAnLnNwYXJrLWNhbGVuZGFyX19kYXktLXNlbGVjdGVkJykpKSkge1xuXG4gICAgICAgICAgaWYgKG5ld1N0YXJ0KSB7XG4gICAgICAgICAgICBuZXdTdGFydCA9IFtuZXdTdGFydF07XG4gICAgICAgICAgICBuZXdFbmQgPSBbZGF5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3RW5kID0gW25ld0VuZF07XG4gICAgICAgICAgICBuZXdTdGFydCA9IFtkYXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShuZXdFbmRbMF0sICdzcGFyay1jYWxlbmRhcl9fcmFuZ2Utc3RhcnQnKSB8fCAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShuZXdTdGFydFswXSwgJ3NwYXJrLWNhbGVuZGFyX19yYW5nZS1lbmQnKSkge1xuICAgICAgICAgICAgbmV3U3RhcnQgPSBbXTtcbiAgICAgICAgICAgIG5ld0VuZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBIG1vbnRoIHdpdGggYSBtaWRkbGUgcmFuZ2Ugc2hvdWxkIGhpZ2hsaWdodCBiZWZvcmVcbiAgICAgICAgZWxzZSBpZiAobUhhc0NsYXNzKCdoYXMtdmFsdWUnKSAmJiBtSGFzQ2xhc3MoJ3JhbmdlLW1pZGRsZScpICYmIG1IYXNDbGFzcygndmFsdWUtYmVmb3JlJykpIHtcbiAgICAgICAgICAgIGRheVNlbCA9ICgwLCBfZ2V0U2libGluZ0JlZm9yZTIuZGVmYXVsdCkoZGF5LCAnLnNwYXJrLWNhbGVuZGFyX19kYXktLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICBpZiAoZGF5U2VsKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXJ0ID0gW2RheVNlbF07XG4gICAgICAgICAgICAgIG5ld0VuZCA9IFtkYXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVIb3ZlckNsYXNzZXMobmV3U3RhcnQsIG5ld0VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNhbGVuZGFyIGlzIGhvdmVyZWQsIHVuZG8gc29tZSBoaWdobGlnaHRpbmcgaWYgd2UncmUgc2hvd2luZyBhIHJhbmdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIENhbGVuZGFyUG9wb3Zlci5wcm90b3R5cGUuX29uQ2FsZW5kYXJNb3VzZU91dCA9IGZ1bmN0aW9uIF9vbkNhbGVuZGFyTW91c2VPdXQoZSkge1xuICAgIGlmICh0aGlzLnZpZXdSYW5nZSA9PT0gJ21vbnRoJykgdGhpcy5fb25DYWxlbmRhck1vdXNlT3V0TW9udGhzKGUudGFyZ2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgaG92ZXIgc3RhdGVzIGZvciBkYXlzLlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSB0YXJnZXRcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vbkNhbGVuZGFyTW91c2VPdXRNb250aHMgPSBmdW5jdGlvbiBfb25DYWxlbmRhck1vdXNlT3V0TW9udGhzKHRhcmdldCkge1xuXG4gICAgdmFyIGRheSA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KSh0YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX2RheScpO1xuICAgIHZhciBkYXlzID0gKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKHRhcmdldCwgJy5zcGFyay1jYWxlbmRhcl9fZGF5cycpO1xuICAgIHZhciBtb250aCA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KSh0YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX21vbnRoJyk7XG5cbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShkYXksICdob3ZlcicpO1xuICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGRheXMsICdob3ZlcicpO1xuICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKG1vbnRoLCAnaG92ZXInKTtcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLmNhbGVuZGFyRWwsICdob3ZlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjYWxlbmRhciBpcyBjbGlja2VkLCBoYW5kbGUgbmF2aWdhdGlvbiBjbGlja3MgYW5kIGRhdGUgc2VsZWN0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vbkNhbGVuZGFyQ2xpY2sgPSBmdW5jdGlvbiBfb25DYWxlbmRhckNsaWNrKGUpIHtcblxuICAgIHZhciBuYXYgPSAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstY2FsZW5kYXJfX25hdicsIHRoaXMuY2FsZW5kYXJFbCk7XG4gICAgdmFyIGRheSA9IHZvaWQgMDtcbiAgICB2YXIgZGlyID0gdm9pZCAwO1xuXG4gICAgLy8gTmF2aWdhdGlvbiBjbGlja3NcbiAgICBpZiAobmF2KSB7XG5cbiAgICAgIC8vIFByZXZpb3VzXG4gICAgICBpZiAoKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19wcmV2aW91cycsIG5hdikpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cygpO1xuICAgICAgfVxuICAgICAgLy8gTmV4dFxuICAgICAgZWxzZSBpZiAoKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLWNhbGVuZGFyX19uZXh0JywgbmF2KSkge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERheSBjbGlja1xuICAgIGVsc2UgaWYgKGRheSA9ICgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1jYWxlbmRhcl9fZGF5JykpIHtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgLy8gRGlzYWJsZWQgZGF5IG1vdmVzIGNhbiBtb3ZlIHVzIHRvIHRoZSBuZXh0IG1vbnRoXG4gICAgICAgIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShkYXksICdzcGFyay1jYWxlbmRhcl9fZGF5LS1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgZGlyID0gZGF5LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXJlY3Rpb24nKTtcbiAgICAgICAgICBpZiAoZGlyID09PSAnbmV4dCcpIHRoaXMubmV4dCgpO2Vsc2UgaWYgKGRpciA9PT0gJ3ByZXZpb3VzJykgdGhpcy5wcmV2aW91cygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuYWJsZWQgZGF5IHNldHMgdGhlIHZhbHVlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShkYXkuZ2V0QXR0cmlidXRlKCdkYXRhLWRhdGUnKSwgdGhpcy5hY3RpdmVJbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQWR2YW5jZSkgdGhpcy5fZm9jdXNOZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHRoaXMuX2Nsb3NlT25MYXN0KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwb3BvdmVyIG9wZW5zLCBzZXQgdGhlIHRvZ2dsZSBzdGF0ZS5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vblBvcG92ZXJPcGVuID0gZnVuY3Rpb24gX29uUG9wb3Zlck9wZW4oKSB7XG4gICAgdGhpcy5fZmlsbFRvZ2dsZSgpO1xuICAgIHRoaXMuX2NoZWNrU2l6ZSgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50QnJlYWtwb2ludCA9PT0gJ3hzJykgdGhpcy5fc2Nyb2xsVG9JbnB1dCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwb3BvdmVyIGNsb3NlcywgcmVzZXQgdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vblBvcG92ZXJDbG9zZSA9IGZ1bmN0aW9uIF9vblBvcG92ZXJDbG9zZSgpIHtcbiAgICB0aGlzLl91bmZpbGxUb2dnbGUoKTtcbiAgICB0aGlzLl91cGRhdGVIb3ZlckNsYXNzZXMoKTtcbiAgICB0aGlzLl9kZWFjdGl2YXRlRWxlbWVudCh0aGlzLmFjdGl2ZUluZGV4KTtcbiAgICB0aGlzLmFjdGl2ZUluZGV4ID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgaW5wdXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGlzIGluc3RhbmNlIGNoYW5nZXMuIEFsbG93cyB1cyB0byBsaXN0ZW5cbiAgICogYW5kIHJlc3BvbmQgdG8gY2hhbmdlcyBtYWRlIGJ5IG90aGVyIGNvbXBvbmVudHMgKENhbGVuZGFyIFBvcG92ZXIsIGZvciBleGFtcGxlKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vbklucHV0Q2hhbmdlID0gZnVuY3Rpb24gX29uSW5wdXRDaGFuZ2UoZSkge1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbnB1dEVscy5pbmRleE9mKGUudGFyZ2V0KTtcblxuICAgIGlmICh0aGlzLl9pbnB1dHNDaGFuZ2luZyAmJiB0aGlzLl9pbnB1dHNDaGFuZ2luZy5pbmRleE9mKGluZGV4KSAhPT0gLTEpIHJldHVybjtcblxuICAgIHRoaXMuc2V0VmFsdWUoZS50YXJnZXQudmFsdWUsIGluZGV4KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBhbiBpbnB1dCByZWNlaXZlcyBmb2N1cywgaWYgd2UgYXJlIHN1cHBvc2VkIHRvIGF1dG9tYXRpY2FsbHkgc2hvd1xuICAgKiBvbiBmb2N1cyBkbyBzby5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBDYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLl9vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiBfb25JbnB1dEZvY3VzKGUpIHtcbiAgICBpZiAoIXRoaXMuc2hvd09uRm9jdXMpIHJldHVybjtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmlucHV0RWxzLmluZGV4T2YoZS50YXJnZXQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHRoaXMub3BlbihpbmRleCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gb25lIG9mIHRoZSBjYWxlbmRhciBxdWljayBqdW1wIHNlbGVjdCBpbnB1dHMgY2hhbmdlcy5cbiAgICogV2UgaGF2ZSB0byBzZXQgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3QgaW5wdXQgYmFjayB0byBpdHMgb3JpZ2luYWxcbiAgICogdmFsdWUgb3IgZWxzZSBpdCB3aWxsIGJlIG91dCBvZiBzeW5jIHdoZW4gdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgICogbW9udGggaXMgc2hvd24gYWdhaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25TZWxlY3RDaGFuZ2UgPSBmdW5jdGlvbiBfb25TZWxlY3RDaGFuZ2UoZSkge1xuXG4gICAgdmFyIG5hbWUgPSBlLnRhcmdldC5uYW1lO1xuICAgIHZhciB2YWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICB2YXIgY3VyVmFsID0gdGhpcy5fZGF0ZXNUb1Nob3dbdGhpcy5hY3RpdmVJbmRleF1bbmFtZV07XG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgb2JqW25hbWVdID0gdmFsO1xuICAgIHRoaXMuc2hvd0RhdGUob2JqKTtcbiAgICBlLnRhcmdldC52YWx1ZSA9IGN1clZhbDtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIGRldGVybWluZSBpZiB3ZSdyZSBhdCB0aGUgWFMgYnJlYWtwb2ludCBzbyB3ZVxuICAgKiBjYW4gZG8gc29tZSBtb2JpbGUtZXNxdWUgc3R1ZmYhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fb25SZXNpemUgPSBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlSW5kZXggIT09IG51bGwpIHRoaXMuX2NoZWNrU2l6ZSgpO1xuICB9O1xuXG4gIHJldHVybiBDYWxlbmRhclBvcG92ZXI7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuLyoqXG4gKiBXaGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBzZXQgb24gY29uc3RydWN0aW9uLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cblxuQ2FsZW5kYXJQb3BvdmVyLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ2VscycsICd2aXNpYmxlQ291bnRzJywgJ2F1dG9BZHZhbmNlJywgJ2F1dG9DbG9zZScsICdjbG9zZURlbGF5JywgJ21pbnMnLCAnbWF4ZXMnLCAndmFsdWVzJywgJ2RheXNEaXNhYmxlZCcsICdkYXlzSW5mbycsICdxdWlja0p1bXAnLCAnY2FsZW5kYXJFbCcsICd2aWV3UmFuZ2UnLCAnYW5pbWF0ZScsICdhbmltYXRpb25EdXJhdGlvbicsICdzaG93T25Gb2N1cycsICdvbkNoYW5nZSddO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5DYWxlbmRhclBvcG92ZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBlbHM6IG51bGwsXG4gIGlucHV0RWxzOiBudWxsLFxuICBjYWxlbmRhckVsOiBudWxsLFxuICBjYWxlbmRhckNvbnRlbnRFbDogbnVsbCxcbiAgY2FsZW5kYXJPdmVyZmxvd0VsOiBudWxsLFxuICB2aXNpYmxlQ291bnRzOiBudWxsLFxuICBhY3RpdmVJbmRleDogbnVsbCxcbiAgbWluczogbnVsbCxcbiAgbWluVmlzaWJsZTogbnVsbCxcbiAgbWF4ZXM6IG51bGwsXG4gIG1heFZpc2libGU6IG51bGwsXG4gIHZhbHVlczogbnVsbCxcbiAgZGF5c0Rpc2FibGVkOiBudWxsLFxuICBkYXlzSW5mbzogbnVsbCxcbiAgdmlld1JhbmdlOiBudWxsLFxuICBhdXRvQWR2YW5jZTogbnVsbCxcbiAgYXV0b0Nsb3NlOiBudWxsLFxuICBxdWlja0p1bXA6IG51bGwsXG4gIGNsb3NlRGVsYXk6IG51bGwsXG4gIG5leHRCdXR0b25FbDogbnVsbCxcbiAgcHJldmlvdXNCdXR0b25FbDogbnVsbCxcbiAgYW5pbWF0ZTogbnVsbCxcbiAgYW5pbWF0aW9uRHVyYXRpb246IG51bGwsXG4gIHNob3dPbkZvY3VzOiBudWxsLFxuICBvbkNoYW5nZTogbnVsbCxcbiAgX2lzRGlzYWJsZWQ6IGZhbHNlLFxuICBfaXNSYW5nZTogbnVsbCxcbiAgX2hvdmVyU3RhcnRzOiBudWxsLFxuICBfaG92ZXJFbmRzOiBudWxsLFxuICBfY3VycmVudEJyZWFrcG9pbnQ6IG51bGwsXG4gIF9hbmltYXRpb25RdWV1ZTogbnVsbCxcbiAgX2N1cnJlbnRDb250ZW50OiBudWxsLFxuICBfZGF0ZXNUb1Nob3c6IG51bGwsXG4gIF9tb250aHNTaG93aW5nOiBudWxsLFxuICBfYXRNaW46IGZhbHNlLFxuICBfYXRNYXg6IGZhbHNlLFxuICBfaW5wdXRzQ2hhbmdpbmc6IGZhbHNlLFxuICBfb3BlbkNsb3NlVGltZXI6IG51bGwsXG4gIF9yZW5kZXJDYWNoZTogbnVsbCxcbiAgX29uQ2xpY2tCb3VuZDogbnVsbCxcbiAgX29uQ2FsZW5kYXJNb3VzZU92ZXJCb3VuZDogbnVsbCxcbiAgX29uQ2FsZW5kYXJNb3VzZU91dEJvdW5kOiBudWxsLFxuICBfb25DYWxlbmRhckNsaWNrQm91bmQ6IG51bGwsXG4gIF9vblNlbGVjdENoYW5nZUJvdW5kOiBudWxsLFxuICBfb25JbnB1dENoYW5nZUJvdW5kOiBudWxsLFxuICBfb25JbnB1dEZvY3VzQm91bmQ6IG51bGwsXG4gIF9vblJlc2l6ZUJvdW5kOiBudWxsXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYWxlbmRhclBvcG92ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGVuZGFyLXBvcG92ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfYWRkQ2xhc3MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9hZGQtY2xhc3MnKTtcblxudmFyIF9hZGRDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGRDbGFzcyk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS90b2dnbGUtY2xhc3MnKTtcblxudmFyIF90b2dnbGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b2dnbGVDbGFzcyk7XG5cbnZhciBfYXBwZW5kQ2hpbGRyZW4gPSByZXF1aXJlKCcuLi9oZWxwZXJzL21hbmlwdWxhdGlvbi9hcHBlbmQtY2hpbGRyZW4nKTtcblxudmFyIF9hcHBlbmRDaGlsZHJlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBlbmRDaGlsZHJlbik7XG5cbnZhciBfaGFzUGFyZW50ID0gcmVxdWlyZSgnLi4vaGVscGVycy90cmF2ZXJzYWwvaGFzLXBhcmVudCcpO1xuXG52YXIgX2hhc1BhcmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNQYXJlbnQpO1xuXG52YXIgX2dldFBhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQnKTtcblxudmFyIF9nZXRQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UGFyZW50KTtcblxudmFyIF9wYXJzZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZScpO1xuXG52YXIgX2FmZml4ID0gcmVxdWlyZSgnLi4vaGVscGVycy9wb3NpdGlvbi9hZmZpeCcpO1xuXG52YXIgX2FmZml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FmZml4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgUG9wb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2hvdyBhbmQgaGlkZSBhIHBvcG92ZXIuIFNob3VsZCBkbyBzb21lIHNhbml0eSBjaGVja3Mgb24gcG9zaXRpb25pbmcgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV3IFBvcG92ZXIoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgLy8gT3B0aW9uYWwuIERlZmF1bHQgYW5jaG9yaW5nIG9mIHRoZSBjb250ZW50J3MgeCBhbmQgeS1heGlzIHJlbGF0aXZlIHRvIHRoZSBidXR0b24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGRlZmF1bHRBbmNob3JYOiAnY2VudGVyJywgLy8gJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBkZWZhdWx0QW5jaG9yWTogJ2NlbnRlcicgLy8gJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBjb21wb25lbnRzL3BvcG92ZXIuanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgUG9wb3ZlciA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUG9wb3ZlciwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvcG92ZXIoZWwpIHtcbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcG92ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKSk7XG5cbiAgICBpZiAoIWVsKSByZXR1cm4gX3JldCA9IF90aGlzLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgX3RoaXMuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCk7XG4gICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3BlbigpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSB0aW1lciBydW5uaW5nIGZvciB0aGUgY2xvc2UgZXZlbnQsIGNsZWFyIGl0IHNvIGl0XG4gICAgLy8gZG9lc24ndCBjbG9zZSBzdHVmZiBkdXJpbmcgb3Blbi5cbiAgICBpZiAodGhpcy5jbG9zZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgd2UgYW5jaG9yIHRoZSBwb3BvdmVyIHRvIGlzIGZpeGVkLCB3ZSBuZWVkIHRvIGtub3dcbiAgICAvLyBzbyB0aGF0IHRoZSBhZmZpeGVkIGNvbnRlbnQgY2FuIGFsc28gYmUgZml4ZWQuXG4gICAgdGhpcy5fY2hlY2tGaXhlZFBvc2l0aW9uKCk7XG5cbiAgICAvLyBVcGRhdGUgYW4gZXhpc3RpbmcgYWZmaXhlZCBpbnN0YW5jZS5cbiAgICBpZiAodGhpcy5hZmZpeCkge1xuICAgICAgdGhpcy5hZmZpeC50YXJnZXRFbCA9IHBhcmFtcy5hZmZpeFRvIHx8IHRoaXMuYWZmaXgudGFyZ2V0RWw7XG4gICAgICB0aGlzLmFmZml4LnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvLyBBZmZpeCB0aGUgY29udGVudCB0byB0aGUgdG9nZ2xlXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYWZmaXggPSBuZXcgX2FmZml4Mi5kZWZhdWx0KHtcbiAgICAgICAgICBlbDogdGhpcy5jb250ZW50RWwsXG4gICAgICAgICAgdGFyZ2V0RWw6IHBhcmFtcy5hZmZpeFRvIHx8IHRoaXMuZWwsXG4gICAgICAgICAgY2FyZXRFbDogdGhpcy5jYXJldEVsLFxuICAgICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgICAgICBhbmNob3JZOiB0aGlzLmFuY2hvclksXG4gICAgICAgICAgaXNGaXhlZDogdGhpcy5pc0ZpeGVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciBjbGlja3Mgb24gdGhlIHdpbmRvd1xuICAgIHRoaXMuX2FkZFdpbmRvd0V2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIC8vIERpc3BhdGNoIGEgY3VzdG9tIGV2ZW50IHNvIGNvbnRlbnQgaW5zaWRlIHRoZSBwb3BvdmVyIGNhbiByZXNwb25kXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBlLmluaXRFdmVudCgnc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRydWUsIHRydWUpO1xuICAgIHRoaXMuY29udGVudEVsLmRpc3BhdGNoRXZlbnQoZSk7XG5cbiAgICAvLyBVcGRhdGUgYmluZGluZ3NcbiAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKCk7XG5cbiAgICAvLyBDYWxsYmFja3NcbiAgICAocGFyYW1zLmNvbXBsZXRlIHx8IG5vb3ApKCk7XG4gICAgKHRoaXMub25PcGVuIHx8IG5vb3ApKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIC8vIE5vdCBvcGVuLCBzbyBkb24ndCBjbG9zZS5cbiAgICBpZiAoIXRoaXMuYWZmaXgpIHJldHVybiB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSB0aW1lciBydW5uaW5nIGZvciB0aGUgY2xvc2UgZXZlbnQsIGNsZWFyIGl0IHNvIHdlIGRvbid0IHJ1biBjbG9zZSBzdHVmZiB0d2ljZS5cbiAgICBpZiAodGhpcy5jbG9zZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgdG8gd2luZG93IGNsaWNrcy5cbiAgICB0aGlzLl9yZW1vdmVXaW5kb3dFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgLy8gVXBkYXRlIGJpbmRpbmdzXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcygpO1xuXG4gICAgLy8gQ2xvc2UgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkXG4gICAgdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuX2ZpbmlzaENsb3NlKHBhcmFtcyk7XG4gICAgfSwgMjUwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIG9wZW4gc3RhdGUuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMuaXNBY3RpdmUgPyAnY2xvc2UnIDogJ29wZW4nXSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbnRlbnQuIE9wdGlvbmFsbHkgYXBwZW5kIGluc3RlYWQgb2YgcmVwbGFjaW5nLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl8Tm9kZUxpc3R9IGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBPcHRpb25hbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQsIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAoMCwgX2FwcGVuZENoaWxkcmVuMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgY29udGVudC5sZW5ndGggPyBjb250ZW50IDogW2NvbnRlbnRdLCAhKHBhcmFtcy5hcHBlbmQgfHwgZmFsc2UpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG5cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2NhY2hlRWxlbWVudHMoZWwgfHwgdGhpcy5lbCk7XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmICh0aGlzLmFmZml4KSB0aGlzLmFmZml4LnVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWJzIGxpc3QsIGVhY2ggdGFiIGFuZCBlYWNoIHBhbmVsLlxuICAgKiBTZXQgd2hpY2ggdGFiIGlzIGFjdGl2ZSwgb3IgdXNlIHRoZSBmaXJzdC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jYWNoZUVsZW1lbnRzID0gZnVuY3Rpb24gX2NhY2hlRWxlbWVudHMoZWwpIHtcblxuICAgIC8vIElmIGEgY29udGVudCBlbGVtZW50IHdhcyBhbHJlYWR5IHBhc3NlZCwgbWFrZSBzdXJlIGl0IGhhcyBhIHBvcG92ZXIgY29udGVudCBjbGFzc1xuICAgIGlmICh0aGlzLmNvbnRlbnRFbCkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMudG9nZ2xlRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1wb3BvdmVyX190b2dnbGUsIFtkYXRhLXJvbGU9XCJ0b2dnbGVcIl0nKSB8fCB0aGlzLmVsO1xuICAgIHRoaXMuY29udGVudEVsID0gdGhpcy5jb250ZW50RWwgfHwgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstcG9wb3Zlcl9fY29udGVudCwgW2NsYXNzKj1cInNwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLVwiXScpIHx8IHRoaXMuX2NyZWF0ZUNvbnRlbnRFbCgpO1xuICAgIHRoaXMuY2FyZXRFbCA9IHRoaXMuY29udGVudEVsLnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1wb3BvdmVyX19jYXJldCcpIHx8IHRoaXMuX2NyZWF0ZUNhcmV0RWwoKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy50b2dnbGVFbCwgJ3BvcG92ZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGNvbmZpZyB2YWx1ZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiBfcGFyc2VQYXJhbXMoKSB7XG5cbiAgICB0aGlzLmFuY2hvclkgPSB0aGlzLmFuY2hvclkgIT09IG51bGwgPyB0aGlzLmFuY2hvclkgOiAoMCwgX3BhcnNlQXR0cmlidXRlLnN0cmluZykodGhpcy5jb250ZW50RWwsICdkYXRhLWFuY2hvci15JywgbnVsbCk7XG4gICAgdGhpcy5hbmNob3JYID0gdGhpcy5hbmNob3JYICE9PSBudWxsID8gdGhpcy5hbmNob3JYIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuY29udGVudEVsLCAnZGF0YS1hbmNob3IteCcsIG51bGwpO1xuXG4gICAgLy8gTm8gYW5jaG9ycyBkZWZpbmVkXG4gICAgaWYgKCF0aGlzLmFuY2hvclkgJiYgIXRoaXMuYW5jaG9yWCkge1xuXG4gICAgICAvLyBMZWZ0XG4gICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50LS1sZWZ0JykpIHtcbiAgICAgICAgdGhpcy5hbmNob3JZID0gJ21pZGRsZSc7XG4gICAgICAgIHRoaXMuYW5jaG9yWCA9ICdsZWZ0JztcbiAgICAgIH1cbiAgICAgIC8vIFJpZ2h0XG4gICAgICBlbHNlIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLXJpZ2h0JykpIHtcbiAgICAgICAgICB0aGlzLmFuY2hvclkgPSAnbWlkZGxlJztcbiAgICAgICAgICB0aGlzLmFuY2hvclggPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcFxuICAgICAgICBlbHNlIGlmICgoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KSh0aGlzLmNvbnRlbnRFbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQtLXRvcCcpKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclkgPSAndG9wJztcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmNob3JZID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5jaG9yWCA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBidXR0b24gdHJpZ2dlcmluZyB0aGUgcG9wb3ZlciBpcyBmaXhlZC5cbiAgICogSWYgc28sIHRoZW4gcG9wb3ZlciBuZWVkcyB0byBiZSBmaXhlZCBhcyB3ZWxsLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jaGVja0ZpeGVkUG9zaXRpb24gPSBmdW5jdGlvbiBfY2hlY2tGaXhlZFBvc2l0aW9uKCkge1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZWw7XG5cbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcbiAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzRml4ZWQgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGNsYXNzZXMgZm9yIHRoZSBvcGVuIG9yIGNsb3NlIHN0YXRlLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl91cGRhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3VwZGF0ZUF0dHJpYnV0ZXMoKSB7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5lbCwgJ3BvcG92ZXItYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdhY3RpdmUnLCB0aGlzLmlzQWN0aXZlKTtcbiAgICAoMCwgX3RvZ2dsZUNsYXNzMi5kZWZhdWx0KSh0aGlzLnRvZ2dsZUVsLCAnYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG4gICAgdGhpcy5fb25DbGlja0JvdW5kID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQ29udGVudENsaWNrQm91bmQgPSB0aGlzLl9vbkNvbnRlbnRDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uV2luZG93Q2xpY2tCb3VuZCA9IHRoaXMuX29uV2luZG93Q2xpY2suYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2tCb3VuZCk7XG4gICAgdGhpcy5jb250ZW50RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNvbnRlbnRDbGlja0JvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy4uXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgIHRoaXMuY29udGVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Db250ZW50Q2xpY2tCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHdpbmRvdy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkV2luZG93RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fcmVtb3ZlV2luZG93RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbldpbmRvd0NsaWNrQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgd2luZG93IGV2ZW50IGxpc3RlbmVycy5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fcmVtb3ZlV2luZG93RXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVtb3ZlV2luZG93RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25XaW5kb3dDbGlja0JvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jcmVhdGVDb250ZW50RWwgPSBmdW5jdGlvbiBfY3JlYXRlQ29udGVudEVsKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKGVsLCAnc3BhcmstcG9wb3Zlcl9fY29udGVudCcpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNhcmV0IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX2NyZWF0ZUNhcmV0RWwgPSBmdW5jdGlvbiBfY3JlYXRlQ2FyZXRFbCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5jbGFzc05hbWUgPSAnc3BhcmstcG9wb3Zlcl9fY2FyZXQnO1xuICAgIHRoaXMuY29udGVudEVsLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHRoZSBjbG9zZSBldmVudCBieSBtb3ZpbmcgdGhlIGVsZW1lbnQgYmFjayBhbmQgZGVzdHJveWluZyB0aGUgYWZmaXguXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX2ZpbmlzaENsb3NlID0gZnVuY3Rpb24gX2ZpbmlzaENsb3NlKCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cbiAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuXG4gICAgLy8gTW92ZSB0aGUgY29udGVudCBiYWNrIHRvIHRoZSBwYXJlbnRcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsKTtcblxuICAgIHRoaXMuYWZmaXgucmVtb3ZlKHsga2VlcEVsOiB0cnVlIH0pO1xuICAgIHRoaXMuYWZmaXggPSBudWxsO1xuXG4gICAgKHBhcmFtcy5jb21wbGV0ZSB8fCBub29wKSgpO1xuICAgICh0aGlzLm9uQ2xvc2UgfHwgbm9vcCkoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB3ZSBhcmUgY2xpY2tlZCwgdG9nZ2xlIHRoZSBwb3BvdmVyLWFjdGl2ZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uIF9vbkNsaWNrKGUpIHtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIHRvZ2dsZSBlbGVtZW50LCB0b2dnbGUuXG4gICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLnRvZ2dsZUVsIHx8ICgwLCBfaGFzUGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgdGhpcy50b2dnbGVFbCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB0b2dnbGUgaXMgY2xpY2tlZCwgY2xvc2UgaWYgaXQncyBhIGxpbmsuIElmIGl0J3MgY29udGVudCwgZG9uJ3QgZG8gYW55dGhpbmcgYnV0IHN0b3BcbiAgICogdGhlIGV2ZW50IGZyb20gYnViYmxpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uQ29udGVudENsaWNrID0gZnVuY3Rpb24gX29uQ29udGVudENsaWNrKGUpIHtcblxuICAgIC8vIElmIHRoaXMgaXMgYSBsaW5rLCBjbG9zZS5cbiAgICBpZiAoKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLXBvcG92ZXJfX2xpc3QtbGluaycsIHRoaXMuY29udGVudEVsKSB8fCAoMCwgX2dldFBhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsICcuc3BhcmstcG9wb3Zlcl9fY2xvc2UnLCB0aGlzLmNvbnRlbnRFbCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpbmRvdyBpcyBjbGlja2VkIGFuZCBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBwb3BvdmVyLCBjbG9zZSB0aGUgcG9wb3Zlci5cbiAgICogQHBhcmFtIHtPYmplY30gZVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9vbldpbmRvd0NsaWNrID0gZnVuY3Rpb24gX29uV2luZG93Q2xpY2soZSkge1xuXG4gICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLmVsICYmICEoMCwgX2hhc1BhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsIHRoaXMuZWwpICYmICEoMCwgX2hhc1BhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsIHRoaXMuY29udGVudEVsKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9wb3Zlcjtcbn0oX2Jhc2UyLmRlZmF1bHQpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5Qb3BvdmVyLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbJ2FuY2hvclgnLCAnYW5jaG9yWScsICd0b2dnbGVFbCcsICdjb250ZW50RWwnLCAnb25PcGVuJywgJ29uQ2xvc2UnXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuUG9wb3Zlci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGVsOiBudWxsLFxuICB0b2dnbGVFbDogbnVsbCxcbiAgY29udGVudEVsOiBudWxsLFxuICBjYXJldEVsOiBudWxsLFxuICBhZmZpeDogbnVsbCxcbiAgaXNBY3RpdmU6IGZhbHNlLFxuICBpc1BhdXNlZDogZmFsc2UsXG4gIGlzRml4ZWQ6IGZhbHNlLFxuICBhbmNob3JYOiBudWxsLFxuICBhbmNob3JZOiBudWxsLFxuICBjbG9zZVRpbWVyOiBudWxsLFxuICBvbk9wZW46IG51bGwsXG4gIG9uQ2xvc2U6IG51bGwsXG4gIF9vbkNsaWNrQm91bmQ6IG51bGwsXG4gIF9vbkNvbnRlbnRDbGlja0JvdW5kOiBudWxsLFxuICBfb25XaW5kb3dDbGlja0JvdW5kOiBudWxsLFxuICBfb25XaW5kb3dSZXNpemVCb3VuZDogbnVsbCxcbiAgX29uV2luZG93U2Nyb2xsQm91bmQ6IG51bGxcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBvcG92ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcG92ZXIuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBSZXF1ZXN0IEFuaW1hdGlvblxuICogUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgcG9seWZpbGwuXG4gKiBAbW9kdWxlIGhlbHBlcnMvYW5pbWF0aW9uL3JlcXVlc3QuanNcbiAqL1xudmFyIHJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmcHMgPSA2MDtcbiAgdmFyIGRlbCA9IDEwMDAgLyBmcHM7XG4gIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gIHZhciBwcmV2ID0gc3RhcnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuXG4gICAgdmFyIHJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZW91dCA9IE1hdGgubWF4KDAsIGRlbCAtIChyZXF1ZXN0VGltZSAtIHByZXYpKTtcbiAgICB2YXIgdGltZVRvQ2FsbCA9IHJlcXVlc3RUaW1lICsgdGltZW91dDtcblxuICAgIHByZXYgPSB0aW1lVG9DYWxsO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uIG9uQW5pbWF0aW9uRnJhbWUoKSB7XG4gICAgICBjYWxsYmFjayh0aW1lVG9DYWxsIC0gc3RhcnQpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfb2Zmc2V0ID0gcmVxdWlyZSgnLi4vZG9tL29mZnNldCcpO1xuXG52YXIgX29mZnNldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZzZXQpO1xuXG52YXIgX3R3ZWVuID0gcmVxdWlyZSgnLi90d2VlbicpO1xuXG52YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiAjIFNjcm9sbCBUb1xuICogU2Nyb2xsIHRoZSB3aW5kb3cgdG8gYSBzcGVjaWZpYyBlbGVtZW50IG9yIHBvc2l0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICpcbiAqIEBtb2R1bGUgaGVscGVycy9hbmltYXRpb24vc2Nyb2xsLXRvLmpzXG4gKi9cblxuZnVuY3Rpb24gc2Nyb2xsVG8ocGFyYW1zKSB7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBvZmZzZXQgPSB2b2lkIDA7XG4gIHZhciB4ID0gdm9pZCAwO1xuICB2YXIgeSA9IHZvaWQgMDtcbiAgdmFyIHRhcmdldCA9IHBhcmFtcy50YXJnZXQgfHwgd2luZG93O1xuICB2YXIgc3RhcnRYID0gdGFyZ2V0ICE9PSB3aW5kb3cgPyB0YXJnZXQuc2Nyb2xsTGVmdCA6IHRhcmdldC5wYWdlWE9mZnNldDtcbiAgdmFyIHN0YXJ0WSA9IHRhcmdldCAhPT0gd2luZG93ID8gdGFyZ2V0LnNjcm9sbFRvcCA6IHRhcmdldC5wYWdlWU9mZnNldDtcblxuICBpZiAocGFyYW1zIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICBvZmZzZXQgPSAoMCwgX29mZnNldDIuZGVmYXVsdCkocGFyYW1zKTtcbiAgICB4ID0gb2Zmc2V0LmxlZnQ7XG4gICAgeSA9IG9mZnNldC50b3A7XG4gICAgcGFyYW1zID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICB9IGVsc2Uge1xuICAgIHggPSBwYXJhbXMueCB8fCAwO1xuICAgIHkgPSBwYXJhbXMueSB8fCAwO1xuICB9XG5cbiAgKDAsIF90d2VlbjIuZGVmYXVsdCkoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHByb3A6ICdzY3JvbGxUbycsXG4gICAgc3RhcnQ6IFtzdGFydFgsIHN0YXJ0WV0sXG4gICAgZW5kOiBbeCwgeV0sXG4gICAgZHVyYXRpb246IHBhcmFtcy5kdXJhdGlvbixcbiAgICBjYWxsYmFjazogcGFyYW1zLmNhbGxiYWNrXG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBzY3JvbGxUbztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsLXRvLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcblxudmFyIF9yZXF1ZXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcXVlc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLyoqXG4gKiBUd2VlbiBmcm9tIG9uZSB2YWx1ZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHJldHVybiB7TG9uZ31cbiAqL1xuLyoqXG4gKiAjIFR3ZWVuXG4gKiBUd2VlbiBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gKiBAbW9kdWxlIGhlbHBlcnMvYW5pbWF0aW9uL3R3ZWVuLmpzXG4gKi9cblxuZnVuY3Rpb24gdHdlZW4ocGFyYW1zKSB7XG5cbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBiZWdpbjtcbiAgdmFyIG9iaiA9IHBhcmFtcy50YXJnZXQ7XG5cbiAgaWYgKCFvYmopIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0d2VlbiB3aXRob3V0IGEgdGFyZ2V0IScpO1xuICB9XG5cbiAgdmFyIHByb3AgPSB0eXBlb2YgcGFyYW1zLnByb3AgPT09ICdzdHJpbmcnID8gW3BhcmFtcy5wcm9wXSA6IHBhcmFtcy5wcm9wO1xuICB2YXIgc3RhcnQgPSB0eXBlb2YgcGFyYW1zLnN0YXJ0ID09PSAnbnVtYmVyJyA/IFtwYXJhbXMuc3RhcnRdIDogcGFyYW1zLnN0YXJ0O1xuICB2YXIgZW5kID0gdHlwZW9mIHBhcmFtcy5lbmQgPT09ICdudW1iZXInID8gW3BhcmFtcy5lbmRdIDogcGFyYW1zLmVuZDtcbiAgdmFyIGR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDI1MDtcbiAgdmFyIGNhbGxiYWNrID0gcGFyYW1zLmNhbGxiYWNrIHx8IG5vb3A7XG5cbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgaWYgKHN0YXJ0Lmxlbmd0aCAhPT0gZW5kLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHR3ZWVuIHR3byBkaWZmZXJlbnQgc2V0cyBvZiBwYXJhbWV0ZXJzIScpO1xuICB9XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiBmKHRzKSB7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZW4gd2Ugc3RhcnRcbiAgICBpZiAoIWJlZ2luKSBiZWdpbiA9IHRzO1xuXG4gICAgLy8gUHJvZ3Jlc3NcbiAgICB2YXIgcHJvZyA9IHRzIC0gYmVnaW47XG5cbiAgICAvLyBQZXJjZW50YWdlIGNvbXBsZXRlXG4gICAgdmFyIHBlciA9IE1hdGgubWluKHByb2cgLyBkdXJhdGlvbiwgMSk7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHZhbHVlcyBmb3IgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHN0YXJ0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gc3RhcnRbaV0gKyAoZW5kW2ldIC0gc3RhcnRbaV0pICogcGVyO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgaSA9IDA7XG4gICAgbGVuID0gcHJvcC5sZW5ndGg7XG4gICAgdmFyIGFyZztcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgcHJvcGVydHkgYnV0IHdlIGhhdmUgbW9yZSBhcmd1bWVudHMsIHNldCB0aGVtIGFsbC5cbiAgICAgIGFyZyA9IGkgKyAxID09PSBsZW4gJiYgYXJncy5sZW5ndGggLSAxID4gaSA/IGFyZ3Muc2xpY2UoaSkgOiBhcmdzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIG9ialtwcm9wW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpbcHJvcFtpXV0uYXBwbHkob2JqLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW3Byb3BbaV1dID0gYXJnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEtlZXAgZ29pbmcgaWYgd2UgaGF2ZSBtb3JlIHRvIGRvLlxuICAgIGlmIChwcm9nIDwgZHVyYXRpb24pICgwLCBfcmVxdWVzdDIuZGVmYXVsdCkoZik7ZWxzZSBjYWxsYmFjaygpO1xuICB9O1xuXG4gIHJldHVybiAoMCwgX3JlcXVlc3QyLmRlZmF1bHQpKGYpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0d2Vlbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHdlZW4uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgRGF0ZSBoZWxwZXJcbiAqIEdlbmVyYWwgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIGRhdGVzLlxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kYXRlL2RhdGUuanNcbiAqL1xuXG52YXIgbW9udGhOYW1lcyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xudmFyIG1vbnRoTmFtZXNTaG9ydCA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVnJywgJ1NlcHQnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbnZhciBkYXlOYW1lcyA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXTtcbnZhciBkYXlOYW1lc1Nob3J0ID0gWydTdW4nLCAnTW9uJywgJ1R1ZXMnLCAnV2VkJywgJ1RodXInLCAnRnJpJywgJ1NhdCddO1xudmFyIGFkanVzdGVkRGF5TmFtZXMgPSBbXTtcbnZhciBhZGp1c3RlZERheU5hbWVzU2hvcnQgPSBbXTtcbnZhciB3ZWVrU3RhcnRzT24gPSAwO1xuXG52YXIgZGF0ZUhlbHBlciA9IHtcblxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgZGF0ZSBpbnRvIGFuIG9iamVjdCBvZiBkYXRlIHZhbHVlcy5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGRhdGUpIHtcblxuICAgIGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGUgOiBuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSk7XG5cbiAgICB2YXIgaW5zdCA9IE9iamVjdC5jcmVhdGUoZGF0ZUhlbHBlcik7XG4gICAgaW5zdC5fZGF0ZSA9IGRhdGU7XG4gICAgaW5zdC5fY2FjaGUgPSB7fTtcblxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB5ZWFyLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgeWVhcigpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd5ZWFyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgeWVhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICovXG4gIHNldCB5ZWFyKHkpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd5ZWFyJyk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnNldEZ1bGxZZWFyKHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBtb250aC5cbiAgICogQHJldHVybiB7TnVtYmVyfSAxLTEyXG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGgnKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGEgbW9udGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtIDEtMTJcbiAgICovXG4gIHNldCBtb250aChtKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGgnKTtcbiAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuc2V0TW9udGgobSAtIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBkYXkuXG4gICAqIEByZXR1cm4ge051bWJlcn0gMS0zMVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdkYXknKTtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5nZXREYXRlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBhIGRheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGQgMS0zMVxuICAgKi9cbiAgc2V0IGRheShkKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnZGF5Jyk7XG4gICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnNldERhdGUoZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRheSwgbW9udGggYW5kIHllYXIgdmFsdWVzIGF0IG9uY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIHNldDogZnVuY3Rpb24gc2V0KHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB0aGlzLnllYXIgPSBwYXJhbXMueWVhciB8fCB0aGlzLnllYXI7XG4gICAgdGhpcy5tb250aCA9IHBhcmFtcy5tb250aCB8fCB0aGlzLm1vbnRoO1xuICAgIHRoaXMuZGF5ID0gcGFyYW1zLmRheSB8fCB0aGlzLmRheTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBmdWxsIG5hbWUgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vbnRoTmFtZTogZnVuY3Rpb24gZ2V0TW9udGhOYW1lKG51bSkge1xuICAgIHJldHVybiBtb250aE5hbWVzW251bSAtIDFdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoIG5hbWUuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldCBtb250aE5hbWUoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGhOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0TW9udGhOYW1lKHRoaXMubW9udGgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgbW9udGggbmFtZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0TW9udGhOYW1lczogZnVuY3Rpb24gZ2V0TW9udGhOYW1lcygpIHtcbiAgICByZXR1cm4gbW9udGhOYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBuYW1lIG9mIHRoZSBtb250aC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG51bVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRNb250aE5hbWVTaG9ydDogZnVuY3Rpb24gZ2V0TW9udGhOYW1lU2hvcnQobnVtKSB7XG4gICAgcmV0dXJuIG1vbnRoTmFtZXNTaG9ydFtudW0gLSAxXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhOYW1lU2hvcnQoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbW9udGhOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0TW9udGhOYW1lU2hvcnQodGhpcy5tb250aCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBzaG9ydCBtb250aCBuYW1lcy5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRNb250aE5hbWVzU2hvcnQ6IGZ1bmN0aW9uIGdldE1vbnRoTmFtZXNTaG9ydCgpIHtcbiAgICByZXR1cm4gbW9udGhOYW1lc1Nob3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1vbnRoIG5hbWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xuICAgKi9cbiAgc2V0TW9udGhOYW1lczogZnVuY3Rpb24gc2V0TW9udGhOYW1lcyhuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEyKSBtb250aE5hbWVzID0gbmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2hvcnQgbW9udGggbmFtZXMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzXG4gICAqL1xuICBzZXRNb250aE5hbWVzU2hvcnQ6IGZ1bmN0aW9uIHNldE1vbnRoTmFtZXNTaG9ydChuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEyKSBtb250aE5hbWVzU2hvcnQgPSBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIGEgZ2l2ZW4gZGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDEtN1xuICAgKi9cbiAgZ2V0RGF5T2ZXZWVrOiBmdW5jdGlvbiBnZXREYXlPZldlZWsoZGF0ZSkge1xuICAgIHZhciBkYXkgPSAoZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRlIDogbmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpKS5nZXREYXkoKSAtIHdlZWtTdGFydHNPbjtcbiAgICByZXR1cm4gKGRheSA8IDAgPyA3IC0gTWF0aC5hYnMoZGF5KSA6IGRheSkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheU9mV2VlaygpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5nZXREYXlPZldlZWsodGhpcy5fZGF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIGEgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldERheU5hbWU6IGZ1bmN0aW9uIGdldERheU5hbWUobnVtKSB7XG4gICAgcmV0dXJuIGRheU5hbWVzW251bSAtIDEgKyB3ZWVrU3RhcnRzT25dIHx8IGRheU5hbWVzW2RheU5hbWVzLmxlbmd0aCAtIG51bSAtIDEgKyB3ZWVrU3RhcnRzT25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGF5TmFtZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdkYXlOYW1lJyk7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuZ2V0RGF5TmFtZSh0aGlzLmRheU9mV2Vlayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldERheU5hbWVzOiBmdW5jdGlvbiBnZXREYXlOYW1lcygpIHtcbiAgICByZXR1cm4gYWRqdXN0ZWREYXlOYW1lcy5sZW5ndGggPyBhZGp1c3RlZERheU5hbWVzIDogZGF5TmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2hvcnQgbmFtZSBvZiB0aGUgZGF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldERheU5hbWVTaG9ydDogZnVuY3Rpb24gZ2V0RGF5TmFtZVNob3J0KG51bSkge1xuICAgIHJldHVybiBkYXlOYW1lc1Nob3J0W251bSAtIDEgKyB3ZWVrU3RhcnRzT25dIHx8IGRheU5hbWVzW2RheU5hbWVzLmxlbmd0aCAtIG51bSAtIDEgKyB3ZWVrU3RhcnRzT25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGRheSBuYW1lLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZGF5TmFtZVNob3J0KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ2RheU5hbWVTaG9ydCcpO1xuICAgIHJldHVybiBkYXRlSGVscGVyLmdldERheU5hbWVTaG9ydCh0aGlzLmRheU9mV2Vlayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBuYW1lIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldERheU5hbWVzU2hvcnQ6IGZ1bmN0aW9uIGdldERheU5hbWVzU2hvcnQoKSB7XG4gICAgcmV0dXJuIGFkanVzdGVkRGF5TmFtZXNTaG9ydC5sZW5ndGggPyBhZGp1c3RlZERheU5hbWVzU2hvcnQgOiBkYXlOYW1lc1Nob3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRheSBuYW1lcy5cbiAgICogQHBhcmFtIHtBcnJheX0gbmFtZXNcbiAgICovXG4gIHNldERheU5hbWVzOiBmdW5jdGlvbiBzZXREYXlOYW1lcyhuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDcpIGRheU5hbWVzID0gbmFtZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2hvcnQgZGF5IG5hbWVzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBuYW1lc1xuICAgKi9cbiAgc2V0RGF5TmFtZXNTaG9ydDogZnVuY3Rpb24gc2V0RGF5TmFtZXNTaG9ydChuYW1lcykge1xuICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDcpIGRheU5hbWVzU2hvcnQgPSBuYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXZWVrU3RhcnRzT246IGZ1bmN0aW9uIGdldFdlZWtTdGFydHNPbigpIHtcbiAgICByZXR1cm4gd2Vla1N0YXJ0c09uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBzZXRXZWVrU3RhcnRzT246IGZ1bmN0aW9uIHNldFdlZWtTdGFydHNPbihudW1iZXIpIHtcblxuICAgIHdlZWtTdGFydHNPbiA9IG51bWJlcjtcblxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIGFkanVzdGVkRGF5TmFtZXMgPSBkYXlOYW1lcy5zbGljZSh3ZWVrU3RhcnRzT24pO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lcyA9IGFkanVzdGVkRGF5TmFtZXMuY29uY2F0KGRheU5hbWVzLnNsaWNlKDAsIHdlZWtTdGFydHNPbikpO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lc1Nob3J0ID0gZGF5TmFtZXNTaG9ydC5zbGljZSh3ZWVrU3RhcnRzT24pO1xuICAgICAgYWRqdXN0ZWREYXlOYW1lc1Nob3J0ID0gYWRqdXN0ZWREYXlOYW1lc1Nob3J0LmNvbmNhdChkYXlOYW1lc1Nob3J0LnNsaWNlKDAsIHdlZWtTdGFydHNPbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGp1c3RlZERheU5hbWVzID0gW107XG4gICAgICBhZGp1c3RlZERheU5hbWVzU2hvcnQgPSBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkYXRlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB5ZWFyIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBUaGlzIG9idmlvdXNseSBpc24ndCB2ZXJ5IGNvbXBsaWNhdGVkLCBidXQgaXQgZXhpc3RzXG4gICAqIGZvciBwYXJpdHkgd2l0aCBob3cgd2UgZ2V0IHRoZSB3ZWVrLCBkYXkgYW5kIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXROZXh0WWVhcjogZnVuY3Rpb24gZ2V0TmV4dFllYXIoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIgKyAxLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dFllYXIoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbmV4dFllYXInKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dFllYXIgfHwgKHRoaXMuX2NhY2hlLm5leHRZZWFyID0gZGF0ZUhlbHBlci5nZXROZXh0WWVhcih0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGZvciBhIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFdlZWtTdGFydDogZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0KGRhdGUpIHtcbiAgICB2YXIgaW5zdCA9IGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDEsIGRhdGUuZGF5IC0gZGF0ZUhlbHBlci5nZXREYXlPZldlZWsoZGF0ZSkgKyAxKSk7XG4gICAgaW5zdC53ZWVrU3RhcnRzT24gPSB3ZWVrU3RhcnRzT247XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIHdlZWsgZm9yIHRoaXMgZGF0ZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IHdlZWtTdGFydCgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCd3ZWVrU3RhcnQnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUud2Vla1N0YXJ0ICYmIHRoaXMuX2NhY2hlLndlZWtTdGFydC53ZWVrU3RhcnRzT24gPT09IHdlZWtTdGFydHNPbiA/IHRoaXMuX2NhY2hlLndlZWtTdGFydCA6IHRoaXMuX2NhY2hlLndlZWtTdGFydCA9IGRhdGVIZWxwZXIuZ2V0V2Vla1N0YXJ0KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TW9udGhTdGFydDogZnVuY3Rpb24gZ2V0TW9udGhTdGFydChkYXRlKSB7XG4gICAgdmFyIGluc3QgPSBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCAxKSk7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnQgb2YgdGhlIG1vbnRoIGZvciB0aGlzIGRhdGUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBtb250aFN0YXJ0KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ21vbnRoU3RhcnQnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubW9udGhTdGFydCB8fCAodGhpcy5fY2FjaGUubW9udGhTdGFydCA9IGRhdGVIZWxwZXIuZ2V0TW9udGhTdGFydCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB3ZWVrIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXROZXh0V2VlazogZnVuY3Rpb24gZ2V0TmV4dFdlZWsoZGF0ZSkge1xuICAgIHZhciBzdGFydCA9IGRhdGVIZWxwZXIuZ2V0V2Vla1N0YXJ0KGRhdGUpO1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShzdGFydC55ZWFyLCBzdGFydC5tb250aCAtIDEsIHN0YXJ0LmRheSArIDcpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dFdlZWsoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygnbmV4dFdlZWsnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dFdlZWsgfHwgKHRoaXMuX2NhY2hlLm5leHRXZWVrID0gZGF0ZUhlbHBlci5nZXROZXh0V2Vlayh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBkYXkgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE5leHREYXk6IGZ1bmN0aW9uIGdldE5leHREYXkoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSArIDEpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXkgZm9sbG93aW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBuZXh0RGF5KCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ25leHREYXknKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUubmV4dERheSB8fCAodGhpcy5fY2FjaGUubmV4dERheSA9IGRhdGVIZWxwZXIuZ2V0TmV4dERheSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBtb250aCBhZnRlciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TmV4dE1vbnRoOiBmdW5jdGlvbiBnZXROZXh0TW9udGgoZGF0ZSkge1xuICAgIC8vIERhdGUoKSBoYXMgYSAqYnVnL2ZlYXR1cmUqIGlmIGxhc3QgZGF5IG9mIG1vbnRoIGlzIDMxIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG5leHQgbW9udGguXG4gICAgLy8gTmVlZCB0byBhY2NvdW50IGZvciB0aGF0IHNvIHRoYXQgaXQgZG9lc24ndCByb3VuZCB1cCB0aGUgZGF0ZS9tb250aC5cblxuICAgIGlmIChkYXRlLmRheSA9PT0gMzEgJiYgZGF0ZS5tb250aCAhPT0gMSAmJiBkYXRlLm1vbnRoICE9PSA3ICYmIGRhdGUubW9udGggIT09IDEyKSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIG1vbnRocyBlbmRpbmcgaW4gMzEgZm9sbG93ZWQgYnkgbW9udGhzIGVuZGluZyBpbiAzMFxuICAgICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXkgLSAxKSk7XG4gICAgfSBlbHNlIGlmIChkYXRlLmRheSA+IDI4ICYmIGRhdGUubW9udGggPT09IDEpIHtcbiAgICAgIC8vIGZpeCBmb3IgbGFzdCBkYXkgb2YgRmVicnVhcnlcbiAgICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggKyAxLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIGRhdGUuZGF5KSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1vbnRoIGZvbGxvd2luZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbmV4dE1vbnRoKCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ25leHRNb250aCcpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5uZXh0TW9udGggfHwgKHRoaXMuX2NhY2hlLm5leHRNb250aCA9IGRhdGVIZWxwZXIuZ2V0TmV4dE1vbnRoKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmV2aW91cyB5ZWFyIGFmdGVyIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBUaGlzIG9idmlvdXNseSBpc24ndCB2ZXJ5IGNvbXBsaWNhdGVkLCBidXQgaXQgZXhpc3RzXG4gICAqIGZvciBwYXJpdHkgd2l0aCBob3cgd2UgZ2V0IHRoZSB3ZWVrLCBkYXkgYW5kIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRQcmV2aW91c1llYXI6IGZ1bmN0aW9uIGdldFByZXZpb3VzWWVhcihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciAtIDEsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXIgcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c1llYXIoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNZZWFyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnByZXZpb3VzWWVhciB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNZZWFyID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c1llYXIodGhpcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIHdlZWsgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFByZXZpb3VzV2VlazogZnVuY3Rpb24gZ2V0UHJldmlvdXNXZWVrKGRhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBkYXRlSGVscGVyLmdldFdlZWtTdGFydChkYXRlKTtcbiAgICB2YXIgaW5zdCA9IGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKHN0YXJ0LnllYXIsIHN0YXJ0Lm1vbnRoIC0gMSwgc3RhcnQuZGF5IC0gNykpO1xuICAgIGluc3Qud2Vla1N0YXJ0c09uID0gd2Vla1N0YXJ0c09uO1xuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c1dlZWsoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNXZWVrJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLnByZXZpb3VzV2VlayB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNXZWVrID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c1dlZWsodGhpcykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIGRheSBhZnRlciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UHJldmlvdXNEYXk6IGZ1bmN0aW9uIGdldFByZXZpb3VzRGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkgLSAxKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IHByZWNlZGluZyB0aGlzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXQgcHJldmlvdXNEYXkoKSB7XG4gICAgdGhpcy5faW5zdGFuY2VDaGVjaygncHJldmlvdXNEYXknKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucHJldmlvdXNEYXkgfHwgKHRoaXMuX2NhY2hlLnByZXZpb3VzRGF5ID0gZGF0ZUhlbHBlci5nZXRQcmV2aW91c0RheSh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJldmlvdXMgbW9udGggYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFByZXZpb3VzTW9udGg6IGZ1bmN0aW9uIGdldFByZXZpb3VzTW9udGgoZGF0ZSkge1xuICAgIC8vIERhdGUoKSBoYXMgYSAqYnVnL2ZlYXR1cmUqIGlmIGxhc3QgZGF5IG9mIG1vbnRoIGlzIDMxIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgIC8vIE5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdCBzbyB0aGF0IGl0IGRvZXNuJ3Qgcm91bmQgdXAgdGhlIGRhdGUvbW9udGguXG5cbiAgICBpZiAoZGF0ZS5kYXkgPT09IDMxICYmIGRhdGUubW9udGggIT09IDEgJiYgZGF0ZS5tb250aCAhPT0gMyAmJiBkYXRlLm1vbnRoICE9PSA4KSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIG1vbnRocyBlbmRpbmcgaW4gMzEgdGhhdCBmb2xsb3cgbW9udGhzIGVuZGluZyBpbiAzMFxuICAgICAgcmV0dXJuIGRhdGVIZWxwZXIuY3JlYXRlKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDIsIGRhdGUuZGF5IC0gMSkpO1xuICAgIH0gZWxzZSBpZiAoZGF0ZS5kYXkgPiAyOCAmJiBkYXRlLm1vbnRoID09PSAzKSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIGxhc3QgZGF5IG9mIEZlYnJ1YXJ5XG4gICAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0ZUhlbHBlci5jcmVhdGUobmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMiwgZGF0ZS5kYXkpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggcHJlY2VkaW5nIHRoaXMuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBwcmV2aW91c01vbnRoKCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ2hlY2soJ3ByZXZpb3VzTW9udGgnKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGUucHJldmlvdXNNb250aCB8fCAodGhpcy5fY2FjaGUucHJldmlvdXNNb250aCA9IGRhdGVIZWxwZXIuZ2V0UHJldmlvdXNNb250aCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRNb250aEVuZDogZnVuY3Rpb24gZ2V0TW9udGhFbmQoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGgsIDApKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGguXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCBtb250aEVuZCgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdtb250aEVuZCcpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5tb250aEVuZCB8fCAodGhpcy5fY2FjaGUubW9udGhFbmQgPSBkYXRlSGVscGVyLmdldE1vbnRoRW5kKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogRG9lcyBhIGdpdmVuIGRheSBlcXVhbCBhbm90aGVyPyBPciBpcyBpdCBwcmVzZW50IGluIGEgbGlzdCBvZiBvdGhlcnM/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWw6IGZ1bmN0aW9uIGVxdWFsKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lcXVhbERheShkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgfSxcblxuICAvKipcbiAgICogRG9lcyBhIGdpdmVuIGRheSBlcXVhbCBhbm90aGVyPyBPciBpcyBpdCBwcmVzZW50IGluIGEgbGlzdCBvZiBvdGhlcnM/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxEYXk6IGZ1bmN0aW9uIGVxdWFsRGF5KGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNvbXBhcmVbaV0gJiYgZGF0ZS55ZWFyID09PSBjb21wYXJlW2ldLnllYXIgJiYgZGF0ZS5tb250aCA9PT0gY29tcGFyZVtpXS5tb250aCAmJiBkYXRlLmRheSA9PT0gY29tcGFyZVtpXS5kYXkpIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB3ZWVrIGVxdWFsIHRvIGFub3RoZXI/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxXZWVrOiBmdW5jdGlvbiBlcXVhbFdlZWsoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgIWRhdGUud2Vla1N0YXJ0LmVxdWFsRGF5KGNvbXBhcmVbaV0ud2Vla1N0YXJ0KSkgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgbW9udGggZXF1YWwgdG8gYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbE1vbnRoOiBmdW5jdGlvbiBlcXVhbE1vbnRoKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFjb21wYXJlW2ldIHx8IGRhdGUueWVhciAhPT0gY29tcGFyZVtpXS55ZWFyIHx8IGRhdGUueWVhciA9PT0gY29tcGFyZVtpXS55ZWFyICYmIGRhdGUubW9udGggIT09IGNvbXBhcmVbaV0ubW9udGgpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIHllYXIgZXF1YWwgdG8gYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbFllYXI6IGZ1bmN0aW9uIGVxdWFsWWVhcihkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLnllYXIgIT09IGNvbXBhcmVbaV0ueWVhcikgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZGF0ZSBiZWZvcmUgYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlRGF5KGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIGdpdmVuIGRhdGUgYmVmb3JlIGFub3RoZXI/XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbCBSZXR1cm4gYSBzdWNjZXNzZnVsIG1hdGNoIG9ubHkgaWYgYWxsIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgYmVmb3JlRGF5OiBmdW5jdGlvbiBiZWZvcmVEYXkoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS5fZGF0ZSA+PSBjb21wYXJlW2ldLl9kYXRlKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB3ZWVrIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZVdlZWs6IGZ1bmN0aW9uIGJlZm9yZVdlZWsoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgIWRhdGUud2Vla1N0YXJ0LmJlZm9yZURheShjb21wYXJlW2ldLndlZWtTdGFydCkpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIG1vbnRoIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZU1vbnRoOiBmdW5jdGlvbiBiZWZvcmVNb250aChkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLnllYXIgPiBjb21wYXJlW2ldLnllYXIgfHwgZGF0ZS55ZWFyID09PSBjb21wYXJlW2ldLnllYXIgJiYgZGF0ZS5tb250aCA+PSBjb21wYXJlW2ldLm1vbnRoKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSB5ZWFyIGJlZm9yZSBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGJlZm9yZVllYXI6IGZ1bmN0aW9uIGJlZm9yZVllYXIoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS55ZWFyID49IGNvbXBhcmVbaV0ueWVhcikgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZGF0ZSBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYWZ0ZXJEYXkoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgZ2l2ZW4gZGF0ZSBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyRGF5OiBmdW5jdGlvbiBhZnRlckRheShkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCBkYXRlLl9kYXRlIDw9IGNvbXBhcmVbaV0uX2RhdGUpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJcyBhIHdlZWsgYWZ0ZXIgYW5vdGhlcj9cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGNvbXBhcmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHVybiBhIHN1Y2Nlc3NmdWwgbWF0Y2ggb25seSBpZiBhbGwgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBhZnRlcldlZWs6IGZ1bmN0aW9uIGFmdGVyV2VlayhkYXRlLCBjb21wYXJlLCBmdWxsKSB7XG5cbiAgICB2YXIgYXJncyA9IHRoaXMuX2NoZWNrQ29tcGFyaXNvbkFyZ3MoZGF0ZSwgY29tcGFyZSwgZnVsbCk7XG4gICAgZGF0ZSA9IGFyZ3NbMF07XG4gICAgY29tcGFyZSA9IGFyZ3NbMV07XG4gICAgZnVsbCA9IGFyZ3NbMl07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNvbXBhcmUubGVuZ3RoO1xuICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGFyZVtpXSB8fCAhZGF0ZS53ZWVrU3RhcnQuYWZ0ZXJEYXkoY29tcGFyZVtpXS53ZWVrU3RhcnQpKSBjb250aW51ZTtlbHNlIG1hdGNoZXMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbCA/IG1hdGNoZXMgPT09IGxlbiA6ICEhbWF0Y2hlcztcbiAgfSxcblxuICAvKipcbiAgICogSXMgYSBtb250aCBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyTW9udGg6IGZ1bmN0aW9uIGFmdGVyTW9udGgoZGF0ZSwgY29tcGFyZSwgZnVsbCkge1xuXG4gICAgdmFyIGFyZ3MgPSB0aGlzLl9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpO1xuICAgIGRhdGUgPSBhcmdzWzBdO1xuICAgIGNvbXBhcmUgPSBhcmdzWzFdO1xuICAgIGZ1bGwgPSBhcmdzWzJdO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBjb21wYXJlLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2hlcyA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIWNvbXBhcmVbaV0gfHwgZGF0ZS55ZWFyIDwgY29tcGFyZVtpXS55ZWFyIHx8IGRhdGUueWVhciA9PT0gY29tcGFyZVtpXS55ZWFyICYmIGRhdGUubW9udGggPD0gY29tcGFyZVtpXS5tb250aCkgY29udGludWU7ZWxzZSBtYXRjaGVzKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bGwgPyBtYXRjaGVzID09PSBsZW4gOiAhIW1hdGNoZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElzIGEgeWVhciBhZnRlciBhbm90aGVyP1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gY29tcGFyZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0dXJuIGEgc3VjY2Vzc2Z1bCBtYXRjaCBvbmx5IGlmIGFsbCBtYXRjaGVzIGFyZSBmb3VuZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGFmdGVyWWVhcjogZnVuY3Rpb24gYWZ0ZXJZZWFyKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIHZhciBhcmdzID0gdGhpcy5fY2hlY2tDb21wYXJpc29uQXJncyhkYXRlLCBjb21wYXJlLCBmdWxsKTtcbiAgICBkYXRlID0gYXJnc1swXTtcbiAgICBjb21wYXJlID0gYXJnc1sxXTtcbiAgICBmdWxsID0gYXJnc1syXTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY29tcGFyZS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoZXMgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFjb21wYXJlW2ldIHx8IGRhdGUueWVhciA8PSBjb21wYXJlW2ldLnllYXIpIGNvbnRpbnVlO2Vsc2UgbWF0Y2hlcysrO1xuICAgIH1cblxuICAgIHJldHVybiBmdWxsID8gbWF0Y2hlcyA9PT0gbGVuIDogISFtYXRjaGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVhcmxpZXN0IGRhdGUgaW4gYW4gYXJyYXkuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGVhcmxpZXN0OiBmdW5jdGlvbiBlYXJsaWVzdChhcnIpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgZSA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghZSB8fCBhcnJbaV0uYmVmb3JlKGUpKSBlID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhdGVzdCBkYXRlIGluIGFuIGFycmF5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBsYXRlc3Q6IGZ1bmN0aW9uIGxhdGVzdChhcnIpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgbCA9IHZvaWQgMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghbCB8fCBhcnJbaV0uYWZ0ZXIobCkpIGwgPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lIGEgZGF0ZSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGRhdGUpIHtcblxuICAgIC8vIElmIHdlIHdlcmVuJ3QgcGFzc2VkIGEgZGF0ZSwgdXNlIHRoaXMgaW5zdGFuY2UuXG4gICAgaWYgKCFkYXRlICYmIHRoaXMuX2RhdGUgJiYgdGhpcy5fZGF0ZSBpbnN0YW5jZW9mIERhdGUgJiYgZGF0ZUhlbHBlci5pc1Byb3RvdHlwZU9mKHRoaXMpKSB7XG4gICAgICBkYXRlID0gdGhpcztcbiAgICB9XG5cbiAgICAvLyBObyBkYXRlLCBjYW4ndCBjbG9uZS5cbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGEgZGF0ZSB0byBjbG9uZSBvciBjYWxsIG9uIGFuIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlSGVscGVyLmNyZWF0ZShuZXcgRGF0ZShkYXRlLl9kYXRlLnZhbHVlT2YoKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhIGNvbXBhcmlzb24gZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGluc3RhbmNlLCBwcm9wZXJseVxuICAgKiBhc3NpZ24gdGhlIHZhcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBjb21wYXJlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbFxuICAgKi9cbiAgX2NoZWNrQ29tcGFyaXNvbkFyZ3M6IGZ1bmN0aW9uIF9jaGVja0NvbXBhcmlzb25BcmdzKGRhdGUsIGNvbXBhcmUsIGZ1bGwpIHtcblxuICAgIGlmIChjb21wYXJlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNvbXBhcmUgPT09ICdib29sZWFuJykge1xuXG4gICAgICBpZiAoIWRhdGVIZWxwZXIuaXNQcm90b3R5cGVPZih0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIG9ubHkgb25lIGRhdGUhJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bGwgPSBjb21wYXJlO1xuICAgICAgY29tcGFyZSA9IGRhdGU7XG4gICAgICBkYXRlID0gdGhpcztcbiAgICB9XG5cbiAgICBjb21wYXJlID0gY29tcGFyZSBpbnN0YW5jZW9mIEFycmF5ID8gY29tcGFyZSA6IFtjb21wYXJlXTtcblxuICAgIHJldHVybiBbZGF0ZSwgY29tcGFyZSwgZnVsbF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoZSBkYXRlIG9iamVjdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBwcm9wXG4gICAqL1xuICBfaW5zdGFuY2VDaGVjazogZnVuY3Rpb24gX2luc3RhbmNlQ2hlY2socHJvcCkge1xuICAgIGlmICghdGhpcy5fZGF0ZSB8fCAhKHRoaXMuX2RhdGUgaW5zdGFuY2VvZiBEYXRlKSB8fCAhZGF0ZUhlbHBlci5pc1Byb3RvdHlwZU9mKHRoaXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2Nlc3MgdGhlIHByb3BlcnR5IFwiJyArIHByb3AgKyAnXCIgb2YgdGhlIGRhdGUgaGVscGVyIHdpdGggY3JlYXRpbmcgYW4gaW5zdGFuY2UhJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBjYWNoZS5cbiAgICovXG4gIF9jbGVhckNhY2hlOiBmdW5jdGlvbiBfY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNoZWNrKCdjbGVhckNhY2hlJyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZGF0ZUhlbHBlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wYWQgPSByZXF1aXJlKCcuLi91dGlsL3BhZCcpO1xuXG52YXIgX3BhZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYWQpO1xuXG52YXIgX2RhdGUgPSByZXF1aXJlKCcuL2RhdGUnKTtcblxudmFyIF9kYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RhdGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIE1hcCBjaGFyYWN0ZXJzIHRvIHRoZWlyIHNwZWNpYWwgbWVhbmluZ3MuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG4vKipcbiAqICMgUGFyc2UgRGF0ZSBGb3JtYXRcbiAqIEdpdmVuIGEgZGF0ZSBmb3JtYXQgc3RyaW5nLCBicmVhayBpdCBkb3duIGludG8gcGllY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBwYXJzZURhdGVGb3JtYXQoJ01NLURELVlZWVknKTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZGF0ZS9wYXJzZS1mb3JtYXQuanNcbiAqL1xuXG52YXIgbWFwID0ge1xuICBkOiAnZGF5JyxcbiAgbTogJ21vbnRoJyxcbiAgeTogJ3llYXInLFxuICAnLSc6ICdkaXZpZGVyJyxcbiAgJy8nOiAnZGl2aWRlcicsXG4gICcgJzogJ3NwYWNlJ1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGZvcm1hdCBhbmQgYSBzdHJpbmcsIGdldCB0aGUgZGF5LCBtb250aCBhbmQgeWVhciB2YWx1ZXMgZnJvbSB0aGF0IHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZXMoZm9ybWF0KSB7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbiA9IGZvcm1hdC5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IHt9O1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBmb3JtYXQgcGllY2VzXG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAvLyBPbmx5IHdvcnJ5IGFib3V0IGRhdGUgdmFsdWVzXG4gICAgICBpZiAoWydkYXknLCAnbW9udGgnLCAneWVhciddLmluZGV4T2YoZm9ybWF0W2ldLm5hbWUpICE9PSAtMSkge1xuXG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgdmFsdWUgZG9lc24ndCBjb250YWluIGEgZm9ybWF0IHBpZWNlLCBpdCdzIGludmFsaWQuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCBpbmRleCArIGZvcm1hdFtpXS5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICB2YWx1ZXNbZm9ybWF0W2ldLm5hbWVdID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGluZGV4LCBmb3JtYXRbaV0ubGVuZ3RoKSwgMTApO1xuICAgICAgfVxuICAgICAgaW5kZXggKz0gZm9ybWF0W2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2RhdGUyLmRlZmF1bHQuY3JlYXRlKHZhbHVlcyk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZm9ybWF0dGVkIGRhdGUgc3RyaW5nIGdpdmVuIGFuIG9iamVjdCBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nKGZvcm1hdCkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHMpIHtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZm9ybWF0Lmxlbmd0aDtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgIC8vIE51bWJlcnNcbiAgICAgIGlmICh2YWxzW2Zvcm1hdFtpXS5uYW1lXSkge1xuICAgICAgICBzdHIgKz0gKDAsIF9wYWQyLmRlZmF1bHQpKHZhbHNbZm9ybWF0W2ldLm5hbWVdLCBmb3JtYXRbaV0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gZm9ybWF0W2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZUZvcm1hdChmb3JtYXQpIHtcblxuICB2YXIgZiA9IGZvcm1hdC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBmLmxlbmd0aDtcblxuICB2YXIgb2JqID0ge1xuICAgIHBhcnRzOiBbXVxuICB9O1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgY2hhcmFjdGVyIG1hcHBpbmcgYW5kIHRoZSBsYXN0IHBhcnQgd2FzIG9mIHRoZSBzYW1lIG5hbWUsIGluY3JlbWVudCBpdHMgbGVuZ3RoXG4gICAgLy8gYW5kIGFkZCB0byBpdHMgY29udGVudC5cbiAgICBpZiAobWFwW2ZbaV1dICYmIG9iai5wYXJ0cy5sZW5ndGggJiYgb2JqLnBhcnRzW29iai5wYXJ0cy5sZW5ndGggLSAxXS5uYW1lID09PSBtYXBbZltpXV0pIHtcbiAgICAgIG9iai5wYXJ0c1tvYmoucGFydHMubGVuZ3RoIC0gMV0ubGVuZ3RoKys7XG4gICAgICBvYmoucGFydHNbb2JqLnBhcnRzLmxlbmd0aCAtIDFdLnZhbHVlICs9IGZvcm1hdFtpXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIG9iai5wYXJ0cy5wdXNoKHtcbiAgICAgIG5hbWU6IG1hcFtmW2ldXSA/IG1hcFtmW2ldXSA6ICcnLFxuICAgICAgdmFsdWU6IGZvcm1hdFtpXSxcbiAgICAgIGxlbmd0aDogMVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIGEgd2F5IHRvIGNvbnZlcnQgdGhlIHBhcnNlZCBkYXRlIGludG8gYSByZWdleC1pc2ggc3RyaW5nIHRoYXQgd29ya3Mgd2l0aCB0aGUgVHlwZWFoZWFkIGltcGxlbWVudGF0aW9uLlxuICBvYmouZ2V0VmFsdWVzID0gZ2V0VmFsdWVzKG9iai5wYXJ0cyk7XG4gIG9iai5nZXRTdHJpbmcgPSBnZXRTdHJpbmcob2JqLnBhcnRzKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZURhdGVGb3JtYXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWZvcm1hdC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqICMgQWRkIENsYXNzXG4gKiBBZGQgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2FkZC1jbGFzcy5qc1xuICovXG5cbnZhciB3cyA9IC9cXHMrLztcbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKG5hbWVbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IG5hbWUubGVuZ3RoO1xuICB2YXIgaXRlbSA9IHZvaWQgMDtcbiAgdmFyIGNsc05hbWUgPSB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnO1xuXG4gIC8vIHNlZSBpZiB3ZSBoYXZlIGFueXRoaW5nIHRvIGFkZFxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBuYW1lW2ldO1xuICAgIGlmIChpdGVtICYmICEoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShjbHNOYW1lLCBpdGVtKSkge1xuICAgICAgdG9BZGQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KSgoY2xzTmFtZSArICcgJyArIHRvQWRkLmpvaW4oJyAnKSkucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWNsYXNzLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgQnJlYWtwb2ludCBIZWxwZXJzXG4gKiBGaW5kIHRoZSBhY3RpdmUgYnJlYWtwb2ludC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2JyZWFrcG9pbnQuanNcbiAqL1xuXG4vKipcbiAqIEJyZWFrcG9pbnRzIGJlaW5nIHVzZWQgaW4gdGhlIENTUy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBkZWZhdWx0QnJlYWtwb2ludHMgPSB7XG4gIHhzOiB7XG4gICAgbWluOiAwLFxuICAgIG1heDogNTQzXG4gIH0sXG4gIHNtOiB7XG4gICAgbWluOiA1NDQsXG4gICAgbWF4OiA3OTVcbiAgfSxcbiAgbWQ6IHtcbiAgICBtaW46IDc5NixcbiAgICBtYXg6IDEwNDdcbiAgfSxcbiAgbGc6IHtcbiAgICBtaW46IDEwNDgsXG4gICAgbWF4OiAxNzk5XG4gIH0sXG4gIHhsOiB7XG4gICAgbWluOiAxODAwLFxuICAgIG1heDogSW5maW5pdHlcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHdpZHRoLCBicmVha3BvaW50cykge1xuXG4gIGJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuXG4gIHZhciBpID0gdm9pZCAwO1xuXG4gIGZvciAoaSBpbiBicmVha3BvaW50cykge1xuICAgIGlmICh3aWR0aCA+PSBicmVha3BvaW50c1tpXS5taW4gJiYgd2lkdGggPD0gYnJlYWtwb2ludHNbaV0ubWF4KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXQgPSBnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVha3BvaW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogIyBIYXMgQ2xhc3NcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL2hhcy1jbGFzcy5qc1xuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xuICB2YXIgY05hbWUgPSAoKHR5cGVvZiBlbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZWwpKSA9PT0gJ29iamVjdCcgPyBlbC5jbGFzc05hbWUgfHwgZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJyA6IGVsIHx8ICcnKS5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmXS9nLCAnICcpO1xuICByZXR1cm4gKCcgJyArIGNOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpICE9PSAtMTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBPZmZzZXQgUG9zaXRpb25cbiAqIEdldCB0aGUgb2Zmc2V0IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlld1BvcnRPZmZzZXQgVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQsIG5vdCBwYWdlLlxuICogQHJldHVybiB7T2JqZWN0fVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vb2Zmc2V0LmpzXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChlbCwgdmlld1BvcnRPZmZzZXQpIHtcblxuICB2YXIgcmVjdCA9IHtcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9O1xuXG4gIC8vIE5hdGl2ZSBpbXBsZW1lbnRhdGlvblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG5cbiAgICB2YXIgYm91bmRpbmcgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZWN0LmxlZnQgPSBib3VuZGluZy5sZWZ0O1xuICAgIHJlY3QudG9wID0gYm91bmRpbmcudG9wO1xuXG4gICAgaWYgKCF2aWV3UG9ydE9mZnNldCkge1xuICAgICAgcmVjdC5sZWZ0ICs9IHR5cGVvZiB3aW5kb3cuc2Nyb2xsWCAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuc2Nyb2xsWCA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgIHJlY3QudG9wICs9IHR5cGVvZiB3aW5kb3cuc2Nyb2xsWSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuc2Nyb2xsWSA6IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHggPSAwLFxuICAgICAgICB5ID0gMDtcbiAgICBkbyB7XG4gICAgICB4ICs9IGVsLm9mZnNldExlZnQgLSAoIXZpZXdQb3J0T2Zmc2V0ID8gZWwuc2Nyb2xsTGVmdCA6IDApO1xuICAgICAgeSArPSBlbC5vZmZzZXRUb3AgLSAoIXZpZXdQb3J0T2Zmc2V0ID8gZWwuc2Nyb2xsVG9wIDogMCk7XG4gICAgfSB3aGlsZSAoZWwgPSBlbC5vZmZzZXRQYXJlbnQpO1xuXG4gICAgcmVjdC5sZWZ0ID0geDtcbiAgICByZWN0LnRvcCA9IHk7XG4gIH1cblxuICByZXR1cm4gcmVjdDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gb2Zmc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZmZzZXQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgUGFyc2UgRE9NIGF0dHJpYnV0ZXNcbiAqIEdpdmVuIGFuIGVsZW1lbnQgYW5kIGFuIGF0dHJpYnV0ZSBuYW1lLCBwYXJzZSB0aGF0IGF0dHJpYnV0ZVxuICogaWYgaXQgZXhpc3RzIG9yIHJldHVybiBhIGRlZmF1bHQuXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanNcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbihlbCwgbmFtZSwgZGVmKSB7XG4gIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBkZWY7XG4gIHJldHVybiB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICcnID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbnVtZXJpYyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlZlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1hdHRyaWJ1dGUuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHJpbSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJpbScpO1xuXG52YXIgX3RyaW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJpbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3cyA9IC9cXHMrLzsgLyoqXG4gICAgICAgICAgICAgICAgICogIyBSZW1vdmUgQ2xhc3NcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYSBjbGFzcyBvbiBhbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qc1xuICAgICAgICAgICAgICAgICAqL1xuXG52YXIgY2xlYW51cCA9IC9cXHN7Mix9L2c7XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkobmFtZSkuc3BsaXQod3MpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgfVxuXG4gIC8vIG9wdGltaXplIGZvciBiZXN0LCBtb3N0IGNvbW1vbiBjYXNlXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMSAmJiBlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAobmFtZVswXSkgZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lWzBdKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvLyBzdG9yZSB0d28gY29waWVzXG4gIHZhciBjbHNOYW1lID0gJyAnICsgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJycpICsgJyAnO1xuICB2YXIgcmVzdWx0ID0gY2xzTmFtZTtcbiAgdmFyIGN1cnJlbnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGN1cnJlbnQgPSBuYW1lW2ldO1xuICAgIHN0YXJ0ID0gY3VycmVudCA/IHJlc3VsdC5pbmRleE9mKCcgJyArIGN1cnJlbnQgKyAnICcpIDogLTE7XG4gICAgaWYgKHN0YXJ0ICE9PSAtMSkge1xuICAgICAgc3RhcnQgKz0gMTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBzdGFydCkgKyByZXN1bHQuc2xpY2Uoc3RhcnQgKyBjdXJyZW50Lmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB3cml0ZSBpZiBtb2RpZmllZFxuICBpZiAoY2xzTmFtZSAhPT0gcmVzdWx0KSB7XG4gICAgaWYgKHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpO1xuICAgIH0gZWxzZSBpZiAoZWwuc2V0QXR0cmlidXRlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbnZhciBfYWRkQ2xhc3MgPSByZXF1aXJlKCcuL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4vcmVtb3ZlLWNsYXNzJyk7XG5cbnZhciBfcmVtb3ZlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ2xhc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbCwgbmFtZSwgZW5hYmxlKSB7XG5cbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIHBhc3NlZCBhbiBhcnJheSwgdG9nZ2xlIHRoZSBjbGFzcyBvbiBlYWNoLlxuICBpZiAoZWwgaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRvZ2dsZUNsYXNzKGVsW2ldLCBuYW1lLCBlbmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhY3Rpb24gPSB2b2lkIDA7XG4gIGlmIChlbmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZSA9IHR5cGVvZiBlbmFibGUgPT09ICdmdW5jdGlvbicgPyBlbmFibGUuY2FsbChudWxsLCBlbCkgOiBlbmFibGU7XG4gICAgYWN0aW9uID0gZW5hYmxlID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgfSBlbHNlIHtcbiAgICBhY3Rpb24gPSAoMCwgX2hhc0NsYXNzMi5kZWZhdWx0KShlbCwgbmFtZSkgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICB9XG5cbiAgcmV0dXJuIChhY3Rpb24gPT09ICdhZGQnID8gX2FkZENsYXNzMi5kZWZhdWx0IDogX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShlbCwgbmFtZSk7XG59IC8qKlxuICAgKiAjIFRvZ2dsZSBDbGFzc1xuICAgKiBUb2dnbGUgYSBjbGFzcyBvbiBhbiBlbGVtZW50IGdpdmVuIGEgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlICBoZWxwZXJzL2RvbS90b2dnbGUtY2xhc3MuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRvZ2dsZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2dnbGUtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgVHJpZ2dlciBFdmVudFxuICogVHJpZ2dlciBhIERPTSBldmVudCBvbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS90cmlnZ2VyLWV2ZW50LmpzXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJFdmVudChlbCwgbmFtZSkge1xuXG4gIHZhciBldmVudCA9IHZvaWQgMDtcblxuICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50LmV2ZW50TmFtZSA9IG5hbWU7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgIGV2ZW50LmV2ZW50VHlwZSA9IG5hbWU7XG4gICAgZXZlbnQuZXZlbnROYW1lID0gbmFtZTtcbiAgICBlbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50LmV2ZW50VHlwZSwgZXZlbnQpO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaWdnZXJFdmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlci1ldmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqICMgQnVpbGQgU2VsZWN0XG4gKiBCdWlsZCBhIHNlbGVjdCBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKlxuICogQGV4YW1wbGVcbiAqIGJ1aWxkU2VsZWN0KHtcbiAqICAgYXR0cmlidXRlczoge1xuICogICAgIG5hbWU6ICd0ZXN0JyxcbiAqICAgICBjbGFzczogJ3NwYXJrLXNlbGVjdF9fZmllbGQnXG4gKiAgIH0sXG4gKiAgIG9wdGlvbnM6IFsxLCAyLCAzLCA0LCA1LCA2XVxuICogfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIGJ1aWxkU2VsZWN0KHtcbiAqICAgYXR0cmlidXRlczoge1xuICogICAgIG5hbWU6ICd0ZXN0JyxcbiAqICAgICBjbGFzczogJ3NwYXJrLXNlbGVjdF9fZmllbGQnLFxuICogICAgICdkYXRhLWF0dHInOiAndGhpbmcnLFxuICogICAgICBtdWx0aXBsZTogdHJ1ZVxuICogICB9LFxuICogICBzZWxlY3RlZDogWzIsIDRdLFxuICogICBvcHRpb25zOiBbXG4gKiAgICAge3RleHQ6ICdPbmUnLCB2YWx1ZTogMX0sXG4gKiAgICAge3RleHQ6ICdUd28nLCB2YWx1ZTogMn0sXG4gKiAgICAge3RleHQ6ICdUaHJlZScsIHZhbHVlOiAzfSxcbiAqICAgICB7dGV4dDogJ0ZvdXInLCB2YWx1ZTogNH0sXG4gKiAgICAge3RleHQ6ICdGaXZlJywgdmFsdWU6IDV9LFxuICogICBdXG4gKiB9KTtcbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZm9ybS9idWlsZC1zZWxlY3QuanNcbiAqL1xuXG5mdW5jdGlvbiBidWlsZFNlbGVjdChwYXJhbXMpIHtcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGF0dHJzID0gcGFyYW1zLmF0dHJpYnV0ZXM7XG4gIHZhciBzZWxlY3RlZCA9IHBhcmFtcy5zZWxlY3RlZCBpbnN0YW5jZW9mIEFycmF5ID8gcGFyYW1zLnNlbGVjdGVkIDogcGFyYW1zLnNlbGVjdGVkID8gW3BhcmFtcy5zZWxlY3RlZF0gOiBbXTtcbiAgdmFyIG9wdHMgPSBwYXJhbXMub3B0aW9ucztcblxuICB2YXIgaSA9IHZvaWQgMDtcbiAgdmFyIGxlbiA9IG9wdHMubGVuZ3RoO1xuXG4gIC8vIFNldCBhdHRyaWJ1dGVzXG4gIGZvciAoaSBpbiBhdHRycykge1xuICAgIGVsLnNldEF0dHJpYnV0ZShpLCBhdHRyc1tpXSk7XG4gIH1cblxuICAvLyBBZGQgb3B0aW9uc1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoX3R5cGVvZihvcHRzW2ldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgb3B0c1tpXS52YWx1ZSArICdcIiAnICsgKHNlbGVjdGVkLmluZGV4T2Yob3B0c1tpXS52YWx1ZSkgIT09IC0xID8gJ3NlbGVjdGVkJyA6ICcnKSArICc+JyArIG9wdHNbaV0udGV4dCArICc8L29wdGlvbj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIG9wdHNbaV0gKyAnXCIgJyArIChzZWxlY3RlZC5pbmRleE9mKG9wdHNbaV0pICE9PSAtMSA/ICdzZWxlY3RlZCcgOiAnJykgKyAnPicgKyBvcHRzW2ldICsgJzwvb3B0aW9uPic7XG4gICAgfVxuICB9XG5cbiAgZWwuaW5uZXJIVE1MID0gaHRtbDtcblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkU2VsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZC1zZWxlY3QuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL3V0aWwvZWFjaCcpO1xuXG52YXIgX2VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkcmVuKGVsLCBjaGlsZHJlbiwgZW1wdHkpIHtcblxuICBlbXB0eSA9IGVtcHR5ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGVtcHR5O1xuXG4gIGlmIChlbXB0eSkge1xuICAgIGVsLnRleHRDb250ZW50ID0gJyc7XG4gIH1cblxuICB2YXIgZG9tTGlzdCA9IGNoaWxkcmVuIGluc3RhbmNlb2Ygd2luZG93LkhUTUxDb2xsZWN0aW9uO1xuXG4gIGlmIChkb21MaXN0KSB7XG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKGNoaWxkcmVuLCBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLyoqXG4gICAqICMgQXBwZW5kIENoaWxkcmVuXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiBjaGlsZHJlbiB0byBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtBcnJheX0gY2hpbGRyZW5cbiAgICogQHBhcmFtIHtCb29sZWFufSBlbXB0eSBFbXB0eSB0aGUgbm9kZSBiZWZvcmUgYWRkaW5nIGNoaWxkcmVuP1xuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvbWFuaXB1bGF0aW9uL2FwcGVuZC1jaGlsZHJlbi5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gYXBwZW5kQ2hpbGRyZW47XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGVuZC1jaGlsZHJlbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9vZmZzZXQyID0gcmVxdWlyZSgnLi4vZG9tL29mZnNldCcpO1xuXG52YXIgX29mZnNldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZzZXQyKTtcblxudmFyIF9ib3hQb3NpdGlvbiA9IHJlcXVpcmUoJy4vYm94LXBvc2l0aW9uJyk7XG5cbnZhciBfYm94UG9zaXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYm94UG9zaXRpb24pO1xuXG52YXIgX2RlYm91bmNlID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJvdW5jZScpO1xuXG52YXIgX2RlYm91bmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlYm91bmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBBZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFmZml4IG9uZSBlbGVtZW50IHRvIGFub3RoZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBBZmZpeCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICB0YXJnZXRFbDogZWwyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgY2FyZXRFbDogZWwzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWTogJ3RvcCcsIC8vICdtaWRkbGUnLCAnYm90dG9tJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgYW5jaG9yWDogJ2xlZnQnLCAvLyAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvcG9zaXRpb24vYWZmaXguanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxudmFyIEFmZml4ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnRzIGFuZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIEFmZml4KCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFmZml4KTtcblxuICAgIHRoaXMuZWwgPSBwYXJhbXMuZWw7XG4gICAgdGhpcy50YXJnZXRFbCA9IHBhcmFtcy50YXJnZXRFbDtcbiAgICB0aGlzLmNhcmV0RWwgPSBwYXJhbXMuY2FyZXRFbDtcbiAgICB0aGlzLmFuY2hvclkgPSBwYXJhbXMuYW5jaG9yWSB8fCAndG9wJztcbiAgICB0aGlzLmFuY2hvclggPSBwYXJhbXMuYW5jaG9yWCB8fCAnY2VudGVyJztcbiAgICB0aGlzLmlzRml4ZWQgPSBwYXJhbXMuaXNGaXhlZCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5faW5zZXJ0RWwoKTtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX3VwZGF0ZURlYm91bmNlZCA9ICgwLCBfZGVib3VuY2UyLmRlZmF1bHQpKHRoaXMudXBkYXRlLmJpbmQodGhpcyksIDUwMCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgYW5kIGNsZWFuIHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqIEByZXR1cm4ge09iamVjdH0gdGhpc1xuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoIXBhcmFtcy5rZWVwRWwpIHRoaXMuX3JlbW92ZUVsKCk7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHdpbmRvdyByZXNpemVzIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9vblJlc2l6ZUJvdW5kID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbEJvdW5kID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5faW5zZXJ0RWwgPSBmdW5jdGlvbiBfaW5zZXJ0RWwoKSB7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYWZmaXhlZCcsICcnKTtcbiAgICB0aGlzLl9nZXRSb290RWwoKS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX3JlbW92ZUVsID0gZnVuY3Rpb24gX3JlbW92ZUVsKCkge1xuICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hZmZpeGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBfc2V0UG9zaXRpb24oKSB7XG5cbiAgICAvLyBGaXhlZCBwb3NpdGlvblxuICAgIHRoaXMuZWwuc3R5bGUuc2V0UHJvcGVydHkoJ3Bvc2l0aW9uJywgdGhpcy5pc0ZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScsICdpbXBvcnRhbnQnKTtcblxuICAgIC8vIFRhcmdldCBlbGVtZW50IHByb3BlcnRpZXNcblxuICAgIHZhciBfb2Zmc2V0ID0gKDAsIF9vZmZzZXQzLmRlZmF1bHQpKHRoaXMudGFyZ2V0RWwsIHRoaXMuaXNGaXhlZCksXG4gICAgICAgIHRhcmdldFRvcCA9IF9vZmZzZXQudG9wLFxuICAgICAgICB0YXJnZXRMZWZ0ID0gX29mZnNldC5sZWZ0O1xuXG4gICAgdmFyIHRhcmdldFdpZHRoID0gdGhpcy50YXJnZXRFbC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGhpcy50YXJnZXRFbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBFbGVtZW50IHRvIGFmZml4IHByb3BlcnRpZXNcbiAgICB2YXIgZWxXaWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsSGVpZ2h0ID0gdGhpcy5lbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBNYXhlc1xuICAgIHZhciBkb2NIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBkb2NXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgIC8vIEdldCB0aGUgdmFsdWVzXG5cbiAgICB2YXIgX2NhbGN1bGF0ZVBvc2l0aW9uMiA9IHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHtcbiAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yWCxcbiAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgIHRhcmdldFRvcDogdGFyZ2V0VG9wLFxuICAgICAgdGFyZ2V0TGVmdDogdGFyZ2V0TGVmdCxcbiAgICAgIGVsSGVpZ2h0OiBlbEhlaWdodCxcbiAgICAgIGVsV2lkdGg6IGVsV2lkdGgsXG4gICAgICB0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcbiAgICAgIG1pblg6IDAsXG4gICAgICBtaW5ZOiAwLFxuICAgICAgbWF4WDogZG9jV2lkdGggLSBlbFdpZHRoLFxuICAgICAgbWF4WTogTWF0aC5tYXgoZG9jSGVpZ2h0IC0gZWxIZWlnaHQsIDApXG4gICAgfSksXG4gICAgICAgIGVsVG9wID0gX2NhbGN1bGF0ZVBvc2l0aW9uMi5lbFRvcCxcbiAgICAgICAgZWxMZWZ0ID0gX2NhbGN1bGF0ZVBvc2l0aW9uMi5lbExlZnQ7XG5cbiAgICAvLyBQb3NpdGlvbiB0aGUgY2FyZXRcblxuXG4gICAgdmFyIF9wb3NpdGlvbkNhcmV0MiA9IHRoaXMuX3Bvc2l0aW9uQ2FyZXQoe1xuICAgICAgZWxMZWZ0OiBlbExlZnQsXG4gICAgICBlbFRvcDogZWxUb3AsXG4gICAgICBlbFdpZHRoOiBlbFdpZHRoLFxuICAgICAgZWxIZWlnaHQ6IGVsSGVpZ2h0LFxuICAgICAgdGFyZ2V0SGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgICB0YXJnZXRXaWR0aDogdGFyZ2V0V2lkdGgsXG4gICAgICB0YXJnZXRMZWZ0OiB0YXJnZXRMZWZ0LFxuICAgICAgdGFyZ2V0VG9wOiB0YXJnZXRUb3BcbiAgICB9KSxcbiAgICAgICAgZXh0cmFMZWZ0ID0gX3Bvc2l0aW9uQ2FyZXQyLmV4dHJhTGVmdCxcbiAgICAgICAgZXh0cmFUb3AgPSBfcG9zaXRpb25DYXJldDIuZXh0cmFUb3A7XG5cbiAgICAvLyBTZXQgdGhlIHBvc2l0aW9uXG5cblxuICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IGVsTGVmdCArIGV4dHJhTGVmdCArICdweCc7XG4gICAgdGhpcy5lbC5zdHlsZS50b3AgPSBlbFRvcCArIGV4dHJhVG9wICsgJ3B4JztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwcm9wZXIgdG9wIHBvc2l0aW9uIGZvciBhbiBhbmNob3IgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fY2FsY3VsYXRlUG9zaXRpb24gPSBmdW5jdGlvbiBfY2FsY3VsYXRlUG9zaXRpb24ocCkge1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB3aGF0IHdlJ3JlIHRyeWluZyB0byBkbyBoZXJlLCBzbyBvbiBzdWJzZXF1ZW50LCBuZXN0ZWQgY2FsbHMgdG8gdGhpc1xuICAgIC8vIG1ldGhvZCB3ZSBjYW4gc2VlIHdoYXQgaGFzIGFscmVhZHkgYmVlbiB0cmllZC5cbiAgICBwLnByZXZpb3VzQXR0ZW1wdHMgPSAocC5wcmV2aW91c0F0dGVtcHRzIHx8IDApICsgMTtcbiAgICBwLnByZXZpb3VzQ2hlY2tzID0gcC5wcmV2aW91c0NoZWNrcyB8fCBbXTtcblxuICAgIHZhciBmaW5hbENoZWNrID0gcC5wcmV2aW91c0F0dGVtcHRzID4gMztcbiAgICB2YXIgdG9wID0gdm9pZCAwO1xuICAgIHZhciBsZWZ0ID0gdm9pZCAwO1xuXG4gICAgLy8gWS1heGlzIGNoZWNrXG4gICAgc3dpdGNoIChwLmFuY2hvclkpIHtcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRvcCA9IHAudGFyZ2V0VG9wICsgcC50YXJnZXRIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgLSAocC5lbEhlaWdodCAtIHAudGFyZ2V0SGVpZ2h0KSAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgLSBwLmVsSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVbmRlciBtaW5cbiAgICBpZiAodG9wIDwgcC5taW5ZKSB7XG5cbiAgICAgIGlmICghZmluYWxDaGVjayAmJiBwLnByZXZpb3VzQ2hlY2tzLmluZGV4T2YoJ292ZXJZJykgPT09IC0xKSB7XG4gICAgICAgIHAucHJldmlvdXNDaGVja3MucHVzaCgndW5kZXJZJyk7XG4gICAgICAgIHAuYW5jaG9yWSA9IHRoaXMuX2dldE5ld0FuY2hvclkodHJ1ZSwgcC5hbmNob3JZLCBwLmFuY2hvclgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBwLm1pblk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgY2hlY2sgZm9yIGJlaW5nIHRvbyB0YWxsIGJlY2F1c2UgY2F1c2luZyBhIHZlcnRpY2FsIHNjcm9sbFxuICAgIC8vIGJhciBkb3duIGlzIG9rYXkgYW5kIHRoaXMgc2F2ZXMgdXMgZnJvbSBzb21lIHJlYWwgcG9zaXRpb25pbmcgaGVsbC5cbiAgICAvKmlmICh0b3AgPiBwLm1heFkpIHtcbiAgICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCd1bmRlclknKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCdvdmVyWScpO1xuICAgICAgICBwLmFuY2hvclkgPSB0aGlzLl9nZXROZXdBbmNob3JZKGZhbHNlLCBwLmFuY2hvclksIHAuYW5jaG9yWCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH1cbiAgICAgIC8vIE9uIGEgZmluYWwgY2hlY2ssIGJvdHRvbSB3aW5zIGJlY2F1c2UgYXQgbGVhc3Qgd2UgY2FuIHNjcm9sbFxuICAgICAgZWxzZSBpZiAoIShmaW5hbENoZWNrICYmIHAuYW5jaG9yWSA9PT0gJ2JvdHRvbScpKSB7XG4gICAgICAgIHRvcCA9IHAubWF4WTtcbiAgICAgIH1cbiAgICB9Ki9cblxuICAgIC8vIFgtYXhpcyBjaGVja1xuICAgIHN3aXRjaCAocC5hbmNob3JYKSB7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgKyAocC5hbmNob3JZICE9PSAnbWlkZGxlJyAmJiAhcC5pc092ZXJsYXBwaW5nID8gMCA6IHAudGFyZ2V0V2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgLSAocC5lbFdpZHRoIC0gcC50YXJnZXRXaWR0aCkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlZnQgPSBwLnRhcmdldExlZnQgLSBwLmVsV2lkdGggKyAocC5hbmNob3JZICE9PSAnbWlkZGxlJyA/IHAudGFyZ2V0V2lkdGggOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVW5kZXIgbWluXG4gICAgaWYgKGxlZnQgPCBwLm1pblgpIHtcblxuICAgICAgaWYgKCFmaW5hbENoZWNrICYmIHAucHJldmlvdXNDaGVja3MuaW5kZXhPZignb3ZlclgnKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCd1bmRlclgnKTtcbiAgICAgICAgcC5hbmNob3JYID0gdGhpcy5fZ2V0TmV3QW5jaG9yWCh0cnVlLCBwLmFuY2hvclgsIHAuYW5jaG9yWSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwLm1pblg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlciBtYXhcbiAgICBpZiAobGVmdCA+IHAubWF4WCkge1xuXG4gICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCd1bmRlclgnKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCdvdmVyWCcpO1xuICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKGZhbHNlLCBwLmFuY2hvclgsIHAuYW5jaG9yWSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBwLm1heFg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT25lIGVsZW1lbnQgaXMgY292ZXJpbmcgYW5vdGhlci4gVHJ5IHRvIGZpeCB0aGF0LCBidXQgYmFpbCBvdXQgYWZ0ZXIgZm91ciB0cmllcy5cbiAgICBpZiAoKDAsIF9ib3hQb3NpdGlvbjIuZGVmYXVsdCkoeyB3aWR0aDogcC5lbFdpZHRoLCBoZWlnaHQ6IHAuZWxIZWlnaHQsIGxlZnQ6IGxlZnQsIHRvcDogdG9wIH0sIHsgd2lkdGg6IHAudGFyZ2V0V2lkdGgsIGhlaWdodDogcC50YXJnZXRIZWlnaHQsIGxlZnQ6IHAudGFyZ2V0TGVmdCwgdG9wOiBwLnRhcmdldFRvcCB9KSA9PT0gJ292ZXJsYXAnKSB7XG5cbiAgICAgIHAuaXNPdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgIC8vIFRyeSBZXG4gICAgICBpZiAocC5yZXBvc2l0aW9uWSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAvLyBXaWxsIHN0YXJ0IHVuZGVmaW5lZCwgdGhlbiB0cnVlLCB0aGVuIGZhbHNlLiBUaGlzIGxpbWl0cyB1cyB0byBlbnRlcmluZ1xuICAgICAgICAvLyB0aGlzIGxvb3AgdHdpY2UsIG9uY2UgdG8gdHJ5IG1vdmluZyBpbiBlYWNoIGRpcmVjdGlvbi5cbiAgICAgICAgcC5yZXBvc2l0aW9uWSA9ICFwLnJlcG9zaXRpb25ZO1xuXG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBwdXQgYWJvdmUsIHRoZW4gdHJ5IHRvIHB1dCBiZWxvdy5cbiAgICAgICAgcC5hbmNob3JZID0gdGhpcy5fZ2V0TmV3QW5jaG9yWShwLnJlcG9zaXRpb25ZLCAnbWlkZGxlJywgcC5hbmNob3JYKTtcblxuICAgICAgICAvLyBHaXZlIHVzIG9uZSBtb3JlIHNob3QgYXQgcG9zaXRpb25pbmdcbiAgICAgICAgcC5wcmV2aW91c0F0dGVtcHRzLS07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IFhcbiAgICAgIGVsc2UgaWYgKHAucmVwb3NpdGlvblggIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAvLyBXaWxsIHN0YXJ0IHVuZGVmaW5lZCwgdGhlbiB0cnVlLCB0aGVuIGZhbHNlLiBUaGlzIGxpbWl0cyB1cyB0byBlbnRlcmluZ1xuICAgICAgICAgIC8vIHRoaXMgbG9vcCB0d2ljZSwgb25jZSB0byB0cnkgbW92aW5nIGluIGVhY2ggZGlyZWN0aW9uLlxuICAgICAgICAgIHAucmVwb3NpdGlvblggPSAhcC5yZXBvc2l0aW9uWDtcblxuICAgICAgICAgIC8vIEZpcnN0IHRyeSB0byBwdXQgYWJvdmUsIHRoZW4gdHJ5IHRvIHB1dCBiZWxvdy5cbiAgICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKHAucmVwb3NpdGlvblgsICdjZW50ZXInLCBwLmFuY2hvclkpO1xuXG4gICAgICAgICAgLy8gR2l2ZSB1cyBvbmUgbW9yZSBzaG90IGF0IHBvc2l0aW9uaW5nXG4gICAgICAgICAgcC5wcmV2aW91c0F0dGVtcHRzLS07XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBlbFRvcDogdG9wLCBlbExlZnQ6IGxlZnQsIGFuY2hvclg6IHAuYW5jaG9yWCwgYW5jaG9yWTogcC5hbmNob3JZIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbmV3IHktYXhpcyBhbmNob3JcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdW5kZXJNaW4gVW5kZXIgdGhlIG1pbj9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JZXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXROZXdBbmNob3JZID0gZnVuY3Rpb24gX2dldE5ld0FuY2hvclkodW5kZXJNaW4sIGFuY2hvclksIGFuY2hvclgpIHtcblxuICAgIC8vIElmIHRoZSB4LWF4aXMgaXMgYW5jaG9yZWQgaW4gdGhlIGNlbnRlciwgc2tpcFxuICAgIC8vIHRyeWluZyB0byBhbmNob3IgdG8gdGhlIG1pZGRsZSBiZWNhdXNlIHRoZW4gd2UnZFxuICAgIC8vIGJlIG92ZXJsYXlpbmcgdGhlIGJ1dHRvbi5cbiAgICBpZiAoYW5jaG9yWCA9PT0gJ2NlbnRlcicgfHwgYW5jaG9yWSA9PT0gJ21pZGRsZScpIHtcbiAgICAgIHJldHVybiB1bmRlck1pbiA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnbWlkZGxlJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgbmV3IHktYXhpcyBhbmNob3JcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdW5kZXJNaW4gVW5kZXIgdGhlIG1pbj9cbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JZXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYW5jaG9yWFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9nZXROZXdBbmNob3JYID0gZnVuY3Rpb24gX2dldE5ld0FuY2hvclgodW5kZXJNaW4sIGFuY2hvclgsIGFuY2hvclkpIHtcblxuICAgIC8vIElmIHRoZSB5LWF4aXMgaXMgYW5jaG9yZWQgaW4gdGhlIGNlbnRlciwgc2tpcFxuICAgIC8vIHRyeWluZyB0byBhbmNob3IgdG8gdGhlIG1pZGRsZSBiZWNhdXNlIHRoZW4gd2UnZFxuICAgIC8vIGJlIG92ZXJsYXlpbmcgdGhlIGJ1dHRvbi5cbiAgICBpZiAoYW5jaG9yWSA9PT0gJ21pZGRsZScgfHwgYW5jaG9yWCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHJldHVybiB1bmRlck1pbiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGNhcmV0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9wb3NpdGlvbkNhcmV0ID0gZnVuY3Rpb24gX3Bvc2l0aW9uQ2FyZXQoKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cbiAgICBpZiAoIXRoaXMuY2FyZXRFbCkgcmV0dXJuO1xuXG4gICAgdmFyIGNhcmV0UG9zaXRpb24gPSAoMCwgX2JveFBvc2l0aW9uMi5kZWZhdWx0KSh7IHdpZHRoOiBwLmVsV2lkdGgsIGhlaWdodDogcC5lbEhlaWdodCwgbGVmdDogcC5lbExlZnQsIHRvcDogcC5lbFRvcCB9LCB7IHdpZHRoOiBwLnRhcmdldFdpZHRoLCBoZWlnaHQ6IHAudGFyZ2V0SGVpZ2h0LCBsZWZ0OiBwLnRhcmdldExlZnQsIHRvcDogcC50YXJnZXRUb3AgfSk7XG5cbiAgICB2YXIgY2FyZXREaW1lbnNpb25zID0gdGhpcy5jYXJldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjYXJldFdpZHRoID0gY2FyZXREaW1lbnNpb25zLndpZHRoO1xuICAgIHZhciBjYXJldEhlaWdodCA9IGNhcmV0RGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbihwLmVsV2lkdGgsIE1hdGgubWF4KDAsIHAudGFyZ2V0TGVmdCAtIHAuZWxMZWZ0ICsgcC50YXJnZXRXaWR0aCAvIDIpKTtcbiAgICB2YXIgdG9wID0gTWF0aC5taW4ocC5lbEhlaWdodCwgTWF0aC5tYXgoMCwgcC50YXJnZXRUb3AgLSBwLmVsVG9wICsgcC50YXJnZXRIZWlnaHQgLyAyKSk7XG5cbiAgICB0aGlzLmNhcmV0RWwuc3R5bGUubGVmdCA9IE1hdGgucm91bmQobGVmdCkgKyAncHgnO1xuICAgIHRoaXMuY2FyZXRFbC5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHRvcCkgKyAncHgnO1xuXG4gICAgdmFyIGV4dHJhTGVmdCA9IDA7XG4gICAgdmFyIGV4dHJhVG9wID0gMDtcblxuICAgIHRoaXMuY2FyZXRFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zaXRpb24nLCBjYXJldFBvc2l0aW9uKTtcblxuICAgIHN3aXRjaCAoY2FyZXRQb3NpdGlvbikge1xuICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICBleHRyYVRvcCA9IC1jYXJldFdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgIGV4dHJhVG9wID0gY2FyZXRXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGV4dHJhTGVmdCA9IC1jYXJldEhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXh0cmFMZWZ0ID0gY2FyZXRIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXh0cmFMZWZ0OiBleHRyYUxlZnQsXG4gICAgICBleHRyYVRvcDogZXh0cmFUb3BcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJvb3QgZWxlbWVudC4gV2FudCB0byBjaGVjayBpZiB0aGVyZSdzIGEgdG9wLWxldmVsIGZvcm0gZm9yIHdvcmtpbmdcbiAgICogd2l0aCBBU1AgLk5FVCBwYWdlcy5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2dldFJvb3RFbCA9IGZ1bmN0aW9uIF9nZXRSb290RWwoKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5ID4gZm9ybScpO1xuICAgIHJldHVybiBmb3JtICYmIGZvcm0uZ2V0QXR0cmlidXRlKCdkYXRhLWFmZml4ZWQnKSA9PT0gbnVsbCA/IGZvcm0gOiBkb2N1bWVudC5ib2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBPbiByZXNpemUsIHVwZGF0ZSB0aGUgcG9zaXRpb24uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB3aW5kb3cgc2Nyb2xscywgZW5zdXJlIHRoZSBwcm9wZXIgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgICB0aGlzLl91cGRhdGVEZWJvdW5jZWQoKTtcbiAgfTtcblxuICByZXR1cm4gQWZmaXg7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFmZml4O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZmZpeC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICB2YXIgYVhTcGFuID0gYS5sZWZ0ICsgYS53aWR0aDtcbiAgdmFyIGFZU3BhbiA9IGEudG9wICsgYS5oZWlnaHQ7XG4gIHZhciBiWFNwYW4gPSBiLmxlZnQgKyBiLndpZHRoO1xuICB2YXIgYllTcGFuID0gYi50b3AgKyBiLmhlaWdodDtcblxuICBpZiAoYVhTcGFuIDw9IGIubGVmdCkgcmV0dXJuICdsZWZ0JzsgLy8gYSBpcyBmdWxseSBsZWZ0IG9mIGJcbiAgaWYgKGEubGVmdCA+PSBiWFNwYW4pIHJldHVybiAncmlnaHQnOyAvLyBhIGlzIGZ1bGx5IHJpZ2h0IG9mIGJcbiAgaWYgKGFZU3BhbiA8PSBiLnRvcCkgcmV0dXJuICdhYm92ZSc7IC8vIGEgaXMgZnVsbHkgYWJvdmUgYlxuICBpZiAoYS50b3AgPj0gYllTcGFuKSByZXR1cm4gJ2JlbG93JzsgLy8gYSBpcyBmdWxseSBiZWxvdyBiXG5cbiAgcmV0dXJuICdvdmVybGFwJzsgLy8gYm94ZXMgb3ZlcmxhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgQm94IFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSG93IGlzIG9uZSBlbGVtZW50IHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gYW5vdGhlcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYm94UG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoge3dpZHRoOiAxMDAsIGhlaWdodDogMzAwLCBsZWZ0OiAwLCB0b3A6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHt3aWR0aDogMjAwLCBoZWlnaHQ6IDUwLCBsZWZ0OiAxMDAsIHRvcDogNDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL3Bvc2l0aW9uL2JveC1wb3NpdGlvbi5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJveC1wb3NpdGlvbi5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRjaGVzID0gcmVxdWlyZSgnLi9tYXRjaGVzJyk7XG5cbnZhciBfbWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KHBhcmVudCwgcXVlcnksIGxpbWl0RWwpIHtcblxuICBsaW1pdEVsID0gbGltaXRFbCBpbnN0YW5jZW9mIEFycmF5ID8gbGltaXRFbCA6IFtsaW1pdEVsIHx8IGRvY3VtZW50LmJvZHldO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcblxuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKHBhcmVudCwgcXVlcnkpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChsaW1pdEVsLmluZGV4T2YocGFyZW50KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLyoqXG4gICAqICMgR2V0IFBhcmVudFxuICAgKiBTZWUgaWYgYW4gZWxlbWVudCBoYXMgYW5vdGhlciBlbGVtZW50IGZvciBhIHBhcmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gbGltaXRFbCBUaGUgbGFzdCBlbGVtZW50IHdlIHNob3VsZCBjaGVjay5cbiAgICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fVxuICAgKlxuICAgKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL2dldC1wYXJlbnQuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFBhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXBhcmVudC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRjaGVzID0gcmVxdWlyZSgnLi9tYXRjaGVzJyk7XG5cbnZhciBfbWF0Y2hlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0U2libGluZ0FmdGVyKGVsLCBxdWVyeSkge1xuXG4gIHdoaWxlIChlbCA9IGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKGVsLCBxdWVyeSkpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLyoqXG4gICAqICMgR2V0IFNpYmxpbmcgQWZ0ZXJcbiAgICogR2V0IGEgbmVhcmVzdCBzaWJsaW5nIGFmdGVyIHRoZSBnaXZlbiBlbGVtZW50IHdoaWNoIG1hdGNoZXNcbiAgICogdGhlIGdpdmVuIHF1ZXJ5IHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fE51bGx9XG4gICAqXG4gICAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvZ2V0LXNpYmxpbmctYWZ0ZXIuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFNpYmxpbmdBZnRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXNpYmxpbmctYWZ0ZXIuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0Y2hlcyA9IHJlcXVpcmUoJy4vbWF0Y2hlcycpO1xuXG52YXIgX21hdGNoZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdCZWZvcmUoZWwsIHF1ZXJ5KSB7XG5cbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmICgoMCwgX21hdGNoZXMyLmRlZmF1bHQpKGVsLCBxdWVyeSkpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLyoqXG4gICAqICMgR2V0IFNpYmxpbmcgQmVmb3JlXG4gICAqIEdldCBhIG5lYXJlc3Qgc2libGluZyBiZWZvcmUgdGhlIGdpdmVuIGVsZW1lbnQgd2hpY2ggbWF0Y2hlc1xuICAgKiB0aGUgZ2l2ZW4gcXVlcnkgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAqIEByZXR1cm4ge0VsZW1lbnR8TnVsbH1cbiAgICpcbiAgICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9nZXQtc2libGluZy1iZWZvcmUuanNcbiAgICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFNpYmxpbmdCZWZvcmU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaWJsaW5nLWJlZm9yZS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEhhcyBQYXJlbnRcbiAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhbm90aGVyIGVsZW1lbnQgZm9yIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9zc2libGVQYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChjaGlsZCwgcG9zc2libGVQYXJlbnQpIHtcblxuICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50KSB7XG5cbiAgICBpZiAocGFyZW50ID09PSBwb3NzaWJsZVBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGhhc1BhcmVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtcGFyZW50LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIE1hdGNoZXNcbiAqIFNlZSBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBxdWVyeSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzXG4gKi9cbnZhciB2ZW5kb3JNYXRjaCA9IHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yKTtcblxuZnVuY3Rpb24gbWF0Y2hlcyhlbCwgcXVlcnkpIHtcblxuICBpZiAodmVuZG9yTWF0Y2gpIHJldHVybiB2ZW5kb3JNYXRjaC5jYWxsKGVsLCBxdWVyeSk7XG5cbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZSA/IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkgOiBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoZXMuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBEZWJvdW5jZVxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBjYWxsXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtJbnRlZ2VyfSBkZWxheVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2RlYm91bmNlLmpzXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIGRlbGF5KSB7XG5cbiAgdmFyIHRpbWVyID0gdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHRpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSwgZGVsYXkpO1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWJvdW5jZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBFYWNoXG4gKiBBcHBseSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBhbnkga2luZDogQXJyYXksIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiBvciBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheXxOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbnxPYmplY3R9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKlxuICogQGV4YW1wbGVcbiAqIGVhY2goW10sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGROb2RlcywgY2FsbGJhY2spO1xuICogZWFjaCh7fSwgY2FsbGJhY2spO1xuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2VhY2guanNcbiAqL1xuZnVuY3Rpb24gZWFjaChsaXN0LCBjYikge1xuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYGVhY2hgIHdpdGhvdXQgYSBjYWxsYmFjayEnKTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIC8vIE9iamVjdFxuICBpZiAobGVuID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGkgaW4gbGlzdCkge1xuICAgICAgaWYgKGkgIT09ICdwcm90b3R5cGUnICYmIGxpc3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2IoaSwgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFycmF5LWxpa2VcbiAgZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNiKGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZWFjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFjaC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBQYWRcbiAqIFBhZCBhIG51bWJlciB3aXRoIGxlYWRpbmcgemVyb3NcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAqIEBwYXJhbSB7U3RyaW5nfSBjIE9wdGlvbmFsIFN0cmluZyB0byBwYWQgd2l0aFxuICpcbiAqIEBleGFtcGxlXG4gKiBwYWQoNCwgMik7XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvcGFkLmpzXG4gKi9cbmZ1bmN0aW9uIHBhZChuLCB3LCBjKSB7XG4gIGMgPSBjIHx8ICcwJztcbiAgbiA9IG4gKyAnJztcbiAgcmV0dXJuIG4ubGVuZ3RoID49IHcgPyBuIDogbmV3IEFycmF5KHcgLSBuLmxlbmd0aCArIDEpLmpvaW4oYykgKyBuO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYWQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFJhbmdlXG4gKiBDcmVhdGUgYSByYW5nZSBvZiBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0b3BcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwIE9wdGlvbmFsXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdXRpbC9yYW5nZS5qc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmICghc3RlcCkge1xuICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVSYW5nZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBUcmltXG4gKiBUcmltIHdoaXRlc3BhY2Ugb24gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL3RyaW0uanNcbiAqL1xuXG52YXIgdHJpbVJFID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodHJpbVJFLCAnJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW0uanMubWFwXG4iXX0="}