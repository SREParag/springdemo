{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/popover.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/offset.js","js/dist/components/js/dist/helpers/dom/parse-attribute.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/dom/toggle-class.js","js/dist/components/js/dist/helpers/manipulation/append-children.js","js/dist/components/js/dist/helpers/position/affix.js","js/dist/components/js/dist/helpers/position/box-position.js","js/dist/components/js/dist/helpers/traversal/get-parent.js","js/dist/components/js/dist/helpers/traversal/has-parent.js","js/dist/components/js/dist/helpers/traversal/matches.js","js/dist/components/js/dist/helpers/util/debounce.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"popover.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _toggleClass = require('../helpers/dom/toggle-class');\n\nvar _toggleClass2 = _interopRequireDefault(_toggleClass);\n\nvar _appendChildren = require('../helpers/manipulation/append-children');\n\nvar _appendChildren2 = _interopRequireDefault(_appendChildren);\n\nvar _hasParent = require('../helpers/traversal/has-parent');\n\nvar _hasParent2 = _interopRequireDefault(_hasParent);\n\nvar _getParent = require('../helpers/traversal/get-parent');\n\nvar _getParent2 = _interopRequireDefault(_getParent);\n\nvar _parseAttribute = require('../helpers/dom/parse-attribute');\n\nvar _affix = require('../helpers/position/affix');\n\nvar _affix2 = _interopRequireDefault(_affix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Popover\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Show and hide a popover. Should do some sanity checks on positioning as well.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new Popover(el, {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   // Optional. Default anchoring of the content's x and y-axis relative to the button.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorX: 'center', // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *   defaultAnchorY: 'center' // 'left', 'center', 'right'\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * });\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/popover.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar Popover = function (_BaseComponent) {\n  _inherits(Popover, _BaseComponent);\n\n  function Popover(el) {\n    var _ret;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Popover);\n\n    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params));\n\n    if (!el) return _ret = _this, _possibleConstructorReturn(_this, _ret);\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    return _this;\n  }\n\n  /**\n   * Open.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.open = function open() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // If there is a timer running for the close event, clear it so it\n    // doesn't close stuff during open.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // If the element we anchor the popover to is fixed, we need to know\n    // so that the affixed content can also be fixed.\n    this._checkFixedPosition();\n\n    // Update an existing affixed instance.\n    if (this.affix) {\n      this.affix.targetEl = params.affixTo || this.affix.targetEl;\n      this.affix.update();\n    }\n    // Affix the content to the toggle\n    else {\n        this.affix = new _affix2.default({\n          el: this.contentEl,\n          targetEl: params.affixTo || this.el,\n          caretEl: this.caretEl,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          isFixed: this.isFixed\n        });\n      }\n\n    // Listen for clicks on the window\n    this._addWindowEventListeners();\n\n    this.isActive = true;\n\n    // Dispatch a custom event so content inside the popover can respond\n    var e = document.createEvent('Event');\n    e.initEvent('spark.visible-children', true, true);\n    this.contentEl.dispatchEvent(e);\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Callbacks\n    (params.complete || noop)();\n    (this.onOpen || noop)();\n\n    return this;\n  };\n\n  /**\n   * Close.\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.close = function close() {\n    var _this2 = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    // Not open, so don't close.\n    if (!this.affix) return this;\n\n    // If there is a timer running for the close event, clear it so we don't run close stuff twice.\n    if (this.closeTimer) {\n      clearTimeout(this.closeTimer);\n      this.closeTimer = null;\n    }\n\n    // Stop listening to window clicks.\n    this._removeWindowEventListeners();\n\n    this.isActive = false;\n\n    // Update bindings\n    this._updateAttributes();\n\n    // Close after the animation has completed\n    this.closeTimer = setTimeout(function () {\n      _this2._finishClose(params);\n    }, 250);\n\n    return this;\n  };\n\n  /**\n   * Toggle the open state.\n   */\n\n\n  Popover.prototype.toggle = function toggle() {\n    return this[this.isActive ? 'close' : 'open']();\n  };\n\n  /**\n   * Set the content. Optionally append instead of replacing.\n   * @param {Element|Array|NodeList} content\n   * @param {Object} params Optional\n   */\n\n\n  Popover.prototype.setContent = function setContent(content, params) {\n    params = params || {};\n    (0, _appendChildren2.default)(this.contentEl, content.length ? content : [content], !(params.append || false));\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  Popover.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._addEventListeners();\n\n    if (this.affix) this.affix.update();\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the tabs list, each tab and each panel.\n   * Set which tab is active, or use the first.\n   * @param {Element} el\n   */\n\n\n  Popover.prototype._cacheElements = function _cacheElements(el) {\n\n    // If a content element was already passed, make sure it has a popover content class\n    if (this.contentEl) {\n      (0, _addClass2.default)(this.contentEl, 'spark-popover__content');\n    }\n\n    this.el = el;\n    this.toggleEl = this.el.querySelector('.spark-popover__toggle, [data-role=\"toggle\"]') || this.el;\n    this.contentEl = this.contentEl || this.el.querySelector('.spark-popover__content, [class*=\"spark-popover__content--\"]') || this._createContentEl();\n    this.caretEl = this.contentEl.querySelector('.spark-popover__caret') || this._createCaretEl();\n    this.isActive = (0, _hasClass2.default)(this.toggleEl, 'popover-active');\n  };\n\n  /**\n   * Parse config values from the element.\n   */\n\n\n  Popover.prototype._parseParams = function _parseParams() {\n\n    this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-y', null);\n    this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-x', null);\n\n    // No anchors defined\n    if (!this.anchorY && !this.anchorX) {\n\n      // Left\n      if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--left')) {\n        this.anchorY = 'middle';\n        this.anchorX = 'left';\n      }\n      // Right\n      else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--right')) {\n          this.anchorY = 'middle';\n          this.anchorX = 'right';\n        }\n        // Top\n        else if ((0, _hasClass2.default)(this.contentEl, 'spark-popover__content--top')) {\n            this.anchorY = 'top';\n            this.anchorX = 'center';\n          }\n          // Bottom\n          else {\n              this.anchorY = 'bottom';\n              this.anchorX = 'center';\n            }\n    }\n  };\n\n  /**\n   * Check to see if the button triggering the popover is fixed.\n   * If so, then popover needs to be fixed as well.\n   */\n\n\n  Popover.prototype._checkFixedPosition = function _checkFixedPosition() {\n\n    var parent = this.el;\n\n    while (parent && parent !== document) {\n      var style = getComputedStyle(parent);\n      if (style.position === 'fixed') {\n        return this.isFixed = true;\n      }\n      parent = parent.parentNode;\n    }\n\n    return this.isFixed = false;\n  };\n\n  /**\n   * Update classes for the open or close state.\n   */\n\n\n  Popover.prototype._updateAttributes = function _updateAttributes() {\n    (0, _toggleClass2.default)(this.el, 'popover-active', this.isActive);\n    (0, _toggleClass2.default)(this.contentEl, 'active', this.isActive);\n    (0, _toggleClass2.default)(this.toggleEl, 'active', this.isActive);\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  Popover.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onClickBound = this._onClick.bind(this);\n    this._onContentClickBound = this._onContentClick.bind(this);\n    this._onWindowClickBound = this._onWindowClick.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  Popover.prototype._addEventListeners = function _addEventListeners() {\n    this.el.addEventListener('click', this._onClickBound);\n    this.contentEl.addEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  Popover.prototype._removeEventListeners = function _removeEventListeners() {\n    this.el.removeEventListener('click', this._onClickBound);\n    this.contentEl.removeEventListener('click', this._onContentClickBound);\n  };\n\n  /**\n   * Add event listeners to the window.\n   */\n\n\n  Popover.prototype._addWindowEventListeners = function _addWindowEventListeners() {\n    this._removeWindowEventListeners();\n    window.addEventListener('click', this._onWindowClickBound);\n  };\n\n  /**\n   * Remove window event listeners.\n   */\n\n\n  Popover.prototype._removeWindowEventListeners = function _removeWindowEventListeners() {\n    window.removeEventListener('click', this._onWindowClickBound);\n  };\n\n  /**\n   * Create a content element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createContentEl = function _createContentEl() {\n    var el = document.createElement('div');\n    (0, _addClass2.default)(el, 'spark-popover__content');\n    el.setAttribute('role', 'tooltip');\n    return el;\n  };\n\n  /**\n   * Create the caret element.\n   * @return {Element}\n   */\n\n\n  Popover.prototype._createCaretEl = function _createCaretEl() {\n    var el = document.createElement('div');\n    el.className = 'spark-popover__caret';\n    this.contentEl.appendChild(el);\n    return el;\n  };\n\n  /**\n   * Complete the close event by moving the element back and destroying the affix.\n   * @param  {Object} params\n   */\n\n\n  Popover.prototype._finishClose = function _finishClose() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    this.closeTimer = null;\n\n    // Move the content back to the parent\n    this.el.appendChild(this.contentEl);\n\n    this.affix.remove({ keepEl: true });\n    this.affix = null;\n\n    (params.complete || noop)();\n    (this.onClose || noop)();\n  };\n\n  /**\n   * When we are clicked, toggle the popover-active state.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onClick = function _onClick(e) {\n\n    // If this is the toggle element, toggle.\n    if (e.target === this.toggleEl || (0, _hasParent2.default)(e.target, this.toggleEl)) {\n      e.preventDefault();\n      this.toggle();\n      return;\n    }\n  };\n\n  /**\n   * When the toggle is clicked, close if it's a link. If it's content, don't do anything but stop\n   * the event from bubbling.\n   * @param {Object} e\n   */\n\n\n  Popover.prototype._onContentClick = function _onContentClick(e) {\n\n    // If this is a link, close.\n    if ((0, _getParent2.default)(e.target, '.spark-popover__list-link', this.contentEl) || (0, _getParent2.default)(e.target, '.spark-popover__close', this.contentEl)) {\n      this.close();\n      return;\n    }\n  };\n\n  /**\n   * When the window is clicked and it's not part of the popover, close the popover.\n   * @param {Objec} e\n   */\n\n\n  Popover.prototype._onWindowClick = function _onWindowClick(e) {\n\n    if (e.target !== this.el && !(0, _hasParent2.default)(e.target, this.el) && !(0, _hasParent2.default)(e.target, this.contentEl)) {\n      this.close();\n    }\n  };\n\n  return Popover;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nPopover.prototype._whitelistedParams = ['anchorX', 'anchorY', 'toggleEl', 'contentEl', 'onOpen', 'onClose'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nPopover.prototype.defaults = {\n  el: null,\n  toggleEl: null,\n  contentEl: null,\n  caretEl: null,\n  affix: null,\n  isActive: false,\n  isPaused: false,\n  isFixed: false,\n  anchorX: null,\n  anchorY: null,\n  closeTimer: null,\n  onOpen: null,\n  onClose: null,\n  _onClickBound: null,\n  _onContentClickBound: null,\n  _onWindowClickBound: null,\n  _onWindowResizeBound: null,\n  _onWindowScrollBound: null\n};\n\nexports.default = Popover;\nmodule.exports = exports['default'];\n//# sourceMappingURL=popover.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Offset Position\n * Get the offset position of the element.\n *\n * @param {Element} el\n * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.\n * @return {Object}\n *\n * @module helpers/dom/offset.js\n */\nfunction offset(el, viewPortOffset) {\n\n  var rect = {\n    top: 0,\n    left: 0\n  };\n\n  // Native implementation\n  if (el.getBoundingClientRect) {\n\n    var bounding = el.getBoundingClientRect();\n    rect.left = bounding.left;\n    rect.top = bounding.top;\n\n    if (!viewPortOffset) {\n      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;\n      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;\n    }\n  } else {\n    var x = 0,\n        y = 0;\n    do {\n      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);\n      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);\n    } while (el = el.offsetParent);\n\n    rect.left = x;\n    rect.top = y;\n  }\n\n  return rect;\n}\n\nexports.default = offset;\nmodule.exports = exports['default'];\n//# sourceMappingURL=offset.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Parse DOM attributes\n * Given an element and an attribute name, parse that attribute\n * if it exists or return a default.\n *\n * @module helpers/dom/parse-attribute.js\n */\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction boolean(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val === 'true' || val === '' ? true : false;\n}\n\n/**\n * Get the numeric value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction number(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return parseInt(val, 10);\n}\n\n/**\n * Get the boolean value of an attribute on an element,\n * falling back to the default value.\n * @param  {Element} el\n * @param  {String} name\n * @param  {Boolean} def\n * @return {Boolean}\n */\nfunction string(el, name, def) {\n  var val = el.getAttribute(name);\n  if (val === null) return def;\n  return val;\n}\n\nexports.boolean = boolean;\nexports.number = number;\nexports.string = string;\n//# sourceMappingURL=parse-attribute.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nvar _addClass = require('./add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('./remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toggleClass(el, name, enable) {\n\n  if (!el) {\n    return;\n  }\n\n  // If we're passed an array, toggle the class on each.\n  if (el instanceof NodeList || el instanceof Array) {\n\n    for (var i = 0, len = el.length; i < len; i++) {\n      toggleClass(el[i], name, enable);\n    }\n\n    return;\n  }\n\n  var action = void 0;\n  if (enable !== undefined) {\n    enable = typeof enable === 'function' ? enable.call(null, el) : enable;\n    action = enable ? 'add' : 'remove';\n  } else {\n    action = (0, _hasClass2.default)(el, name) ? 'remove' : 'add';\n  }\n\n  return (action === 'add' ? _addClass2.default : _removeClass2.default)(el, name);\n} /**\n   * # Toggle Class\n   * Toggle a class on an element given a condition.\n   *\n   * @param {Element|Array} el An element or array of elements to update.\n   * @param {String} name\n   * @param {Boolean} enable\n   * @return {Element}\n   *\n   * @module  helpers/dom/toggle-class.js\n   */\n\nexports.default = toggleClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=toggle-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction appendChildren(el, children, empty) {\n\n  empty = empty === undefined ? false : empty;\n\n  if (empty) {\n    el.textContent = '';\n  }\n\n  var domList = children instanceof window.HTMLCollection;\n\n  if (domList) {\n    while (children.length) {\n      el.appendChild(children[0]);\n    }\n  } else {\n    (0, _each2.default)(children, function (c) {\n      if (c) {\n        el.appendChild(c);\n      }\n    });\n  }\n} /**\n   * # Append Children\n   * Append an array of children to a node.\n   *\n   * @param {Element} el\n   * @param {Array} children\n   * @param {Boolean} empty Empty the node before adding children?\n   *\n   * @module helpers/manipulation/append-children.js\n   */\n\nexports.default = appendChildren;\nmodule.exports = exports['default'];\n//# sourceMappingURL=append-children.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offset2 = require('../dom/offset');\n\nvar _offset3 = _interopRequireDefault(_offset2);\n\nvar _boxPosition = require('./box-position');\n\nvar _boxPosition2 = _interopRequireDefault(_boxPosition);\n\nvar _debounce = require('../util/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Affix\n                                                                                                                                                           * Affix one element to another.\n                                                                                                                                                           *\n                                                                                                                                                           * @example\n                                                                                                                                                           * new Affix({\n                                                                                                                                                           *   el: el,\n                                                                                                                                                           *   targetEl: el2,\n                                                                                                                                                           *   caretEl: el3,\n                                                                                                                                                           *   anchorY: 'top', // 'middle', 'bottom'\n                                                                                                                                                           *   anchorX: 'left', // 'center', 'right'\n                                                                                                                                                           * })\n                                                                                                                                                           *\n                                                                                                                                                           * @module helpers/position/affix.js\n                                                                                                                                                           */\n\nvar Affix = function () {\n\n  /**\n   * Store the reference elements and position.\n   * @param  {Object} params\n   */\n  function Affix() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Affix);\n\n    this.el = params.el;\n    this.targetEl = params.targetEl;\n    this.caretEl = params.caretEl;\n    this.anchorY = params.anchorY || 'top';\n    this.anchorX = params.anchorX || 'center';\n    this.isFixed = params.isFixed || false;\n\n    this._addEventListeners();\n    this._insertEl();\n    this._setPosition();\n    this._updateDebounced = (0, _debounce2.default)(this.update.bind(this), 500);\n  }\n\n  /**\n   * Stop listening and clean up event listeners\n   * @param {Object} params Optional\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.remove = function remove() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!params.keepEl) this._removeEl();\n    this._removeEventListeners();\n    return this;\n  };\n\n  /**\n   * Update the position.\n   * @return {Object} this\n   */\n\n\n  Affix.prototype.update = function update() {\n    this._setPosition();\n    return this;\n  };\n\n  /**\n   * Listen for window resizes to update the position.\n   */\n\n\n  Affix.prototype._addEventListeners = function _addEventListeners() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onScrollBound = this._onScroll.bind(this);\n    window.addEventListener('resize', this._onResizeBound);\n    window.addEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Remove event listeners\n   */\n\n\n  Affix.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    window.removeEventListener('scroll', this._onScrollBound);\n  };\n\n  /**\n   * Insert the element into the DOM.\n   */\n\n\n  Affix.prototype._insertEl = function _insertEl() {\n    this.el.setAttribute('data-affixed', '');\n    this._getRootEl().appendChild(this.el);\n  };\n\n  /**\n   * Remove the element from the DOM.\n   */\n\n\n  Affix.prototype._removeEl = function _removeEl() {\n    this.el.parentNode.removeChild(this.el);\n    this.el.removeAttribute('data-affixed');\n  };\n\n  /**\n   * Set the position of the target element.\n   */\n\n\n  Affix.prototype._setPosition = function _setPosition() {\n\n    // Fixed position\n    this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');\n\n    // Target element properties\n\n    var _offset = (0, _offset3.default)(this.targetEl, this.isFixed),\n        targetTop = _offset.top,\n        targetLeft = _offset.left;\n\n    var targetWidth = this.targetEl.offsetWidth;\n    var targetHeight = this.targetEl.offsetHeight;\n\n    // Element to affix properties\n    var elWidth = this.el.offsetWidth;\n    var elHeight = this.el.offsetHeight;\n\n    // Maxes\n    var docHeight = document.documentElement.offsetHeight;\n    var docWidth = document.documentElement.offsetWidth;\n\n    // Get the values\n\n    var _calculatePosition2 = this._calculatePosition({\n      anchorX: this.anchorX,\n      anchorY: this.anchorY,\n      targetTop: targetTop,\n      targetLeft: targetLeft,\n      elHeight: elHeight,\n      elWidth: elWidth,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      minX: 0,\n      minY: 0,\n      maxX: docWidth - elWidth,\n      maxY: Math.max(docHeight - elHeight, 0)\n    }),\n        elTop = _calculatePosition2.elTop,\n        elLeft = _calculatePosition2.elLeft;\n\n    // Position the caret\n\n\n    var _positionCaret2 = this._positionCaret({\n      elLeft: elLeft,\n      elTop: elTop,\n      elWidth: elWidth,\n      elHeight: elHeight,\n      targetHeight: targetHeight,\n      targetWidth: targetWidth,\n      targetLeft: targetLeft,\n      targetTop: targetTop\n    }),\n        extraLeft = _positionCaret2.extraLeft,\n        extraTop = _positionCaret2.extraTop;\n\n    // Set the position\n\n\n    this.el.style.left = elLeft + extraLeft + 'px';\n    this.el.style.top = elTop + extraTop + 'px';\n  };\n\n  /**\n   * Get the proper top position for an anchor direction.\n   * @param  {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._calculatePosition = function _calculatePosition(p) {\n\n    // Keep track of what we're trying to do here, so on subsequent, nested calls to this\n    // method we can see what has already been tried.\n    p.previousAttempts = (p.previousAttempts || 0) + 1;\n    p.previousChecks = p.previousChecks || [];\n\n    var finalCheck = p.previousAttempts > 3;\n    var top = void 0;\n    var left = void 0;\n\n    // Y-axis check\n    switch (p.anchorY) {\n      case 'bottom':\n        top = p.targetTop + p.targetHeight;\n        break;\n      case 'middle':\n        top = p.targetTop - (p.elHeight - p.targetHeight) / 2;\n        break;\n      default:\n        top = p.targetTop - p.elHeight;\n        break;\n    }\n\n    // Under min\n    if (top < p.minY) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {\n        p.previousChecks.push('underY');\n        p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      } else {\n        top = p.minY;\n      }\n    }\n\n    // Don't check for being too tall because causing a vertical scroll\n    // bar down is okay and this saves us from some real positioning hell.\n    /*if (top > p.maxY) {\n       if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {\n        p.previousChecks.push('overY');\n        p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);\n        return this._calculatePosition(p);\n      }\n      // On a final check, bottom wins because at least we can scroll\n      else if (!(finalCheck && p.anchorY === 'bottom')) {\n        top = p.maxY;\n      }\n    }*/\n\n    // X-axis check\n    switch (p.anchorX) {\n      case 'right':\n        left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);\n        break;\n      case 'center':\n        left = p.targetLeft - (p.elWidth - p.targetWidth) / 2;\n        break;\n      default:\n        left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);\n        break;\n    }\n\n    // Under min\n    if (left < p.minX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {\n        p.previousChecks.push('underX');\n        p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.minX;\n      }\n    }\n\n    // Over max\n    if (left > p.maxX) {\n\n      if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {\n        p.previousChecks.push('overX');\n        p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);\n        return this._calculatePosition(p);\n      } else {\n        left = p.maxX;\n      }\n    }\n\n    // One element is covering another. Try to fix that, but bail out after four tries.\n    if ((0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: left, top: top }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop }) === 'overlap') {\n\n      p.isOverlapping = true;\n\n      // Try Y\n      if (p.repositionY !== false) {\n\n        // Will start undefined, then true, then false. This limits us to entering\n        // this loop twice, once to try moving in each direction.\n        p.repositionY = !p.repositionY;\n\n        // First try to put above, then try to put below.\n        p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);\n\n        // Give us one more shot at positioning\n        p.previousAttempts--;\n\n        return this._calculatePosition(p);\n      }\n      // Try X\n      else if (p.repositionX !== false) {\n\n          // Will start undefined, then true, then false. This limits us to entering\n          // this loop twice, once to try moving in each direction.\n          p.repositionX = !p.repositionX;\n\n          // First try to put above, then try to put below.\n          p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);\n\n          // Give us one more shot at positioning\n          p.previousAttempts--;\n\n          return this._calculatePosition(p);\n        }\n    }\n\n    return { elTop: top, elLeft: left, anchorX: p.anchorX, anchorY: p.anchorY };\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorY = function _getNewAnchorY(underMin, anchorY, anchorX) {\n\n    // If the x-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorX === 'center' || anchorY === 'middle') {\n      return underMin ? 'bottom' : 'top';\n    } else {\n      return 'middle';\n    }\n  };\n\n  /**\n   * Determine the new y-axis anchor\n   * @param  {Boolean} underMin Under the min?\n   * @param  {String} anchorY\n   * @param  {String} anchorX\n   * @return {String}\n   */\n\n\n  Affix.prototype._getNewAnchorX = function _getNewAnchorX(underMin, anchorX, anchorY) {\n\n    // If the y-axis is anchored in the center, skip\n    // trying to anchor to the middle because then we'd\n    // be overlaying the button.\n    if (anchorY === 'middle' || anchorX === 'center') {\n      return underMin ? 'left' : 'right';\n    } else {\n      return 'center';\n    }\n  };\n\n  /**\n   * Set the position of the caret.\n   * @param {Object} p\n   * @return {Object}\n   */\n\n\n  Affix.prototype._positionCaret = function _positionCaret() {\n    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n    if (!this.caretEl) return;\n\n    var caretPosition = (0, _boxPosition2.default)({ width: p.elWidth, height: p.elHeight, left: p.elLeft, top: p.elTop }, { width: p.targetWidth, height: p.targetHeight, left: p.targetLeft, top: p.targetTop });\n\n    var caretDimensions = this.caretEl.getBoundingClientRect();\n    var caretWidth = caretDimensions.width;\n    var caretHeight = caretDimensions.height;\n    var left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + p.targetWidth / 2));\n    var top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + p.targetHeight / 2));\n\n    this.caretEl.style.left = Math.round(left) + 'px';\n    this.caretEl.style.top = Math.round(top) + 'px';\n\n    var extraLeft = 0;\n    var extraTop = 0;\n\n    this.caretEl.setAttribute('data-position', caretPosition);\n\n    switch (caretPosition) {\n      case 'above':\n        extraTop = -caretWidth / 2;\n        break;\n      case 'below':\n        extraTop = caretWidth / 2;\n        break;\n      case 'left':\n        extraLeft = -caretHeight / 2;\n        break;\n      default:\n        extraLeft = caretHeight / 2;\n        break;\n    }\n\n    return {\n      extraLeft: extraLeft,\n      extraTop: extraTop\n    };\n  };\n\n  /**\n   * Get the root element. Want to check if there's a top-level form for working\n   * with ASP .NET pages.\n   */\n\n\n  Affix.prototype._getRootEl = function _getRootEl() {\n    var form = document.querySelector('body > form');\n    return form && form.getAttribute('data-affixed') === null ? form : document.body;\n  };\n\n  /**\n   * On resize, update the position.\n   */\n\n\n  Affix.prototype._onResize = function _onResize() {\n    this.update();\n  };\n\n  /**\n   * When the window scrolls, ensure the proper position of the popover.\n   */\n\n\n  Affix.prototype._onScroll = function _onScroll() {\n    this._updateDebounced();\n  };\n\n  return Affix;\n}();\n\nexports.default = Affix;\nmodule.exports = exports['default'];\n//# sourceMappingURL=affix.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (a, b) {\n\n  var aXSpan = a.left + a.width;\n  var aYSpan = a.top + a.height;\n  var bXSpan = b.left + b.width;\n  var bYSpan = b.top + b.height;\n\n  if (aXSpan <= b.left) return 'left'; // a is fully left of b\n  if (a.left >= bXSpan) return 'right'; // a is fully right of b\n  if (aYSpan <= b.top) return 'above'; // a is fully above b\n  if (a.top >= bYSpan) return 'below'; // a is fully below b\n\n  return 'overlap'; // boxes overlap\n};\n\nmodule.exports = exports['default']; /**\n                                      * # Box Position\n                                      * How is one element positioned relative to another?\n                                      *\n                                      * @example\n                                      * boxPosition(\n                                      * {width: 100, height: 300, left: 0, top: 0},\n                                      * {width: 200, height: 50, left: 100, top: 40}\n                                      * )\n                                      *\n                                      * @module helpers/position/box-position.js\n                                      *\n                                      * @param {Object} a\n                                      * @param {Object} b\n                                      * @return {String}\n                                      */\n//# sourceMappingURL=box-position.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _matches = require('./matches');\n\nvar _matches2 = _interopRequireDefault(_matches);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getParent(parent, query, limitEl) {\n\n  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];\n\n  while (parent) {\n\n    if ((0, _matches2.default)(parent, query)) {\n      return parent;\n    }\n\n    if (limitEl.indexOf(parent) !== -1) {\n      return false;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n} /**\n   * # Get Parent\n   * See if an element has another element for a parent.\n   *\n   * @param {Element} parent\n   * @param {String} query\n   * @param {Array|Element} limitEl The last element we should check.\n   * @return {Boolean|Element}\n   *\n   * @module helpers/traversal/get-parent.js\n   */\n\nexports.default = getParent;\nmodule.exports = exports['default'];\n//# sourceMappingURL=get-parent.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Has Parent\n * See if an element has another element for a parent.\n *\n * @param {Element} child\n * @param {Element} possibleParent\n * @return {Boolean}\n *\n * @module helpers/traversal/has-parent.js\n */\nfunction hasParent(child, possibleParent) {\n\n  var parent = child.parentNode;\n\n  while (parent) {\n\n    if (parent === possibleParent) {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n}\n\nexports.default = hasParent;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=has-parent.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Matches\n * See if an element matches a query selector.\n *\n * @param {Element} el\n * @param {String} query\n * @return {Boolean}\n *\n * @module helpers/traversal/matches.js\n */\nvar vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);\n\nfunction matches(el, query) {\n\n  if (vendorMatch) return vendorMatch.call(el, query);\n\n  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i] === el) return true;\n  }\n\n  return false;\n}\n\nexports.default = matches;\nmodule.exports = exports['default'];\n//# sourceMappingURL=matches.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Debounce\n * Debounce a function call\n *\n * @param {Function} func\n * @param {Integer} delay\n *\n * @module helpers/util/debounce.js\n */\nfunction debounce(func, delay) {\n\n  var timer = void 0;\n\n  return function () {\n    var args = arguments;\n    if (timer) window.clearTimeout(timer);\n    timer = window.setTimeout(function () {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\nexports.default = debounce;\nmodule.exports = exports[\"default\"];\n//# sourceMappingURL=debounce.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9wb3BvdmVyLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9hZGQtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL2hhcy1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vb2Zmc2V0LmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL21hbmlwdWxhdGlvbi9hcHBlbmQtY2hpbGRyZW4uanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYWZmaXguanMiLCJqcy9kaXN0L2hlbHBlcnMvcG9zaXRpb24vYm94LXBvc2l0aW9uLmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9oYXMtcGFyZW50LmpzIiwianMvZGlzdC9oZWxwZXJzL3RyYXZlcnNhbC9tYXRjaGVzLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvZGVib3VuY2UuanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC9lYWNoLmpzIiwianMvZGlzdC9oZWxwZXJzL3V0aWwvdHJpbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vaGVscGVycy91dGlsL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEJhc2UgQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGJhc2UgY2xhc3MgZm9yIFNwYXJrIEpTIGNvbXBvbmVudHMuIFRoaXMgY2xhc3Mgc2hvdWxkIG5ldmVyIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9iYXNlLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgYW5kIGNhY2hlIGVsZW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZShlbCkge1xuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2UpO1xuXG4gICAgaWYgKHBhcmFtcy5lbFJlcXVpcmVkICYmICFlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMgfHwge30sIHRydWUpO1xuICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgKHRoaXMuX2NhY2hlRWxlbWVudHMgfHwgbm9vcCkuY2FsbCh0aGlzLCBlbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHByZXBhcmUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBieSBkZXJlZmVyZW5jaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsZWF2ZUVsZW1lbnQgTGVhdmUgdGhlIGVsZW1lbnQgaW50YWN0LlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShsZWF2ZUVsZW1lbnQpIHtcblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoIWxlYXZlRWxlbWVudCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cblxuICAgIHRoaXMudW5zZXRQYXJhbXModGhpcy5kZWZhdWx0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjb21wb25lbnQgdG8gdXNlIGEgbmV3IGVsZW1lbnQgb3IgcmVwYXJzZSBmcm9tXG4gICAqIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIE9wdGlvbmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXG4gICAgaWYgKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwgfHwgdGhpcy5lbCwgcGFyYW1zKTtcbiAgICAodGhpcy5fcGFyc2VQYXJhbXMgfHwgbm9vcCkuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9hZGRFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgaGFzaCBvZiBwYXJhbWV0ZXJzIGlmIHRoZXkncmUgd2hpdGVsaXN0ZWQgb3Igd2UncmUgdG9sZCB0byBmb3JjZSB0aGUgc2V0LlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gc2V0IGluaXRpYWwgdmFsdWVzIGFzIHdlbGwgYXMgc2V0IHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2Ugc2V0dGluZyBldmVuIGlmIHRoZSBwYXJhbSBpcyBub3Qgd2hpdGVsaXN0ZWQuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUuc2V0UGFyYW1zID0gZnVuY3Rpb24gc2V0UGFyYW1zKHBhcmFtcywgZm9yY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShwYXJhbXMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBpZiAoX3RoaXMuX3doaXRlbGlzdGVkUGFyYW1zLmluZGV4T2YoaykgIT09IC0xIHx8IGZvcmNlKSB7XG4gICAgICAgIF90aGlzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNldCBhbGwgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBvYmplY3QgdG8gdW5zZXQgdGhlIHBhcmFtcyBmcm9tLiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudW5zZXRQYXJhbXMgPSBmdW5jdGlvbiB1bnNldFBhcmFtcyhrZXlzLCBzY29wZSkge1xuXG4gICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICBzY29wZSA9IHNjb3BlIHx8IHRoaXM7XG4gICAgKDAsIF9lYWNoMi5kZWZhdWx0KShrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgZGVsZXRlIHNjb3BlW2tdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cbkJhc2UucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFtdO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBpbnRlcm5hbCBwcm9wZXJ0aWVzIHdlIHdpbGwgYmUgc2V0dGluZy5cbiAqIFRoZXNlIGFyZSBzZXQgb24gZWFjaCBjb25zdHJ1Y3Rpb24gc28gd2UgZG9uJ3QgbGVhayBwcm9wZXJ0aWVzXG4gKiBpbnRvIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CYXNlLnByb3RvdHlwZS5kZWZhdWx0cyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX2FkZENsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vaGFzLWNsYXNzJyk7XG5cbnZhciBfaGFzQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzQ2xhc3MpO1xuXG52YXIgX3RvZ2dsZUNsYXNzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb20vdG9nZ2xlLWNsYXNzJyk7XG5cbnZhciBfdG9nZ2xlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQ2xhc3MpO1xuXG52YXIgX2FwcGVuZENoaWxkcmVuID0gcmVxdWlyZSgnLi4vaGVscGVycy9tYW5pcHVsYXRpb24vYXBwZW5kLWNoaWxkcmVuJyk7XG5cbnZhciBfYXBwZW5kQ2hpbGRyZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwZW5kQ2hpbGRyZW4pO1xuXG52YXIgX2hhc1BhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdHJhdmVyc2FsL2hhcy1wYXJlbnQnKTtcblxudmFyIF9oYXNQYXJlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzUGFyZW50KTtcblxudmFyIF9nZXRQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RyYXZlcnNhbC9nZXQtcGFyZW50Jyk7XG5cbnZhciBfZ2V0UGFyZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFBhcmVudCk7XG5cbnZhciBfcGFyc2VBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbS9wYXJzZS1hdHRyaWJ1dGUnKTtcblxudmFyIF9hZmZpeCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcG9zaXRpb24vYWZmaXgnKTtcblxudmFyIF9hZmZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZmZpeCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIFBvcG92ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNob3cgYW5kIGhpZGUgYSBwb3BvdmVyLiBTaG91bGQgZG8gc29tZSBzYW5pdHkgY2hlY2tzIG9uIHBvc2l0aW9uaW5nIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5ldyBQb3BvdmVyKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIE9wdGlvbmFsLiBEZWZhdWx0IGFuY2hvcmluZyBvZiB0aGUgY29udGVudCdzIHggYW5kIHktYXhpcyByZWxhdGl2ZSB0byB0aGUgYnV0dG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBkZWZhdWx0QW5jaG9yWDogJ2NlbnRlcicsIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgZGVmYXVsdEFuY2hvclk6ICdjZW50ZXInIC8vICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgY29tcG9uZW50cy9wb3BvdmVyLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIFBvcG92ZXIgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBvcG92ZXIsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb3BvdmVyKGVsKSB7XG4gICAgdmFyIF9yZXQ7XG5cbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BvdmVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpO1xuXG4gICAgaWYgKCFlbCkgcmV0dXJuIF9yZXQgPSBfdGhpcywgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIF90aGlzLl9iaW5kRXZlbnRMaXN0ZW5lckNhbGxiYWNrcygpO1xuICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgdGltZXIgcnVubmluZyBmb3IgdGhlIGNsb3NlIGV2ZW50LCBjbGVhciBpdCBzbyBpdFxuICAgIC8vIGRvZXNuJ3QgY2xvc2Ugc3R1ZmYgZHVyaW5nIG9wZW4uXG4gICAgaWYgKHRoaXMuY2xvc2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcik7XG4gICAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIGFuY2hvciB0aGUgcG9wb3ZlciB0byBpcyBmaXhlZCwgd2UgbmVlZCB0byBrbm93XG4gICAgLy8gc28gdGhhdCB0aGUgYWZmaXhlZCBjb250ZW50IGNhbiBhbHNvIGJlIGZpeGVkLlxuICAgIHRoaXMuX2NoZWNrRml4ZWRQb3NpdGlvbigpO1xuXG4gICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIGFmZml4ZWQgaW5zdGFuY2UuXG4gICAgaWYgKHRoaXMuYWZmaXgpIHtcbiAgICAgIHRoaXMuYWZmaXgudGFyZ2V0RWwgPSBwYXJhbXMuYWZmaXhUbyB8fCB0aGlzLmFmZml4LnRhcmdldEVsO1xuICAgICAgdGhpcy5hZmZpeC51cGRhdGUoKTtcbiAgICB9XG4gICAgLy8gQWZmaXggdGhlIGNvbnRlbnQgdG8gdGhlIHRvZ2dsZVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFmZml4ID0gbmV3IF9hZmZpeDIuZGVmYXVsdCh7XG4gICAgICAgICAgZWw6IHRoaXMuY29udGVudEVsLFxuICAgICAgICAgIHRhcmdldEVsOiBwYXJhbXMuYWZmaXhUbyB8fCB0aGlzLmVsLFxuICAgICAgICAgIGNhcmV0RWw6IHRoaXMuY2FyZXRFbCxcbiAgICAgICAgICBhbmNob3JYOiB0aGlzLmFuY2hvclgsXG4gICAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgICAgIGlzRml4ZWQ6IHRoaXMuaXNGaXhlZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgY2xpY2tzIG9uIHRoZSB3aW5kb3dcbiAgICB0aGlzLl9hZGRXaW5kb3dFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAvLyBEaXNwYXRjaCBhIGN1c3RvbSBldmVudCBzbyBjb250ZW50IGluc2lkZSB0aGUgcG9wb3ZlciBjYW4gcmVzcG9uZFxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZS5pbml0RXZlbnQoJ3NwYXJrLnZpc2libGUtY2hpbGRyZW4nLCB0cnVlLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRlbnRFbC5kaXNwYXRjaEV2ZW50KGUpO1xuXG4gICAgLy8gVXBkYXRlIGJpbmRpbmdzXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcygpO1xuXG4gICAgLy8gQ2FsbGJhY2tzXG4gICAgKHBhcmFtcy5jb21wbGV0ZSB8fCBub29wKSgpO1xuICAgICh0aGlzLm9uT3BlbiB8fCBub29wKSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cbiAgICAvLyBOb3Qgb3Blbiwgc28gZG9uJ3QgY2xvc2UuXG4gICAgaWYgKCF0aGlzLmFmZml4KSByZXR1cm4gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgdGltZXIgcnVubmluZyBmb3IgdGhlIGNsb3NlIGV2ZW50LCBjbGVhciBpdCBzbyB3ZSBkb24ndCBydW4gY2xvc2Ugc3R1ZmYgdHdpY2UuXG4gICAgaWYgKHRoaXMuY2xvc2VUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcik7XG4gICAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFN0b3AgbGlzdGVuaW5nIHRvIHdpbmRvdyBjbGlja3MuXG4gICAgdGhpcy5fcmVtb3ZlV2luZG93RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcblxuICAgIC8vIFVwZGF0ZSBiaW5kaW5nc1xuICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZXMoKTtcblxuICAgIC8vIENsb3NlIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGNvbXBsZXRlZFxuICAgIHRoaXMuY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLl9maW5pc2hDbG9zZShwYXJhbXMpO1xuICAgIH0sIDI1MCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBvcGVuIHN0YXRlLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmlzQWN0aXZlID8gJ2Nsb3NlJyA6ICdvcGVuJ10oKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb250ZW50LiBPcHRpb25hbGx5IGFwcGVuZCBpbnN0ZWFkIG9mIHJlcGxhY2luZy5cbiAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5fE5vZGVMaXN0fSBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgKDAsIF9hcHBlbmRDaGlsZHJlbjIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsIGNvbnRlbnQubGVuZ3RoID8gY29udGVudCA6IFtjb250ZW50XSwgIShwYXJhbXMuYXBwZW5kIHx8IGZhbHNlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShlbCkge1xuXG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9jYWNoZUVsZW1lbnRzKGVsIHx8IHRoaXMuZWwpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBpZiAodGhpcy5hZmZpeCkgdGhpcy5hZmZpeC51cGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgdGFicyBsaXN0LCBlYWNoIHRhYiBhbmQgZWFjaCBwYW5lbC5cbiAgICogU2V0IHdoaWNoIHRhYiBpcyBhY3RpdmUsIG9yIHVzZSB0aGUgZmlyc3QuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fY2FjaGVFbGVtZW50cyA9IGZ1bmN0aW9uIF9jYWNoZUVsZW1lbnRzKGVsKSB7XG5cbiAgICAvLyBJZiBhIGNvbnRlbnQgZWxlbWVudCB3YXMgYWxyZWFkeSBwYXNzZWQsIG1ha2Ugc3VyZSBpdCBoYXMgYSBwb3BvdmVyIGNvbnRlbnQgY2xhc3NcbiAgICBpZiAodGhpcy5jb250ZW50RWwpIHtcbiAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY29udGVudEVsLCAnc3BhcmstcG9wb3Zlcl9fY29udGVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLnRvZ2dsZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstcG9wb3Zlcl9fdG9nZ2xlLCBbZGF0YS1yb2xlPVwidG9nZ2xlXCJdJykgfHwgdGhpcy5lbDtcbiAgICB0aGlzLmNvbnRlbnRFbCA9IHRoaXMuY29udGVudEVsIHx8IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnNwYXJrLXBvcG92ZXJfX2NvbnRlbnQsIFtjbGFzcyo9XCJzcGFyay1wb3BvdmVyX19jb250ZW50LS1cIl0nKSB8fCB0aGlzLl9jcmVhdGVDb250ZW50RWwoKTtcbiAgICB0aGlzLmNhcmV0RWwgPSB0aGlzLmNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCcuc3BhcmstcG9wb3Zlcl9fY2FyZXQnKSB8fCB0aGlzLl9jcmVhdGVDYXJldEVsKCk7XG4gICAgdGhpcy5pc0FjdGl2ZSA9ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMudG9nZ2xlRWwsICdwb3BvdmVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBjb25maWcgdmFsdWVzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX3BhcnNlUGFyYW1zID0gZnVuY3Rpb24gX3BhcnNlUGFyYW1zKCkge1xuXG4gICAgdGhpcy5hbmNob3JZID0gdGhpcy5hbmNob3JZICE9PSBudWxsID8gdGhpcy5hbmNob3JZIDogKDAsIF9wYXJzZUF0dHJpYnV0ZS5zdHJpbmcpKHRoaXMuY29udGVudEVsLCAnZGF0YS1hbmNob3IteScsIG51bGwpO1xuICAgIHRoaXMuYW5jaG9yWCA9IHRoaXMuYW5jaG9yWCAhPT0gbnVsbCA/IHRoaXMuYW5jaG9yWCA6ICgwLCBfcGFyc2VBdHRyaWJ1dGUuc3RyaW5nKSh0aGlzLmNvbnRlbnRFbCwgJ2RhdGEtYW5jaG9yLXgnLCBudWxsKTtcblxuICAgIC8vIE5vIGFuY2hvcnMgZGVmaW5lZFxuICAgIGlmICghdGhpcy5hbmNob3JZICYmICF0aGlzLmFuY2hvclgpIHtcblxuICAgICAgLy8gTGVmdFxuICAgICAgaWYgKCgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY29udGVudEVsLCAnc3BhcmstcG9wb3Zlcl9fY29udGVudC0tbGVmdCcpKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yWSA9ICdtaWRkbGUnO1xuICAgICAgICB0aGlzLmFuY2hvclggPSAnbGVmdCc7XG4gICAgICB9XG4gICAgICAvLyBSaWdodFxuICAgICAgZWxzZSBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50LS1yaWdodCcpKSB7XG4gICAgICAgICAgdGhpcy5hbmNob3JZID0gJ21pZGRsZSc7XG4gICAgICAgICAgdGhpcy5hbmNob3JYID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBUb3BcbiAgICAgICAgZWxzZSBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5jb250ZW50RWwsICdzcGFyay1wb3BvdmVyX19jb250ZW50LS10b3AnKSkge1xuICAgICAgICAgICAgdGhpcy5hbmNob3JZID0gJ3RvcCc7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclggPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQm90dG9tXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYW5jaG9yWSA9ICdib3R0b20nO1xuICAgICAgICAgICAgICB0aGlzLmFuY2hvclggPSAnY2VudGVyJztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgYnV0dG9uIHRyaWdnZXJpbmcgdGhlIHBvcG92ZXIgaXMgZml4ZWQuXG4gICAqIElmIHNvLCB0aGVuIHBvcG92ZXIgbmVlZHMgdG8gYmUgZml4ZWQgYXMgd2VsbC5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fY2hlY2tGaXhlZFBvc2l0aW9uID0gZnVuY3Rpb24gX2NoZWNrRml4ZWRQb3NpdGlvbigpIHtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLmVsO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XG4gICAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaXhlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pc0ZpeGVkID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjbGFzc2VzIGZvciB0aGUgb3BlbiBvciBjbG9zZSBzdGF0ZS5cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fdXBkYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF91cGRhdGVBdHRyaWJ1dGVzKCkge1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuZWwsICdwb3BvdmVyLWFjdGl2ZScsIHRoaXMuaXNBY3RpdmUpO1xuICAgICgwLCBfdG9nZ2xlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuY29udGVudEVsLCAnYWN0aXZlJywgdGhpcy5pc0FjdGl2ZSk7XG4gICAgKDAsIF90b2dnbGVDbGFzczIuZGVmYXVsdCkodGhpcy50b2dnbGVFbCwgJ2FjdGl2ZScsIHRoaXMuaXNBY3RpdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYm91bmQgdmVyc2lvbnMgb2YgZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2tzIGFuZCBzdG9yZSB0aGVtLlxuICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgdW5iaW5kIGZyb20gdGhlc2UgZXZlbnRzIGxhdGVyIGJlY2F1c2UgdGhlXG4gICAqIGZ1bmN0aW9uIHNpZ25hdHVyZXMgd29uJ3QgbWF0Y2guXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCkge1xuICAgIHRoaXMuX29uQ2xpY2tCb3VuZCA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNvbnRlbnRDbGlja0JvdW5kID0gdGhpcy5fb25Db250ZW50Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbldpbmRvd0NsaWNrQm91bmQgPSB0aGlzLl9vbldpbmRvd0NsaWNrLmJpbmQodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIERPTSBldmVudHMuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQm91bmQpO1xuICAgIHRoaXMuY29udGVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Db250ZW50Q2xpY2tCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIERPTSBldmVudHMuLlxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGlja0JvdW5kKTtcbiAgICB0aGlzLmNvbnRlbnRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ29udGVudENsaWNrQm91bmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSB3aW5kb3cuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX2FkZFdpbmRvd0V2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZFdpbmRvd0V2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX3JlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXJzKCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25XaW5kb3dDbGlja0JvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHdpbmRvdyBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXJzKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uV2luZG93Q2xpY2tCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGVudEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNvbnRlbnRFbCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KShlbCwgJ3NwYXJrLXBvcG92ZXJfX2NvbnRlbnQnKTtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndG9vbHRpcCcpO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjYXJldCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9jcmVhdGVDYXJldEVsID0gZnVuY3Rpb24gX2NyZWF0ZUNhcmV0RWwoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuY2xhc3NOYW1lID0gJ3NwYXJrLXBvcG92ZXJfX2NhcmV0JztcbiAgICB0aGlzLmNvbnRlbnRFbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgY2xvc2UgZXZlbnQgYnkgbW92aW5nIHRoZSBlbGVtZW50IGJhY2sgYW5kIGRlc3Ryb3lpbmcgdGhlIGFmZml4LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9maW5pc2hDbG9zZSA9IGZ1bmN0aW9uIF9maW5pc2hDbG9zZSgpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuXG4gICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcblxuICAgIC8vIE1vdmUgdGhlIGNvbnRlbnQgYmFjayB0byB0aGUgcGFyZW50XG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbCk7XG5cbiAgICB0aGlzLmFmZml4LnJlbW92ZSh7IGtlZXBFbDogdHJ1ZSB9KTtcbiAgICB0aGlzLmFmZml4ID0gbnVsbDtcblxuICAgIChwYXJhbXMuY29tcGxldGUgfHwgbm9vcCkoKTtcbiAgICAodGhpcy5vbkNsb3NlIHx8IG5vb3ApKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gd2UgYXJlIGNsaWNrZWQsIHRvZ2dsZSB0aGUgcG9wb3Zlci1hY3RpdmUgc3RhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqL1xuXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSB0b2dnbGUgZWxlbWVudCwgdG9nZ2xlLlxuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy50b2dnbGVFbCB8fCAoMCwgX2hhc1BhcmVudDIuZGVmYXVsdCkoZS50YXJnZXQsIHRoaXMudG9nZ2xlRWwpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgdG9nZ2xlIGlzIGNsaWNrZWQsIGNsb3NlIGlmIGl0J3MgYSBsaW5rLiBJZiBpdCdzIGNvbnRlbnQsIGRvbid0IGRvIGFueXRoaW5nIGJ1dCBzdG9wXG4gICAqIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFBvcG92ZXIucHJvdG90eXBlLl9vbkNvbnRlbnRDbGljayA9IGZ1bmN0aW9uIF9vbkNvbnRlbnRDbGljayhlKSB7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgbGluaywgY2xvc2UuXG4gICAgaWYgKCgwLCBfZ2V0UGFyZW50Mi5kZWZhdWx0KShlLnRhcmdldCwgJy5zcGFyay1wb3BvdmVyX19saXN0LWxpbmsnLCB0aGlzLmNvbnRlbnRFbCkgfHwgKDAsIF9nZXRQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCAnLnNwYXJrLXBvcG92ZXJfX2Nsb3NlJywgdGhpcy5jb250ZW50RWwpKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSB3aW5kb3cgaXMgY2xpY2tlZCBhbmQgaXQncyBub3QgcGFydCBvZiB0aGUgcG9wb3ZlciwgY2xvc2UgdGhlIHBvcG92ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN9IGVcbiAgICovXG5cblxuICBQb3BvdmVyLnByb3RvdHlwZS5fb25XaW5kb3dDbGljayA9IGZ1bmN0aW9uIF9vbldpbmRvd0NsaWNrKGUpIHtcblxuICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcy5lbCAmJiAhKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmVsKSAmJiAhKDAsIF9oYXNQYXJlbnQyLmRlZmF1bHQpKGUudGFyZ2V0LCB0aGlzLmNvbnRlbnRFbCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvcG92ZXI7XG59KF9iYXNlMi5kZWZhdWx0KTtcblxuLyoqXG4gKiBXaGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIHdoaWNoIGNhbiBiZSBzZXQgb24gY29uc3RydWN0aW9uLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cblxuUG9wb3Zlci5wcm90b3R5cGUuX3doaXRlbGlzdGVkUGFyYW1zID0gWydhbmNob3JYJywgJ2FuY2hvclknLCAndG9nZ2xlRWwnLCAnY29udGVudEVsJywgJ29uT3BlbicsICdvbkNsb3NlJ107XG5cbi8qKlxuICogRGVmYXVsdCB2YWx1ZXMgZm9yIGludGVybmFsIHByb3BlcnRpZXMgd2Ugd2lsbCBiZSBzZXR0aW5nLlxuICogVGhlc2UgYXJlIHNldCBvbiBlYWNoIGNvbnN0cnVjdGlvbiBzbyB3ZSBkb24ndCBsZWFrIHByb3BlcnRpZXNcbiAqIGludG8gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblBvcG92ZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBlbDogbnVsbCxcbiAgdG9nZ2xlRWw6IG51bGwsXG4gIGNvbnRlbnRFbDogbnVsbCxcbiAgY2FyZXRFbDogbnVsbCxcbiAgYWZmaXg6IG51bGwsXG4gIGlzQWN0aXZlOiBmYWxzZSxcbiAgaXNQYXVzZWQ6IGZhbHNlLFxuICBpc0ZpeGVkOiBmYWxzZSxcbiAgYW5jaG9yWDogbnVsbCxcbiAgYW5jaG9yWTogbnVsbCxcbiAgY2xvc2VUaW1lcjogbnVsbCxcbiAgb25PcGVuOiBudWxsLFxuICBvbkNsb3NlOiBudWxsLFxuICBfb25DbGlja0JvdW5kOiBudWxsLFxuICBfb25Db250ZW50Q2xpY2tCb3VuZDogbnVsbCxcbiAgX29uV2luZG93Q2xpY2tCb3VuZDogbnVsbCxcbiAgX29uV2luZG93UmVzaXplQm91bmQ6IG51bGwsXG4gIF9vbldpbmRvd1Njcm9sbEJvdW5kOiBudWxsXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQb3BvdmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BvdmVyLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogIyBBZGQgQ2xhc3NcbiAqIEFkZCBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vYWRkLWNsYXNzLmpzXG4gKi9cblxudmFyIHdzID0gL1xccysvO1xudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZVswXSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHZhciB0b0FkZCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gbmFtZS5sZW5ndGg7XG4gIHZhciBpdGVtID0gdm9pZCAwO1xuICB2YXIgY2xzTmFtZSA9IHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJyc7XG5cbiAgLy8gc2VlIGlmIHdlIGhhdmUgYW55dGhpbmcgdG8gYWRkXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgaXRlbSA9IG5hbWVbaV07XG4gICAgaWYgKGl0ZW0gJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGNsc05hbWUsIGl0ZW0pKSB7XG4gICAgICB0b0FkZC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkoKGNsc05hbWUgKyAnICcgKyB0b0FkZC5qb2luKCcgJykpLnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyoqXG4gKiAjIEhhcyBDbGFzc1xuICogU2VlIGlmIGFuIGVsZW1lbnQgaGFzIGEgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vaGFzLWNsYXNzLmpzXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XG4gIHZhciBjTmFtZSA9ICgodHlwZW9mIGVsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihlbCkpID09PSAnb2JqZWN0JyA/IGVsLmNsYXNzTmFtZSB8fCBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnIDogZWwgfHwgJycpLnJlcGxhY2UoL1tcXHRcXHJcXG5cXGZdL2csICcgJyk7XG4gIHJldHVybiAoJyAnICsgY05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgbmFtZSArICcgJykgIT09IC0xO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBoYXNDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIE9mZnNldCBQb3NpdGlvblxuICogR2V0IHRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSB2aWV3UG9ydE9mZnNldCBUaGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgbm90IHBhZ2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL2RvbS9vZmZzZXQuanNcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGVsLCB2aWV3UG9ydE9mZnNldCkge1xuXG4gIHZhciByZWN0ID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG5cbiAgLy8gTmF0aXZlIGltcGxlbWVudGF0aW9uXG4gIGlmIChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcblxuICAgIHZhciBib3VuZGluZyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJlY3QubGVmdCA9IGJvdW5kaW5nLmxlZnQ7XG4gICAgcmVjdC50b3AgPSBib3VuZGluZy50b3A7XG5cbiAgICBpZiAoIXZpZXdQb3J0T2Zmc2V0KSB7XG4gICAgICByZWN0LmxlZnQgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxYICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgcmVjdC50b3AgKz0gdHlwZW9mIHdpbmRvdy5zY3JvbGxZICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwO1xuICAgIGRvIHtcbiAgICAgIHggKz0gZWwub2Zmc2V0TGVmdCAtICghdmlld1BvcnRPZmZzZXQgPyBlbC5zY3JvbGxMZWZ0IDogMCk7XG4gICAgICB5ICs9IGVsLm9mZnNldFRvcCAtICghdmlld1BvcnRPZmZzZXQgPyBlbC5zY3JvbGxUb3AgOiAwKTtcbiAgICB9IHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCk7XG5cbiAgICByZWN0LmxlZnQgPSB4O1xuICAgIHJlY3QudG9wID0geTtcbiAgfVxuXG4gIHJldHVybiByZWN0O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBvZmZzZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mZnNldC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBQYXJzZSBET00gYXR0cmlidXRlc1xuICogR2l2ZW4gYW4gZWxlbWVudCBhbmQgYW4gYXR0cmlidXRlIG5hbWUsIHBhcnNlIHRoYXQgYXR0cmlidXRlXG4gKiBpZiBpdCBleGlzdHMgb3IgcmV0dXJuIGEgZGVmYXVsdC5cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvZG9tL3BhcnNlLWF0dHJpYnV0ZS5qc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBib29sZWFuIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBib29sZWFuKGVsLCBuYW1lLCBkZWYpIHtcbiAgdmFyIHZhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIGRlZjtcbiAgcmV0dXJuIHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJycgPyB0cnVlIDogZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IHRoZSBudW1lcmljIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBudW1iZXIoZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBib29sZWFuIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxuICogZmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gZGVmXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBzdHJpbmcoZWwsIG5hbWUsIGRlZikge1xuICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gZGVmO1xuICByZXR1cm4gdmFsO1xufVxuXG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWF0dHJpYnV0ZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90cmltID0gcmVxdWlyZSgnLi4vdXRpbC90cmltJyk7XG5cbnZhciBfdHJpbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90cmltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdzID0gL1xccysvOyAvKipcbiAgICAgICAgICAgICAgICAgKiAjIFJlbW92ZSBDbGFzc1xuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9kb20vcmVtb3ZlLWNsYXNzLmpzXG4gICAgICAgICAgICAgICAgICovXG5cbnZhciBjbGVhbnVwID0gL1xcc3syLH0vZztcblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShuYW1lKS5zcGxpdCh3cyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IG5hbWUgaW5zdGFuY2VvZiBBcnJheSA/IG5hbWUgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB9XG5cbiAgLy8gb3B0aW1pemUgZm9yIGJlc3QsIG1vc3QgY29tbW9uIGNhc2VcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxICYmIGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChuYW1lWzBdKSBlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVbMF0pO1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8vIHN0b3JlIHR3byBjb3BpZXNcbiAgdmFyIGNsc05hbWUgPSAnICcgKyAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiBlbC5nZXRBdHRyaWJ1dGUgPyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgOiAnJykgKyAnICc7XG4gIHZhciByZXN1bHQgPSBjbHNOYW1lO1xuICB2YXIgY3VycmVudCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3VycmVudCA9IG5hbWVbaV07XG4gICAgc3RhcnQgPSBjdXJyZW50ID8gcmVzdWx0LmluZGV4T2YoJyAnICsgY3VycmVudCArICcgJykgOiAtMTtcbiAgICBpZiAoc3RhcnQgIT09IC0xKSB7XG4gICAgICBzdGFydCArPSAxO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHN0YXJ0KSArIHJlc3VsdC5zbGljZShzdGFydCArIGN1cnJlbnQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHdyaXRlIGlmIG1vZGlmaWVkXG4gIGlmIChjbHNOYW1lICE9PSByZXN1bHQpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKHJlc3VsdC5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaGFzQ2xhc3MgPSByZXF1aXJlKCcuL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4vYWRkLWNsYXNzJyk7XG5cbnZhciBfYWRkQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQ2xhc3MpO1xuXG52YXIgX3JlbW92ZUNsYXNzID0gcmVxdWlyZSgnLi9yZW1vdmUtY2xhc3MnKTtcblxudmFyIF9yZW1vdmVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW1vdmVDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBlbmFibGUpIHtcblxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgcGFzc2VkIGFuIGFycmF5LCB0b2dnbGUgdGhlIGNsYXNzIG9uIGVhY2guXG4gIGlmIChlbCBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdG9nZ2xlQ2xhc3MoZWxbaV0sIG5hbWUsIGVuYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFjdGlvbiA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5hYmxlID0gdHlwZW9mIGVuYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IGVuYWJsZS5jYWxsKG51bGwsIGVsKSA6IGVuYWJsZTtcbiAgICBhY3Rpb24gPSBlbmFibGUgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICB9IGVsc2Uge1xuICAgIGFjdGlvbiA9ICgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGVsLCBuYW1lKSA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gIH1cblxuICByZXR1cm4gKGFjdGlvbiA9PT0gJ2FkZCcgPyBfYWRkQ2xhc3MyLmRlZmF1bHQgOiBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKGVsLCBuYW1lKTtcbn0gLyoqXG4gICAqICMgVG9nZ2xlIENsYXNzXG4gICAqIFRvZ2dsZSBhIGNsYXNzIG9uIGFuIGVsZW1lbnQgZ2l2ZW4gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqXG4gICAqIEBtb2R1bGUgIGhlbHBlcnMvZG9tL3RvZ2dsZS1jbGFzcy5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gdG9nZ2xlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnLi4vdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRyZW4oZWwsIGNoaWxkcmVuLCBlbXB0eSkge1xuXG4gIGVtcHR5ID0gZW1wdHkgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogZW1wdHk7XG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSAnJztcbiAgfVxuXG4gIHZhciBkb21MaXN0ID0gY2hpbGRyZW4gaW5zdGFuY2VvZiB3aW5kb3cuSFRNTENvbGxlY3Rpb247XG5cbiAgaWYgKGRvbUxpc3QpIHtcbiAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBlbC5hcHBlbmRDaGlsZChjaGlsZHJlblswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvKipcbiAgICogIyBBcHBlbmQgQ2hpbGRyZW5cbiAgICogQXBwZW5kIGFuIGFycmF5IG9mIGNoaWxkcmVuIHRvIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge0FycmF5fSBjaGlsZHJlblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtcHR5IEVtcHR5IHRoZSBub2RlIGJlZm9yZSBhZGRpbmcgY2hpbGRyZW4/XG4gICAqXG4gICAqIEBtb2R1bGUgaGVscGVycy9tYW5pcHVsYXRpb24vYXBwZW5kLWNoaWxkcmVuLmpzXG4gICAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcHBlbmRDaGlsZHJlbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwZW5kLWNoaWxkcmVuLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX29mZnNldDIgPSByZXF1aXJlKCcuLi9kb20vb2Zmc2V0Jyk7XG5cbnZhciBfb2Zmc2V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29mZnNldDIpO1xuXG52YXIgX2JveFBvc2l0aW9uID0gcmVxdWlyZSgnLi9ib3gtcG9zaXRpb24nKTtcblxudmFyIF9ib3hQb3NpdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib3hQb3NpdGlvbik7XG5cbnZhciBfZGVib3VuY2UgPSByZXF1aXJlKCcuLi91dGlsL2RlYm91bmNlJyk7XG5cbnZhciBfZGVib3VuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVib3VuY2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAjIEFmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQWZmaXggb25lIGVsZW1lbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV3IEFmZml4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHRhcmdldEVsOiBlbDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBjYXJldEVsOiBlbDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBhbmNob3JZOiAndG9wJywgLy8gJ21pZGRsZScsICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICBhbmNob3JYOiAnbGVmdCcsIC8vICdjZW50ZXInLCAncmlnaHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgaGVscGVycy9wb3NpdGlvbi9hZmZpeC5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgQWZmaXggPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSByZWZlcmVuY2UgZWxlbWVudHMgYW5kIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gQWZmaXgoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWZmaXgpO1xuXG4gICAgdGhpcy5lbCA9IHBhcmFtcy5lbDtcbiAgICB0aGlzLnRhcmdldEVsID0gcGFyYW1zLnRhcmdldEVsO1xuICAgIHRoaXMuY2FyZXRFbCA9IHBhcmFtcy5jYXJldEVsO1xuICAgIHRoaXMuYW5jaG9yWSA9IHBhcmFtcy5hbmNob3JZIHx8ICd0b3AnO1xuICAgIHRoaXMuYW5jaG9yWCA9IHBhcmFtcy5hbmNob3JYIHx8ICdjZW50ZXInO1xuICAgIHRoaXMuaXNGaXhlZCA9IHBhcmFtcy5pc0ZpeGVkIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9pbnNlcnRFbCgpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fdXBkYXRlRGVib3VuY2VkID0gKDAsIF9kZWJvdW5jZTIuZGVmYXVsdCkodGhpcy51cGRhdGUuYmluZCh0aGlzKSwgNTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyBhbmQgY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgT3B0aW9uYWxcbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmICghcGFyYW1zLmtlZXBFbCkgdGhpcy5fcmVtb3ZlRWwoKTtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNcbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3Igd2luZG93IHJlc2l6ZXMgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbi5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX29uUmVzaXplQm91bmQgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2Nyb2xsQm91bmQgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJvdW5kKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGxCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJvdW5kKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGxCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCB0aGUgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9pbnNlcnRFbCA9IGZ1bmN0aW9uIF9pbnNlcnRFbCgpIHtcbiAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZGF0YS1hZmZpeGVkJywgJycpO1xuICAgIHRoaXMuX2dldFJvb3RFbCgpLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fcmVtb3ZlRWwgPSBmdW5jdGlvbiBfcmVtb3ZlRWwoKSB7XG4gICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFmZml4ZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcblxuICAgIC8vIEZpeGVkIHBvc2l0aW9uXG4gICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCB0aGlzLmlzRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJywgJ2ltcG9ydGFudCcpO1xuXG4gICAgLy8gVGFyZ2V0IGVsZW1lbnQgcHJvcGVydGllc1xuXG4gICAgdmFyIF9vZmZzZXQgPSAoMCwgX29mZnNldDMuZGVmYXVsdCkodGhpcy50YXJnZXRFbCwgdGhpcy5pc0ZpeGVkKSxcbiAgICAgICAgdGFyZ2V0VG9wID0gX29mZnNldC50b3AsXG4gICAgICAgIHRhcmdldExlZnQgPSBfb2Zmc2V0LmxlZnQ7XG5cbiAgICB2YXIgdGFyZ2V0V2lkdGggPSB0aGlzLnRhcmdldEVsLm9mZnNldFdpZHRoO1xuICAgIHZhciB0YXJnZXRIZWlnaHQgPSB0aGlzLnRhcmdldEVsLm9mZnNldEhlaWdodDtcblxuICAgIC8vIEVsZW1lbnQgdG8gYWZmaXggcHJvcGVydGllc1xuICAgIHZhciBlbFdpZHRoID0gdGhpcy5lbC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZWxIZWlnaHQgPSB0aGlzLmVsLm9mZnNldEhlaWdodDtcblxuICAgIC8vIE1heGVzXG4gICAgdmFyIGRvY0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGRvY1dpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZXNcblxuICAgIHZhciBfY2FsY3VsYXRlUG9zaXRpb24yID0gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24oe1xuICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgdGFyZ2V0VG9wOiB0YXJnZXRUb3AsXG4gICAgICB0YXJnZXRMZWZ0OiB0YXJnZXRMZWZ0LFxuICAgICAgZWxIZWlnaHQ6IGVsSGVpZ2h0LFxuICAgICAgZWxXaWR0aDogZWxXaWR0aCxcbiAgICAgIHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuICAgICAgdGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuICAgICAgbWluWDogMCxcbiAgICAgIG1pblk6IDAsXG4gICAgICBtYXhYOiBkb2NXaWR0aCAtIGVsV2lkdGgsXG4gICAgICBtYXhZOiBNYXRoLm1heChkb2NIZWlnaHQgLSBlbEhlaWdodCwgMClcbiAgICB9KSxcbiAgICAgICAgZWxUb3AgPSBfY2FsY3VsYXRlUG9zaXRpb24yLmVsVG9wLFxuICAgICAgICBlbExlZnQgPSBfY2FsY3VsYXRlUG9zaXRpb24yLmVsTGVmdDtcblxuICAgIC8vIFBvc2l0aW9uIHRoZSBjYXJldFxuXG5cbiAgICB2YXIgX3Bvc2l0aW9uQ2FyZXQyID0gdGhpcy5fcG9zaXRpb25DYXJldCh7XG4gICAgICBlbExlZnQ6IGVsTGVmdCxcbiAgICAgIGVsVG9wOiBlbFRvcCxcbiAgICAgIGVsV2lkdGg6IGVsV2lkdGgsXG4gICAgICBlbEhlaWdodDogZWxIZWlnaHQsXG4gICAgICB0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcbiAgICAgIHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcbiAgICAgIHRhcmdldExlZnQ6IHRhcmdldExlZnQsXG4gICAgICB0YXJnZXRUb3A6IHRhcmdldFRvcFxuICAgIH0pLFxuICAgICAgICBleHRyYUxlZnQgPSBfcG9zaXRpb25DYXJldDIuZXh0cmFMZWZ0LFxuICAgICAgICBleHRyYVRvcCA9IF9wb3NpdGlvbkNhcmV0Mi5leHRyYVRvcDtcblxuICAgIC8vIFNldCB0aGUgcG9zaXRpb25cblxuXG4gICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gZWxMZWZ0ICsgZXh0cmFMZWZ0ICsgJ3B4JztcbiAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IGVsVG9wICsgZXh0cmFUb3AgKyAncHgnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByb3BlciB0b3AgcG9zaXRpb24gZm9yIGFuIGFuY2hvciBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gcFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cbiAgQWZmaXgucHJvdG90eXBlLl9jYWxjdWxhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVQb3NpdGlvbihwKSB7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHdoYXQgd2UncmUgdHJ5aW5nIHRvIGRvIGhlcmUsIHNvIG9uIHN1YnNlcXVlbnQsIG5lc3RlZCBjYWxscyB0byB0aGlzXG4gICAgLy8gbWV0aG9kIHdlIGNhbiBzZWUgd2hhdCBoYXMgYWxyZWFkeSBiZWVuIHRyaWVkLlxuICAgIHAucHJldmlvdXNBdHRlbXB0cyA9IChwLnByZXZpb3VzQXR0ZW1wdHMgfHwgMCkgKyAxO1xuICAgIHAucHJldmlvdXNDaGVja3MgPSBwLnByZXZpb3VzQ2hlY2tzIHx8IFtdO1xuXG4gICAgdmFyIGZpbmFsQ2hlY2sgPSBwLnByZXZpb3VzQXR0ZW1wdHMgPiAzO1xuICAgIHZhciB0b3AgPSB2b2lkIDA7XG4gICAgdmFyIGxlZnQgPSB2b2lkIDA7XG5cbiAgICAvLyBZLWF4aXMgY2hlY2tcbiAgICBzd2l0Y2ggKHAuYW5jaG9yWSkge1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdG9wID0gcC50YXJnZXRUb3AgKyBwLnRhcmdldEhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICB0b3AgPSBwLnRhcmdldFRvcCAtIChwLmVsSGVpZ2h0IC0gcC50YXJnZXRIZWlnaHQpIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0b3AgPSBwLnRhcmdldFRvcCAtIHAuZWxIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFVuZGVyIG1pblxuICAgIGlmICh0b3AgPCBwLm1pblkpIHtcblxuICAgICAgaWYgKCFmaW5hbENoZWNrICYmIHAucHJldmlvdXNDaGVja3MuaW5kZXhPZignb3ZlclknKSA9PT0gLTEpIHtcbiAgICAgICAgcC5wcmV2aW91c0NoZWNrcy5wdXNoKCd1bmRlclknKTtcbiAgICAgICAgcC5hbmNob3JZID0gdGhpcy5fZ2V0TmV3QW5jaG9yWSh0cnVlLCBwLmFuY2hvclksIHAuYW5jaG9yWCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCA9IHAubWluWTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEb24ndCBjaGVjayBmb3IgYmVpbmcgdG9vIHRhbGwgYmVjYXVzZSBjYXVzaW5nIGEgdmVydGljYWwgc2Nyb2xsXG4gICAgLy8gYmFyIGRvd24gaXMgb2theSBhbmQgdGhpcyBzYXZlcyB1cyBmcm9tIHNvbWUgcmVhbCBwb3NpdGlvbmluZyBoZWxsLlxuICAgIC8qaWYgKHRvcCA+IHAubWF4WSkge1xuICAgICAgIGlmICghZmluYWxDaGVjayAmJiBwLnByZXZpb3VzQ2hlY2tzLmluZGV4T2YoJ3VuZGVyWScpID09PSAtMSkge1xuICAgICAgICBwLnByZXZpb3VzQ2hlY2tzLnB1c2goJ292ZXJZJyk7XG4gICAgICAgIHAuYW5jaG9yWSA9IHRoaXMuX2dldE5ld0FuY2hvclkoZmFsc2UsIHAuYW5jaG9yWSwgcC5hbmNob3JYKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfVxuICAgICAgLy8gT24gYSBmaW5hbCBjaGVjaywgYm90dG9tIHdpbnMgYmVjYXVzZSBhdCBsZWFzdCB3ZSBjYW4gc2Nyb2xsXG4gICAgICBlbHNlIGlmICghKGZpbmFsQ2hlY2sgJiYgcC5hbmNob3JZID09PSAnYm90dG9tJykpIHtcbiAgICAgICAgdG9wID0gcC5tYXhZO1xuICAgICAgfVxuICAgIH0qL1xuXG4gICAgLy8gWC1heGlzIGNoZWNrXG4gICAgc3dpdGNoIChwLmFuY2hvclgpIHtcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgbGVmdCA9IHAudGFyZ2V0TGVmdCArIChwLmFuY2hvclkgIT09ICdtaWRkbGUnICYmICFwLmlzT3ZlcmxhcHBpbmcgPyAwIDogcC50YXJnZXRXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgbGVmdCA9IHAudGFyZ2V0TGVmdCAtIChwLmVsV2lkdGggLSBwLnRhcmdldFdpZHRoKSAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVmdCA9IHAudGFyZ2V0TGVmdCAtIHAuZWxXaWR0aCArIChwLmFuY2hvclkgIT09ICdtaWRkbGUnID8gcC50YXJnZXRXaWR0aCA6IDApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVbmRlciBtaW5cbiAgICBpZiAobGVmdCA8IHAubWluWCkge1xuXG4gICAgICBpZiAoIWZpbmFsQ2hlY2sgJiYgcC5wcmV2aW91c0NoZWNrcy5pbmRleE9mKCdvdmVyWCcpID09PSAtMSkge1xuICAgICAgICBwLnByZXZpb3VzQ2hlY2tzLnB1c2goJ3VuZGVyWCcpO1xuICAgICAgICBwLmFuY2hvclggPSB0aGlzLl9nZXROZXdBbmNob3JYKHRydWUsIHAuYW5jaG9yWCwgcC5hbmNob3JZKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IHAubWluWDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdmVyIG1heFxuICAgIGlmIChsZWZ0ID4gcC5tYXhYKSB7XG5cbiAgICAgIGlmICghZmluYWxDaGVjayAmJiBwLnByZXZpb3VzQ2hlY2tzLmluZGV4T2YoJ3VuZGVyWCcpID09PSAtMSkge1xuICAgICAgICBwLnByZXZpb3VzQ2hlY2tzLnB1c2goJ292ZXJYJyk7XG4gICAgICAgIHAuYW5jaG9yWCA9IHRoaXMuX2dldE5ld0FuY2hvclgoZmFsc2UsIHAuYW5jaG9yWCwgcC5hbmNob3JZKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVBvc2l0aW9uKHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IHAubWF4WDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbmUgZWxlbWVudCBpcyBjb3ZlcmluZyBhbm90aGVyLiBUcnkgdG8gZml4IHRoYXQsIGJ1dCBiYWlsIG91dCBhZnRlciBmb3VyIHRyaWVzLlxuICAgIGlmICgoMCwgX2JveFBvc2l0aW9uMi5kZWZhdWx0KSh7IHdpZHRoOiBwLmVsV2lkdGgsIGhlaWdodDogcC5lbEhlaWdodCwgbGVmdDogbGVmdCwgdG9wOiB0b3AgfSwgeyB3aWR0aDogcC50YXJnZXRXaWR0aCwgaGVpZ2h0OiBwLnRhcmdldEhlaWdodCwgbGVmdDogcC50YXJnZXRMZWZ0LCB0b3A6IHAudGFyZ2V0VG9wIH0pID09PSAnb3ZlcmxhcCcpIHtcblxuICAgICAgcC5pc092ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gVHJ5IFlcbiAgICAgIGlmIChwLnJlcG9zaXRpb25ZICE9PSBmYWxzZSkge1xuXG4gICAgICAgIC8vIFdpbGwgc3RhcnQgdW5kZWZpbmVkLCB0aGVuIHRydWUsIHRoZW4gZmFsc2UuIFRoaXMgbGltaXRzIHVzIHRvIGVudGVyaW5nXG4gICAgICAgIC8vIHRoaXMgbG9vcCB0d2ljZSwgb25jZSB0byB0cnkgbW92aW5nIGluIGVhY2ggZGlyZWN0aW9uLlxuICAgICAgICBwLnJlcG9zaXRpb25ZID0gIXAucmVwb3NpdGlvblk7XG5cbiAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIHB1dCBhYm92ZSwgdGhlbiB0cnkgdG8gcHV0IGJlbG93LlxuICAgICAgICBwLmFuY2hvclkgPSB0aGlzLl9nZXROZXdBbmNob3JZKHAucmVwb3NpdGlvblksICdtaWRkbGUnLCBwLmFuY2hvclgpO1xuXG4gICAgICAgIC8vIEdpdmUgdXMgb25lIG1vcmUgc2hvdCBhdCBwb3NpdGlvbmluZ1xuICAgICAgICBwLnByZXZpb3VzQXR0ZW1wdHMtLTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlUG9zaXRpb24ocCk7XG4gICAgICB9XG4gICAgICAvLyBUcnkgWFxuICAgICAgZWxzZSBpZiAocC5yZXBvc2l0aW9uWCAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgIC8vIFdpbGwgc3RhcnQgdW5kZWZpbmVkLCB0aGVuIHRydWUsIHRoZW4gZmFsc2UuIFRoaXMgbGltaXRzIHVzIHRvIGVudGVyaW5nXG4gICAgICAgICAgLy8gdGhpcyBsb29wIHR3aWNlLCBvbmNlIHRvIHRyeSBtb3ZpbmcgaW4gZWFjaCBkaXJlY3Rpb24uXG4gICAgICAgICAgcC5yZXBvc2l0aW9uWCA9ICFwLnJlcG9zaXRpb25YO1xuXG4gICAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIHB1dCBhYm92ZSwgdGhlbiB0cnkgdG8gcHV0IGJlbG93LlxuICAgICAgICAgIHAuYW5jaG9yWCA9IHRoaXMuX2dldE5ld0FuY2hvclgocC5yZXBvc2l0aW9uWCwgJ2NlbnRlcicsIHAuYW5jaG9yWSk7XG5cbiAgICAgICAgICAvLyBHaXZlIHVzIG9uZSBtb3JlIHNob3QgYXQgcG9zaXRpb25pbmdcbiAgICAgICAgICBwLnByZXZpb3VzQXR0ZW1wdHMtLTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbihwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGVsVG9wOiB0b3AsIGVsTGVmdDogbGVmdCwgYW5jaG9yWDogcC5hbmNob3JYLCBhbmNob3JZOiBwLmFuY2hvclkgfTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBuZXcgeS1heGlzIGFuY2hvclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSB1bmRlck1pbiBVbmRlciB0aGUgbWluP1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFuY2hvcllcbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JYXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2dldE5ld0FuY2hvclkgPSBmdW5jdGlvbiBfZ2V0TmV3QW5jaG9yWSh1bmRlck1pbiwgYW5jaG9yWSwgYW5jaG9yWCkge1xuXG4gICAgLy8gSWYgdGhlIHgtYXhpcyBpcyBhbmNob3JlZCBpbiB0aGUgY2VudGVyLCBza2lwXG4gICAgLy8gdHJ5aW5nIHRvIGFuY2hvciB0byB0aGUgbWlkZGxlIGJlY2F1c2UgdGhlbiB3ZSdkXG4gICAgLy8gYmUgb3ZlcmxheWluZyB0aGUgYnV0dG9uLlxuICAgIGlmIChhbmNob3JYID09PSAnY2VudGVyJyB8fCBhbmNob3JZID09PSAnbWlkZGxlJykge1xuICAgICAgcmV0dXJuIHVuZGVyTWluID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBuZXcgeS1heGlzIGFuY2hvclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSB1bmRlck1pbiBVbmRlciB0aGUgbWluP1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFuY2hvcllcbiAgICogQHBhcmFtICB7U3RyaW5nfSBhbmNob3JYXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX2dldE5ld0FuY2hvclggPSBmdW5jdGlvbiBfZ2V0TmV3QW5jaG9yWCh1bmRlck1pbiwgYW5jaG9yWCwgYW5jaG9yWSkge1xuXG4gICAgLy8gSWYgdGhlIHktYXhpcyBpcyBhbmNob3JlZCBpbiB0aGUgY2VudGVyLCBza2lwXG4gICAgLy8gdHJ5aW5nIHRvIGFuY2hvciB0byB0aGUgbWlkZGxlIGJlY2F1c2UgdGhlbiB3ZSdkXG4gICAgLy8gYmUgb3ZlcmxheWluZyB0aGUgYnV0dG9uLlxuICAgIGlmIChhbmNob3JZID09PSAnbWlkZGxlJyB8fCBhbmNob3JYID09PSAnY2VudGVyJykge1xuICAgICAgcmV0dXJuIHVuZGVyTWluID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX3Bvc2l0aW9uQ2FyZXQgPSBmdW5jdGlvbiBfcG9zaXRpb25DYXJldCgpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblxuICAgIGlmICghdGhpcy5jYXJldEVsKSByZXR1cm47XG5cbiAgICB2YXIgY2FyZXRQb3NpdGlvbiA9ICgwLCBfYm94UG9zaXRpb24yLmRlZmF1bHQpKHsgd2lkdGg6IHAuZWxXaWR0aCwgaGVpZ2h0OiBwLmVsSGVpZ2h0LCBsZWZ0OiBwLmVsTGVmdCwgdG9wOiBwLmVsVG9wIH0sIHsgd2lkdGg6IHAudGFyZ2V0V2lkdGgsIGhlaWdodDogcC50YXJnZXRIZWlnaHQsIGxlZnQ6IHAudGFyZ2V0TGVmdCwgdG9wOiBwLnRhcmdldFRvcCB9KTtcblxuICAgIHZhciBjYXJldERpbWVuc2lvbnMgPSB0aGlzLmNhcmV0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNhcmV0V2lkdGggPSBjYXJldERpbWVuc2lvbnMud2lkdGg7XG4gICAgdmFyIGNhcmV0SGVpZ2h0ID0gY2FyZXREaW1lbnNpb25zLmhlaWdodDtcbiAgICB2YXIgbGVmdCA9IE1hdGgubWluKHAuZWxXaWR0aCwgTWF0aC5tYXgoMCwgcC50YXJnZXRMZWZ0IC0gcC5lbExlZnQgKyBwLnRhcmdldFdpZHRoIC8gMikpO1xuICAgIHZhciB0b3AgPSBNYXRoLm1pbihwLmVsSGVpZ2h0LCBNYXRoLm1heCgwLCBwLnRhcmdldFRvcCAtIHAuZWxUb3AgKyBwLnRhcmdldEhlaWdodCAvIDIpKTtcblxuICAgIHRoaXMuY2FyZXRFbC5zdHlsZS5sZWZ0ID0gTWF0aC5yb3VuZChsZWZ0KSArICdweCc7XG4gICAgdGhpcy5jYXJldEVsLnN0eWxlLnRvcCA9IE1hdGgucm91bmQodG9wKSArICdweCc7XG5cbiAgICB2YXIgZXh0cmFMZWZ0ID0gMDtcbiAgICB2YXIgZXh0cmFUb3AgPSAwO1xuXG4gICAgdGhpcy5jYXJldEVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wb3NpdGlvbicsIGNhcmV0UG9zaXRpb24pO1xuXG4gICAgc3dpdGNoIChjYXJldFBvc2l0aW9uKSB7XG4gICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgIGV4dHJhVG9wID0gLWNhcmV0V2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JlbG93JzpcbiAgICAgICAgZXh0cmFUb3AgPSBjYXJldFdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZXh0cmFMZWZ0ID0gLWNhcmV0SGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBleHRyYUxlZnQgPSBjYXJldEhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHRyYUxlZnQ6IGV4dHJhTGVmdCxcbiAgICAgIGV4dHJhVG9wOiBleHRyYVRvcFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcm9vdCBlbGVtZW50LiBXYW50IHRvIGNoZWNrIGlmIHRoZXJlJ3MgYSB0b3AtbGV2ZWwgZm9ybSBmb3Igd29ya2luZ1xuICAgKiB3aXRoIEFTUCAuTkVUIHBhZ2VzLlxuICAgKi9cblxuXG4gIEFmZml4LnByb3RvdHlwZS5fZ2V0Um9vdEVsID0gZnVuY3Rpb24gX2dldFJvb3RFbCgpIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHkgPiBmb3JtJyk7XG4gICAgcmV0dXJuIGZvcm0gJiYgZm9ybS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWZmaXhlZCcpID09PSBudWxsID8gZm9ybSA6IGRvY3VtZW50LmJvZHk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9uIHJlc2l6ZSwgdXBkYXRlIHRoZSBwb3NpdGlvbi5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpbmRvdyBzY3JvbGxzLCBlbnN1cmUgdGhlIHByb3BlciBwb3NpdGlvbiBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG5cblxuICBBZmZpeC5wcm90b3R5cGUuX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICAgIHRoaXMuX3VwZGF0ZURlYm91bmNlZCgpO1xuICB9O1xuXG4gIHJldHVybiBBZmZpeDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQWZmaXg7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmZml4LmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gIHZhciBhWFNwYW4gPSBhLmxlZnQgKyBhLndpZHRoO1xuICB2YXIgYVlTcGFuID0gYS50b3AgKyBhLmhlaWdodDtcbiAgdmFyIGJYU3BhbiA9IGIubGVmdCArIGIud2lkdGg7XG4gIHZhciBiWVNwYW4gPSBiLnRvcCArIGIuaGVpZ2h0O1xuXG4gIGlmIChhWFNwYW4gPD0gYi5sZWZ0KSByZXR1cm4gJ2xlZnQnOyAvLyBhIGlzIGZ1bGx5IGxlZnQgb2YgYlxuICBpZiAoYS5sZWZ0ID49IGJYU3BhbikgcmV0dXJuICdyaWdodCc7IC8vIGEgaXMgZnVsbHkgcmlnaHQgb2YgYlxuICBpZiAoYVlTcGFuIDw9IGIudG9wKSByZXR1cm4gJ2Fib3ZlJzsgLy8gYSBpcyBmdWxseSBhYm92ZSBiXG4gIGlmIChhLnRvcCA+PSBiWVNwYW4pIHJldHVybiAnYmVsb3cnOyAvLyBhIGlzIGZ1bGx5IGJlbG93IGJcblxuICByZXR1cm4gJ292ZXJsYXAnOyAvLyBib3hlcyBvdmVybGFwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBCb3ggUG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBIb3cgaXMgb25lIGVsZW1lbnQgcG9zaXRpb25lZCByZWxhdGl2ZSB0byBhbm90aGVyP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBib3hQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB7d2lkdGg6IDEwMCwgaGVpZ2h0OiAzMDAsIGxlZnQ6IDAsIHRvcDogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoge3dpZHRoOiAyMDAsIGhlaWdodDogNTAsIGxlZnQ6IDEwMCwgdG9wOiA0MH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGhlbHBlcnMvcG9zaXRpb24vYm94LXBvc2l0aW9uLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym94LXBvc2l0aW9uLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGNoZXMgPSByZXF1aXJlKCcuL21hdGNoZXMnKTtcblxudmFyIF9tYXRjaGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRQYXJlbnQocGFyZW50LCBxdWVyeSwgbGltaXRFbCkge1xuXG4gIGxpbWl0RWwgPSBsaW1pdEVsIGluc3RhbmNlb2YgQXJyYXkgPyBsaW1pdEVsIDogW2xpbWl0RWwgfHwgZG9jdW1lbnQuYm9keV07XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuXG4gICAgaWYgKCgwLCBfbWF0Y2hlczIuZGVmYXVsdCkocGFyZW50LCBxdWVyeSkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGxpbWl0RWwuaW5kZXhPZihwYXJlbnQpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvKipcbiAgICogIyBHZXQgUGFyZW50XG4gICAqIFNlZSBpZiBhbiBlbGVtZW50IGhhcyBhbm90aGVyIGVsZW1lbnQgZm9yIGEgcGFyZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlcbiAgICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBsaW1pdEVsIFRoZSBsYXN0IGVsZW1lbnQgd2Ugc2hvdWxkIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufEVsZW1lbnR9XG4gICAqXG4gICAqIEBtb2R1bGUgaGVscGVycy90cmF2ZXJzYWwvZ2V0LXBhcmVudC5qc1xuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0UGFyZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcGFyZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgSGFzIFBhcmVudFxuICogU2VlIGlmIGFuIGVsZW1lbnQgaGFzIGFub3RoZXIgZWxlbWVudCBmb3IgYSBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZFxuICogQHBhcmFtIHtFbGVtZW50fSBwb3NzaWJsZVBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL2hhcy1wYXJlbnQuanNcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KGNoaWxkLCBwb3NzaWJsZVBhcmVudCkge1xuXG4gIHZhciBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcblxuICAgIGlmIChwYXJlbnQgPT09IHBvc3NpYmxlUGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gaGFzUGFyZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1wYXJlbnQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqICMgTWF0Y2hlc1xuICogU2VlIGlmIGFuIGVsZW1lbnQgbWF0Y2hlcyBhIHF1ZXJ5IHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqXG4gKiBAbW9kdWxlIGhlbHBlcnMvdHJhdmVyc2FsL21hdGNoZXMuanNcbiAqL1xudmFyIHZlbmRvck1hdGNoID0gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IpO1xuXG5mdW5jdGlvbiBtYXRjaGVzKGVsLCBxdWVyeSkge1xuXG4gIGlmICh2ZW5kb3JNYXRjaCkgcmV0dXJuIHZlbmRvck1hdGNoLmNhbGwoZWwsIHF1ZXJ5KTtcblxuICB2YXIgbm9kZXMgPSBlbC5wYXJlbnROb2RlID8gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSA6IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2hlcy5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIERlYm91bmNlXG4gKiBEZWJvdW5jZSBhIGZ1bmN0aW9uIGNhbGxcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGRlbGF5XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvZGVib3VuY2UuanNcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgZGVsYXkpIHtcblxuICB2YXIgdGltZXIgPSB2b2lkIDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAodGltZXIpIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LCBkZWxheSk7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlYm91bmNlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIEVhY2hcbiAqIEFwcGx5IGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGFueSBraW5kOiBBcnJheSwgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uIG9yIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE5vZGVMaXN0fEhUTUxDb2xsZWN0aW9ufE9iamVjdH0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqXG4gKiBAZXhhbXBsZVxuICogZWFjaChbXSwgY2FsbGJhY2spO1xuICogZWFjaChlbC5jaGlsZHJlbiwgY2FsbGJhY2spO1xuICogZWFjaChlbC5jaGlsZE5vZGVzLCBjYWxsYmFjayk7XG4gKiBlYWNoKHt9LCBjYWxsYmFjayk7XG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvZWFjaC5qc1xuICovXG5mdW5jdGlvbiBlYWNoKGxpc3QsIGNiKSB7XG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludm9rZSBgZWFjaGAgd2l0aG91dCBhIGNhbGxiYWNrIScpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgLy8gT2JqZWN0XG4gIGlmIChsZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoaSBpbiBsaXN0KSB7XG4gICAgICBpZiAoaSAhPT0gJ3Byb3RvdHlwZScgJiYgbGlzdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBjYihpLCBsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQXJyYXktbGlrZVxuICBlbHNlIHtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2IobGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBlYWNoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYWNoLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiAjIFRyaW1cbiAqIFRyaW0gd2hpdGVzcGFjZSBvbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKlxuICogQG1vZHVsZSBoZWxwZXJzL3V0aWwvdHJpbS5qc1xuICovXG5cbnZhciB0cmltUkUgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh0cmltUkUsICcnKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHJpbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpbS5qcy5tYXBcbiJdfQ=="}