{"version":3,"sources":["js/dist/components/node_modules/browser-pack/_prelude.js","js/dist/components/js/dist/components/base.js","js/dist/components/js/dist/components/step-indicator.js","js/dist/components/js/dist/helpers/dom/add-class.js","js/dist/components/js/dist/helpers/dom/has-class.js","js/dist/components/js/dist/helpers/dom/remove-class.js","js/dist/components/js/dist/helpers/util/each.js","js/dist/components/js/dist/helpers/util/trim.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"step-indicator.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _each = require('../helpers/util/each');\n\nvar _each2 = _interopRequireDefault(_each);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * # Base Component\n                                                                                                                                                           * The base class for Spark JS components. This class should never be\n                                                                                                                                                           * instantiated directly.\n                                                                                                                                                           *\n                                                                                                                                                           * @param {Element} el\n                                                                                                                                                           * @param {Object} params\n                                                                                                                                                           *\n                                                                                                                                                           * @module components/base.js\n                                                                                                                                                           */\n\nvar noop = function noop() {};\n\nvar Base = function () {\n\n  /**\n   * Set parameters and cache elements.\n   */\n  function Base(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Base);\n\n    if (params.elRequired && !el) {\n      return;\n    }\n\n    this.setParams(this.defaults || {}, true);\n    this.setParams(params);\n    (this._cacheElements || noop).call(this, el, params);\n    (this._parseParams || noop).call(this);\n  }\n\n  /**\n   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.\n   * @param {Boolean} leaveElement Leave the element intact.\n   */\n\n\n  Base.prototype.remove = function remove(leaveElement) {\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    if (!leaveElement && this.el && this.el.parentNode) {\n      this.el.parentNode.removeChild(this.el);\n    }\n\n    this.unsetParams(this.defaults);\n\n    return this;\n  };\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   * @param {Object} params Optional\n   */\n\n\n  Base.prototype.update = function update(el) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    if (this._removeEventListeners) {\n      this._removeEventListeners();\n    }\n\n    (this._cacheElements || noop).call(this, el || this.el, params);\n    (this._parseParams || noop).call(this);\n\n    if (this._addEventListeners) {\n      this._addEventListeners();\n    }\n\n    return this;\n  };\n\n  /**\n   * Set a hash of parameters if they're whitelisted or we're told to force the set.\n   * This is used to set initial values as well as set passed parameters.\n   * @param {Object} params\n   * @param {Boolean} force Force setting even if the param is not whitelisted.\n   */\n\n\n  Base.prototype.setParams = function setParams(params, force) {\n    var _this = this;\n\n    (0, _each2.default)(params, function (k, v) {\n      if (_this._whitelistedParams.indexOf(k) !== -1 || force) {\n        _this[k] = v;\n      }\n    });\n\n    return this;\n  };\n\n  /**\n   * Unset all parameters.\n   * @param {Array|Object} keys\n   * @param {Object} scope The object to unset the params from. Defaults to `this`.\n   */\n\n\n  Base.prototype.unsetParams = function unsetParams(keys, scope) {\n\n    keys = keys instanceof Array ? keys : Object.keys(keys);\n    scope = scope || this;\n    (0, _each2.default)(keys, function (k) {\n      delete scope[k];\n    });\n\n    return this;\n  };\n\n  return Base;\n}();\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nBase.prototype._whitelistedParams = [];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nBase.prototype.defaults = {};\n\nexports.default = Base;\nmodule.exports = exports['default'];\n//# sourceMappingURL=base.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = require('./base');\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _addClass = require('../helpers/dom/add-class');\n\nvar _addClass2 = _interopRequireDefault(_addClass);\n\nvar _removeClass = require('../helpers/dom/remove-class');\n\nvar _removeClass2 = _interopRequireDefault(_removeClass);\n\nvar _hasClass = require('../helpers/dom/has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * # Step Indicator\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Set of indicators represent different steps\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @example\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * new StepIndicator(el, params);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module components/step-indicator.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar noop = function noop() {};\n\nvar StepIndicator = function (_BaseComponent) {\n  _inherits(StepIndicator, _BaseComponent);\n\n  /**\n   * StepIndicator constructor.\n   * @param {Element} el\n   * @param {Object} params\n   */\n  function StepIndicator(el) {\n    var _this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, StepIndicator);\n\n    if (!(_this = _possibleConstructorReturn(this, _BaseComponent.call(this, el, params)), _this)) {\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._bindEventListenerCallbacks();\n    _this._addEventListeners();\n    _this._calculateStyle();\n    return _possibleConstructorReturn(_this);\n  }\n\n  /**\n   * Update the component to use a new element or reparse from\n   * the existing element.\n   * @param {Element} el Optional\n   */\n\n\n  StepIndicator.prototype.update = function update(el) {\n\n    this._removeEventListeners();\n    this._cacheElements(el || this.el);\n    this._parseParams();\n    this._addEventListeners();\n    this._calculateStyle();\n\n    return this;\n  };\n\n  /**\n   * Store a reference to the element.\n   * @param {Element} el\n   */\n\n\n  StepIndicator.prototype._cacheElements = function _cacheElements(el) {\n    this.el = el;\n    this.containerEl = this.containerEl || el.parentNode;\n    this._body = this.el.querySelector('.spark-step-indicator__body');\n    this._list = this.el.querySelector('.spark-step-indicator__list');\n    this._items = this.el.querySelectorAll('.spark-step-indicator__item');\n  };\n\n  /**\n   * Parse parameters from the element.\n   */\n\n\n  StepIndicator.prototype._parseParams = function _parseParams() {\n    this.type = this.type !== null ? this.type : this.el.attributes['data-type'] && this.el.attributes['data-type'].value;\n    this.header = this.header !== null ? this.header : this.el.attributes['data-header'] && true;\n    this.subtitle = this.subtitle !== null ? this.subtitle : this.el.attributes['data-subtitle'] && true;\n  };\n\n  /**\n   * Create bound versions of event listener callbacks and store them.\n   * Otherwise we can't unbind from these events later because the\n   * function signatures won't match.\n   */\n\n\n  StepIndicator.prototype._bindEventListenerCallbacks = function _bindEventListenerCallbacks() {\n    this._onResizeBound = this._onResize.bind(this);\n    this._onLoadBound = this._onLoad.bind(this);\n    this._onVisibleBound = this._onVisible.bind(this);\n    this._toggleDropdownBound = this._toggleDropdown.bind(this);\n  };\n\n  /**\n   * Add event listeners for DOM events.\n   */\n\n\n  StepIndicator.prototype._addEventListeners = function _addEventListeners() {\n    window.addEventListener('resize', this._onResizeBound);\n    document.addEventListener('spark.visible-children', this._onVisibleBound, true);\n    window.addEventListener('load', this._onLoadBound);\n  };\n\n  /**\n   * Remove event listeners for DOM events..\n   */\n\n\n  StepIndicator.prototype._removeEventListeners = function _removeEventListeners() {\n    window.removeEventListener('resize', this._onResizeBound);\n    document.removeEventListener('spark.visible-children', this._onVisibleBound, true);\n    document.removeEventListener('click', this._toggleDropdownBound);\n    window.removeEventListener('load', this._onLoadBound);\n  };\n\n  /**\n   * Change selected step state into incomplete\n   * @param {Int} index of selected step\n   */\n\n\n  StepIndicator.prototype._resetStepState = function _resetStepState(stepIndex) {\n    if (stepIndex < 0 || stepIndex >= this._items.length) {\n      return;\n    }\n    (0, _removeClass2.default)(this._items[stepIndex], ['spark-step-indicator__item--completed', 'spark-step-indicator__item--current', 'spark-step-indicator__item--disabled']);\n  };\n\n  /**\n   * Set selected step state: completed/current/disabled/incomplete\n   * For current step, will remove current step from other steps\n   * @param {Int} index of selected step\n   * @param {String} state to be set\n   */\n\n\n  StepIndicator.prototype.setStepState = function setStepState(stepIndex, state) {\n    if (stepIndex < 0 || stepIndex >= this._items.length) {\n      return this;\n    }\n    switch (state) {\n      case 'completed':\n        this._resetStepState(stepIndex);\n        (0, _addClass2.default)(this._items[stepIndex], 'spark-step-indicator__item--completed');\n        break;\n      case 'current':\n        var currentStep = this._list.querySelector('.spark-step-indicator__item--current');\n        (0, _removeClass2.default)(currentStep, 'spark-step-indicator__item--current');\n        (0, _addClass2.default)(this._items[stepIndex], 'spark-step-indicator__item--current');\n        break;\n      case 'disabled':\n        this._resetStepState(stepIndex);\n        (0, _addClass2.default)(this._items[stepIndex], 'spark-step-indicator__item--disabled');\n        break;\n      case 'incomplete':\n        this._resetStepState(stepIndex);\n        break;\n    }\n    this._calculateStyle();\n    return this;\n  };\n\n  /**\n   * Provide a method to bind click callback function to certain step.\n   * @param {Array} a set of step indices represent the target of callback\n   * @param {Function} callback function\n   */\n\n\n  StepIndicator.prototype.bindStepClickCallback = function bindStepClickCallback(indexArr, callback) {\n    callback = callback || noop;\n    for (var i = 0; i < indexArr.length; i++) {\n      this._items[indexArr[i]].addEventListener('click', callback);\n    }\n    return this;\n  };\n\n  /**\n   * Remove click callback from steps\n   * @param {Array} a set of step indices represent the target of callback\n   * @param {Function} callback function\n   *\n   */\n\n\n  StepIndicator.prototype.removeStepClickCallback = function removeStepClickCallback(indexArr, callback) {\n    callback = callback || noop;\n    for (var i = 0; i < indexArr.length; i++) {\n      this._items[indexArr[i]].removeEventListener('click', callback);\n    }\n    return this;\n  };\n\n  /**\n   * Work for _calculateStyle.\n   * Comparing the width of list and total items, including padding\n   * Sometimes after calculating, even itemTotalWidth is bigger 1px than listWidth,\n   * it also means items are fit in the list, not over width.\n   * So add 2px to list width when comparing to avoid this.\n   * @return {Boolean}\n   */\n\n\n  StepIndicator.prototype._isOverWidth = function _isOverWidth() {\n    var listWidth = this._list.offsetWidth;\n    var itemTotalWidth = this._listPaddingTotal;\n    for (var i = 0; i < this._items.length; i++) {\n      itemTotalWidth += this._items[i].offsetWidth;\n    }\n    if (listWidth + 2 < itemTotalWidth) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Calcuate different style based settings\n   */\n\n\n  StepIndicator.prototype._calculateStyle = function _calculateStyle() {\n    if (!this.header) {\n      var titleEl = this.el.querySelector('.spark-step-indicator__title');\n      titleEl.style.display = 'none';\n      (0, _addClass2.default)(this._body, 'spark-step-indicator__body--no-border');\n    }\n    if (!this.subtitle) {\n      var subtitleEl = this.el.querySelector('.spark-step-indicator__subtitle');\n      subtitleEl.style.display = 'none';\n    }\n    // Remove special DOM and Class of dropdown variation\n    this._switchFromDropdown();\n    switch (this.type) {\n      case 'standard-dropdown':\n        this._calculateRespStyle();\n        break;\n      case 'large':\n        this._calculateLargeStyle();\n        break;\n      case 'condensed':\n        this._calculateCondensedStyle();\n        break;\n      case 'dropdown':\n        this._calculateDropdownStyle();\n        break;\n      default:\n        this._calculateStandardStyle();\n    }\n    // Work for IE11, detect IE11 via userAgent\n    // userAgent: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv 11.0) like Gecko\n    var isIE11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));\n    if (isIE11) {\n      this._addItemWidth();\n    }\n  };\n\n  /**\n   * For IE11 ONLY, Add width: 100% to work around IE11 bug\n   * IE11 will have incorrect position with flex-grow max-width and justify-content when items hit max-width\n   * Sometimes after calculating, even itemTotalWidth is less 1px than listWidth,\n   * it also means items are fit in the list, not hit the max-width\n   * So add 2px to list width when comparing to avoid this.\n   */\n\n\n  StepIndicator.prototype._addItemWidth = function _addItemWidth() {\n    if (!(0, _hasClass2.default)(this._list, 'spark-step-indicator__list--condensed') && !(0, _hasClass2.default)(this._body, 'spark-step-indicator__body--dropdown')) {\n      var listWidth = this._list.offsetWidth;\n      var itemTotalWidth = this._listPaddingTotal;\n      for (var i = 0; i < this._items.length; i++) {\n        itemTotalWidth += this._items[i].offsetWidth;\n      }\n      if (listWidth - itemTotalWidth > 2) {\n        this._switchWidthForIe11(0, true);\n      } else {\n        this._switchWidthForIe11(0, false);\n      }\n    } else {\n      this._switchWidthForIe11(0, false);\n    }\n  };\n\n  /**\n   * Switch spark-step-indicator__item style width: 100% to work around IE11 bug\n   * @param {Number} start index of step\n   * @param {Boolean} whether add width: 100%\n   */\n\n\n  StepIndicator.prototype._switchWidthForIe11 = function _switchWidthForIe11(index, val) {\n    for (var i = index; i < this._items.length; i++) {\n      this._items[i].style.width = val ? '100%' : '';\n    }\n  };\n\n  /**\n   * Fix on large variation\n   * Calculate node and list length remove connect line of each end\n   * Sometimes after calculating, even itemTotalWidth is bigger 1px than listWidth,\n   * it also means items are fit in the list, not over width.\n   * So add 2px to list width when comparing to avoid this.\n   * Dependency of _calculateCondensedStyle() and _calculateStandardStyle()\n   *\n   */\n\n\n  StepIndicator.prototype._calculateLargeStyle = function _calculateLargeStyle() {\n    this._list.style['flex-wrap'] = 'wrap';\n    var listWidth = this._list.offsetWidth;\n    var itemTotalWidth = this._listPaddingTotal;\n    for (var i = 0; i < this._items.length; i++) {\n      (0, _removeClass2.default)(this._items[i], 'noline');\n      itemTotalWidth += this._items[i].offsetWidth;\n      if (listWidth + 2 < itemTotalWidth && i > 0) {\n        (0, _addClass2.default)(this._items[i - 1], 'noline');\n        itemTotalWidth = this._items[i].offsetWidth + this._listPaddingTotal;\n      }\n    }\n  };\n\n  /**\n   * Fix on condensed variation\n   * Same as fix large variation except CSS class\n   */\n\n\n  StepIndicator.prototype._calculateCondensedStyle = function _calculateCondensedStyle() {\n    (0, _addClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n    this._calculateLargeStyle();\n  };\n\n  /**\n   * Fix on dropdown variation\n   */\n\n\n  StepIndicator.prototype._calculateDropdownStyle = function _calculateDropdownStyle() {\n    this._switchToDropdown();\n  };\n\n  /**\n   * Change only between large and condensed variation\n   * no dropdown variation\n   */\n\n\n  StepIndicator.prototype._calculateStandardStyle = function _calculateStandardStyle() {\n    this._list.style.visibility = 'hidden';\n    for (var i = 0; i < this._items.length; i++) {\n      (0, _removeClass2.default)(this._items[i], 'noline');\n    }\n    (0, _removeClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n    if (this._isOverWidth()) {\n      (0, _addClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n      this._calculateLargeStyle();\n    }\n    this._list.style.visibility = 'visible';\n  };\n\n  /**\n   * Make list invisible and change it into large variation at first.\n   * Switch variation from top to bottom to find the fit one\n   */\n\n\n  StepIndicator.prototype._calculateRespStyle = function _calculateRespStyle() {\n    this._list.style.visibility = 'hidden';\n    (0, _removeClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n    if (this._isOverWidth()) {\n      (0, _addClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n      if (this._isOverWidth()) {\n        (0, _removeClass2.default)(this._list, 'spark-step-indicator__list--condensed');\n        this._switchToDropdown();\n      }\n    }\n    this._list.style.visibility = 'visible';\n  };\n\n  /**\n   * Create header element for dropdown variation\n   * Try to find the current step of indicator and show it on the header\n   * if not found, show the first step\n   * @return {Object} header element of dropdown variation\n   */\n\n\n  StepIndicator.prototype._createDropdownHeader = function _createDropdownHeader() {\n    var el = document.createElement('a');\n    var currentStep = this._list.querySelector('.spark-step-indicator__item--current');\n    // Can not find current step\n    if (!currentStep) {\n      currentStep = this._items[0];\n    }\n    el.innerHTML = currentStep.innerHTML;\n    el.innerHTML += '<span class=\"spark-step-indicator__notice\">Select a Step</span>';\n\n    // Create label element like '2 of 7'\n    var stepNotice = document.createElement('span');\n    var currentIndex = Array.prototype.indexOf.call(this._items, currentStep);\n    stepNotice.innerHTML = currentIndex + 1 + ' of ' + this._items.length;\n    stepNotice.className = 'spark-step-indicator__label--dropdown';\n\n    el.appendChild(stepNotice);\n    el.className = currentStep.className;\n    (0, _addClass2.default)(el, 'spark-step-indicator__item--dropdown__header');\n    this._dropdownHeader = el;\n  };\n\n  /**\n   * Some extra event binder and DOM of dropdown variation need to be set\n   */\n\n\n  StepIndicator.prototype._switchToDropdown = function _switchToDropdown() {\n    (0, _addClass2.default)(this._body, 'spark-step-indicator__body--dropdown');\n    this._createDropdownHeader();\n    this._list.parentNode.insertBefore(this._dropdownHeader, this._list);\n    document.removeEventListener('click', this._toggleDropdownBound);\n    document.addEventListener('click', this._toggleDropdownBound);\n    (0, _addClass2.default)(this._list, 'collapse');\n  };\n\n  /**\n   * Remove extra event and DOM when switch variation from dropdown\n   */\n\n\n  StepIndicator.prototype._switchFromDropdown = function _switchFromDropdown() {\n    (0, _removeClass2.default)(this._body, 'spark-step-indicator__body--dropdown');\n    var header = this._list.parentNode.querySelector('.spark-step-indicator__item--dropdown__header');\n    document.removeEventListener('click', this._toggleDropdownBound);\n    if (header) {\n      this._list.parentNode.removeChild(header);\n    }\n    (0, _removeClass2.default)(this._list, 'collapse');\n  };\n\n  /**\n   * Toggle collapse/expand state of step list in dropdown variation\n   * If there is a scroll in dropdown variation, scroll to 'current' node\n   * @param {Object} Reference of DOM obj\n   * @param {Object} Event of click\n   */\n\n\n  StepIndicator.prototype._toggleDropdown = function _toggleDropdown(e) {\n    var target = e.target || e.srcElement;\n    if (this._dropdownHeader.contains(target)) {\n      if (!this._dropdownExpand) {\n        (0, _removeClass2.default)(this._list, 'collapse');\n        (0, _addClass2.default)(this._dropdownHeader, 'expand');\n        this._dropdownExpand = true;\n      } else {\n        (0, _addClass2.default)(this._list, 'collapse');\n        (0, _removeClass2.default)(this._dropdownHeader, 'expand');\n        this._dropdownExpand = false;\n      }\n    } else {\n      (0, _addClass2.default)(this._list, 'collapse');\n      (0, _removeClass2.default)(this._dropdownHeader, 'expand');\n      this._dropdownExpand = false;\n    }\n    if (this._list.offsetHeight > 0) {\n      var scrollMove = 0;\n      for (var i = 0; i < this._items.length; i++) {\n        if ((0, _hasClass2.default)(this._items[i], 'spark-step-indicator__item--current')) {\n          this._list.scrollTop = scrollMove;\n          break;\n        }\n        scrollMove += this._items[i].offsetHeight;\n      }\n    }\n  };\n\n  /**\n   * When the window finish loading\n   */\n\n\n  StepIndicator.prototype._onLoad = function _onLoad() {\n    // Cache list left + right padding for width calculating\n    var listStyles = getComputedStyle(this._list);\n    var listPaddingLeft = parseInt(listStyles.getPropertyValue('padding-left'), 10);\n    var listPaddingRight = parseInt(listStyles.getPropertyValue('padding-right'), 10);\n    this._listPaddingTotal = listPaddingLeft + listPaddingRight;\n    this._calculateStyle();\n  };\n\n  /**\n   * When the window is resized, base on params make some reponsive change.\n   */\n\n\n  StepIndicator.prototype._onResize = function _onResize() {\n    this._calculateStyle();\n  };\n\n  /**\n   * When a parent container shows its children and our element\n   * is inside of it, resize\n   * @param  {Object} e\n   */\n\n\n  StepIndicator.prototype._onVisible = function _onVisible(e) {\n    if (e.target.contains(this.el)) {\n      window.setTimeout(function () {\n        this._calculateStyle();\n      }.bind(this), 0);\n    }\n  };\n\n  return StepIndicator;\n}(_base2.default);\n\n/**\n * Whitelisted parameters which can be set on construction.\n * @type {Array}\n */\n\n\nStepIndicator.prototype._whitelistedParams = ['type', 'header', 'subtitle'];\n\n/**\n * Default values for internal properties we will be setting.\n * These are set on each construction so we don't leak properties\n * into the prototype chain.\n * @type {Object}\n */\nStepIndicator.prototype.defaults = {\n  el: null,\n  containerEl: null,\n  header: null,\n  subtitle: null,\n  type: null,\n  _body: null,\n  _list: null,\n  _listPaddingTotal: 0,\n  _dropdownExpand: false,\n  _dropdownHeader: null,\n  _items: null,\n  _onResizeBound: null,\n  _onVisibleBound: null\n};\n\nexports.default = StepIndicator;\nmodule.exports = exports['default'];\n//# sourceMappingURL=step-indicator.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nvar _hasClass = require('./has-class');\n\nvar _hasClass2 = _interopRequireDefault(_hasClass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * # Add Class\n * Add a class on an element.\n *\n * @param {Element|Array} el An element or array of elements to update.\n * @param {String} name\n * @return {Element}\n *\n * @module helpers/dom/add-class.js\n */\n\nvar ws = /\\s+/;\nvar cleanup = /\\s{2,}/g;\n\nfunction addClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) {\n      el.classList.add(name[0]);\n    }\n    return el;\n  }\n\n  var toAdd = [];\n  var i = 0;\n  var l = name.length;\n  var item = void 0;\n  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';\n\n  // see if we have anything to add\n  for (; i < l; i++) {\n    item = name[i];\n    if (item && !(0, _hasClass2.default)(clsName, item)) {\n      toAdd.push(item);\n    }\n  }\n\n  if (toAdd.length) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = addClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=add-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * # Has Class\n * See if an element has a class.\n *\n * @param {Element|String} el\n * @param {String} name\n * @return {Boolean}\n *\n * @module helpers/dom/has-class.js\n */\nfunction hasClass(el, name) {\n  var cName = ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\\t\\r\\n\\f]/g, ' ');\n  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;\n}\n\nexports.default = hasClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=has-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _trim = require('../util/trim');\n\nvar _trim2 = _interopRequireDefault(_trim);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ws = /\\s+/; /**\n                 * # Remove Class\n                 * Remove a class on an element.\n                 *\n                 * @param {Element|Array} el An element or array of elements to update.\n                 * @param {String} name\n                 * @return {Element}\n                 *\n                 * @module helpers/dom/remove-class.js\n                 */\n\nvar cleanup = /\\s{2,}/g;\n\nfunction removeClass(el, name) {\n\n  if (arguments.length === 2 && typeof name === 'string') {\n    name = (0, _trim2.default)(name).split(ws);\n  } else {\n    name = name instanceof Array ? name : Array.prototype.slice.call(arguments, 1);\n  }\n\n  // optimize for best, most common case\n  if (name.length === 1 && el.classList) {\n    if (name[0]) el.classList.remove(name[0]);\n    return el;\n  }\n\n  // store two copies\n  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';\n  var result = clsName;\n  var current = void 0;\n  var start = void 0;\n  for (var i = 0, l = name.length; i < l; i++) {\n    current = name[i];\n    start = current ? result.indexOf(' ' + current + ' ') : -1;\n    if (start !== -1) {\n      start += 1;\n      result = result.slice(0, start) + result.slice(start + current.length);\n    }\n  }\n\n  // only write if modified\n  if (clsName !== result) {\n    if (typeof el.className === 'string') {\n      el.className = (0, _trim2.default)(result.replace(cleanup, ' '));\n    } else if (el.setAttribute) {\n      el.setAttribute('class', (0, _trim2.default)(result.replace(cleanup, ' ')));\n    }\n  }\n\n  return el;\n}\n\nexports.default = removeClass;\nmodule.exports = exports['default'];\n//# sourceMappingURL=remove-class.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Each\n * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.\n *\n * @param {Array|NodeList|HTMLCollection|Object} list\n * @param {Function} cb\n *\n * @example\n * each([], callback);\n * each(el.children, callback);\n * each(el.childNodes, callback);\n * each({}, callback);\n *\n * @module helpers/util/each.js\n */\nfunction each(list, cb) {\n\n  if (!list) {\n    return;\n  }\n\n  if (typeof cb !== 'function') {\n    throw new Error('Cannot invoke `each` without a callback!');\n  }\n\n  var i = 0;\n  var len = list.length;\n\n  // Object\n  if (len === undefined) {\n    for (i in list) {\n      if (i !== 'prototype' && list.hasOwnProperty(i)) {\n        cb(i, list[i]);\n      }\n    }\n  }\n  // Array-like\n  else {\n      for (; i < len; i++) {\n        cb(list[i]);\n      }\n    }\n}\n\nexports.default = each;\nmodule.exports = exports['default'];\n//# sourceMappingURL=each.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * # Trim\n * Trim whitespace on a string.\n *\n * @param {String} str\n *\n * @module helpers/util/trim.js\n */\n\nvar trimRE = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction trim(str) {\n  return str.replace(trimRE, '');\n}\n\nexports.default = trim;\nmodule.exports = exports['default'];\n//# sourceMappingURL=trim.js.map\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kaXN0L2NvbXBvbmVudHMvYmFzZS5qcyIsImpzL2Rpc3QvY29tcG9uZW50cy9zdGVwLWluZGljYXRvci5qcyIsImpzL2Rpc3QvaGVscGVycy9kb20vYWRkLWNsYXNzLmpzIiwianMvZGlzdC9oZWxwZXJzL2RvbS9oYXMtY2xhc3MuanMiLCJqcy9kaXN0L2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcy5qcyIsImpzL2Rpc3QvaGVscGVycy91dGlsL2VhY2guanMiLCJqcy9kaXN0L2hlbHBlcnMvdXRpbC90cmltLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNua0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdXRpbC9lYWNoJyk7XG5cbnZhciBfZWFjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIyBCYXNlIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBiYXNlIGNsYXNzIGZvciBTcGFyayBKUyBjb21wb25lbnRzLiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIGNvbXBvbmVudHMvYmFzZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIEJhc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIGFuZCBjYWNoZSBlbGVtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2UoZWwpIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIGlmIChwYXJhbXMuZWxSZXF1aXJlZCAmJiAhZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFBhcmFtcyh0aGlzLmRlZmF1bHRzIHx8IHt9LCB0cnVlKTtcbiAgICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICh0aGlzLl9jYWNoZUVsZW1lbnRzIHx8IG5vb3ApLmNhbGwodGhpcywgZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCBwcmVwYXJlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgZGVyZWZlcmVuY2luZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGVhdmVFbGVtZW50IExlYXZlIHRoZSBlbGVtZW50IGludGFjdC5cbiAgICovXG5cblxuICBCYXNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobGVhdmVFbGVtZW50KSB7XG5cbiAgICBpZiAodGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWF2ZUVsZW1lbnQgJiYgdGhpcy5lbCAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuc2V0UGFyYW1zKHRoaXMuZGVmYXVsdHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIHVzZSBhIG5ldyBlbGVtZW50IG9yIHJlcGFyc2UgZnJvbVxuICAgKiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBPcHRpb25hbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE9wdGlvbmFsXG4gICAqL1xuXG5cbiAgQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGVsKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblxuICAgIGlmICh0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAodGhpcy5fY2FjaGVFbGVtZW50cyB8fCBub29wKS5jYWxsKHRoaXMsIGVsIHx8IHRoaXMuZWwsIHBhcmFtcyk7XG4gICAgKHRoaXMuX3BhcnNlUGFyYW1zIHx8IG5vb3ApLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIGhhc2ggb2YgcGFyYW1ldGVycyBpZiB0aGV5J3JlIHdoaXRlbGlzdGVkIG9yIHdlJ3JlIHRvbGQgdG8gZm9yY2UgdGhlIHNldC5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHNldCBpbml0aWFsIHZhbHVlcyBhcyB3ZWxsIGFzIHNldCBwYXNzZWQgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHNldHRpbmcgZXZlbiBpZiB0aGUgcGFyYW0gaXMgbm90IHdoaXRlbGlzdGVkLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIHNldFBhcmFtcyhwYXJhbXMsIGZvcmNlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkocGFyYW1zLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgaWYgKF90aGlzLl93aGl0ZWxpc3RlZFBhcmFtcy5pbmRleE9mKGspICE9PSAtMSB8fCBmb3JjZSkge1xuICAgICAgICBfdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVW5zZXQgYWxsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgb2JqZWN0IHRvIHVuc2V0IHRoZSBwYXJhbXMgZnJvbS4gRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgKi9cblxuXG4gIEJhc2UucHJvdG90eXBlLnVuc2V0UGFyYW1zID0gZnVuY3Rpb24gdW5zZXRQYXJhbXMoa2V5cywgc2NvcGUpIHtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXkgPyBrZXlzIDogT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgIGRlbGV0ZSBzY29wZVtrXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG4vKipcbiAqIFdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgd2hpY2ggY2FuIGJlIHNldCBvbiBjb25zdHJ1Y3Rpb24uXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblxuXG5CYXNlLnByb3RvdHlwZS5fd2hpdGVsaXN0ZWRQYXJhbXMgPSBbXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQmFzZS5wcm90b3R5cGUuZGVmYXVsdHMgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcblxudmFyIF9hZGRDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2FkZC1jbGFzcycpO1xuXG52YXIgX2FkZENsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkZENsYXNzKTtcblxudmFyIF9yZW1vdmVDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL3JlbW92ZS1jbGFzcycpO1xuXG52YXIgX3JlbW92ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUNsYXNzKTtcblxudmFyIF9oYXNDbGFzcyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tL2hhcy1jbGFzcycpO1xuXG52YXIgX2hhc0NsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc0NsYXNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICMgU3RlcCBJbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNldCBvZiBpbmRpY2F0b3JzIHJlcHJlc2VudCBkaWZmZXJlbnQgc3RlcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV3IFN0ZXBJbmRpY2F0b3IoZWwsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBjb21wb25lbnRzL3N0ZXAtaW5kaWNhdG9yLmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIFN0ZXBJbmRpY2F0b3IgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0ZXBJbmRpY2F0b3IsIF9CYXNlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogU3RlcEluZGljYXRvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBTdGVwSW5kaWNhdG9yKGVsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcEluZGljYXRvcik7XG5cbiAgICBpZiAoIShfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcywgZWwsIHBhcmFtcykpLCBfdGhpcykpIHtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2JpbmRFdmVudExpc3RlbmVyQ2FsbGJhY2tzKCk7XG4gICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgX3RoaXMuX2NhbGN1bGF0ZVN0eWxlKCk7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbXBvbmVudCB0byB1c2UgYSBuZXcgZWxlbWVudCBvciByZXBhcnNlIGZyb21cbiAgICogdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgT3B0aW9uYWxcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZWwpIHtcblxuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fY2FjaGVFbGVtZW50cyhlbCB8fCB0aGlzLmVsKTtcbiAgICB0aGlzLl9wYXJzZVBhcmFtcygpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fY2FsY3VsYXRlU3R5bGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWNoZUVsZW1lbnRzID0gZnVuY3Rpb24gX2NhY2hlRWxlbWVudHMoZWwpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jb250YWluZXJFbCA9IHRoaXMuY29udGFpbmVyRWwgfHwgZWwucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib2R5ID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2JvZHknKTtcbiAgICB0aGlzLl9saXN0ID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QnKTtcbiAgICB0aGlzLl9pdGVtcyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLnNwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHBhcmFtZXRlcnMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiBfcGFyc2VQYXJhbXMoKSB7XG4gICAgdGhpcy50eXBlID0gdGhpcy50eXBlICE9PSBudWxsID8gdGhpcy50eXBlIDogdGhpcy5lbC5hdHRyaWJ1dGVzWydkYXRhLXR5cGUnXSAmJiB0aGlzLmVsLmF0dHJpYnV0ZXNbJ2RhdGEtdHlwZSddLnZhbHVlO1xuICAgIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXIgIT09IG51bGwgPyB0aGlzLmhlYWRlciA6IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1oZWFkZXInXSAmJiB0cnVlO1xuICAgIHRoaXMuc3VidGl0bGUgPSB0aGlzLnN1YnRpdGxlICE9PSBudWxsID8gdGhpcy5zdWJ0aXRsZSA6IHRoaXMuZWwuYXR0cmlidXRlc1snZGF0YS1zdWJ0aXRsZSddICYmIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBib3VuZCB2ZXJzaW9ucyBvZiBldmVudCBsaXN0ZW5lciBjYWxsYmFja3MgYW5kIHN0b3JlIHRoZW0uXG4gICAqIE90aGVyd2lzZSB3ZSBjYW4ndCB1bmJpbmQgZnJvbSB0aGVzZSBldmVudHMgbGF0ZXIgYmVjYXVzZSB0aGVcbiAgICogZnVuY3Rpb24gc2lnbmF0dXJlcyB3b24ndCBtYXRjaC5cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBfYmluZEV2ZW50TGlzdGVuZXJDYWxsYmFja3MoKSB7XG4gICAgdGhpcy5fb25SZXNpemVCb3VuZCA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Mb2FkQm91bmQgPSB0aGlzLl9vbkxvYWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblZpc2libGVCb3VuZCA9IHRoaXMuX29uVmlzaWJsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3RvZ2dsZURyb3Bkb3duQm91bmQgPSB0aGlzLl90b2dnbGVEcm9wZG93bi5iaW5kKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZXZlbnQgbGlzdGVuZXJzIGZvciBET00gZXZlbnRzLlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemVCb3VuZCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3BhcmsudmlzaWJsZS1jaGlsZHJlbicsIHRoaXMuX29uVmlzaWJsZUJvdW5kLCB0cnVlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX29uTG9hZEJvdW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgRE9NIGV2ZW50cy4uXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJvdW5kKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzcGFyay52aXNpYmxlLWNoaWxkcmVuJywgdGhpcy5fb25WaXNpYmxlQm91bmQsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fdG9nZ2xlRHJvcGRvd25Cb3VuZCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9vbkxvYWRCb3VuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSBzZWxlY3RlZCBzdGVwIHN0YXRlIGludG8gaW5jb21wbGV0ZVxuICAgKiBAcGFyYW0ge0ludH0gaW5kZXggb2Ygc2VsZWN0ZWQgc3RlcFxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9yZXNldFN0ZXBTdGF0ZSA9IGZ1bmN0aW9uIF9yZXNldFN0ZXBTdGF0ZShzdGVwSW5kZXgpIHtcbiAgICBpZiAoc3RlcEluZGV4IDwgMCB8fCBzdGVwSW5kZXggPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2l0ZW1zW3N0ZXBJbmRleF0sIFsnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWNvbXBsZXRlZCcsICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY3VycmVudCcsICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tZGlzYWJsZWQnXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBzdGVwIHN0YXRlOiBjb21wbGV0ZWQvY3VycmVudC9kaXNhYmxlZC9pbmNvbXBsZXRlXG4gICAqIEZvciBjdXJyZW50IHN0ZXAsIHdpbGwgcmVtb3ZlIGN1cnJlbnQgc3RlcCBmcm9tIG90aGVyIHN0ZXBzXG4gICAqIEBwYXJhbSB7SW50fSBpbmRleCBvZiBzZWxlY3RlZCBzdGVwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSB0byBiZSBzZXRcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5zZXRTdGVwU3RhdGUgPSBmdW5jdGlvbiBzZXRTdGVwU3RhdGUoc3RlcEluZGV4LCBzdGF0ZSkge1xuICAgIGlmIChzdGVwSW5kZXggPCAwIHx8IHN0ZXBJbmRleCA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICB0aGlzLl9yZXNldFN0ZXBTdGF0ZShzdGVwSW5kZXgpO1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tzdGVwSW5kZXhdLCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2l0ZW0tLWNvbXBsZXRlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2N1cnJlbnQnOlxuICAgICAgICB2YXIgY3VycmVudFN0ZXAgPSB0aGlzLl9saXN0LnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY3VycmVudCcpO1xuICAgICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KShjdXJyZW50U3RlcCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1jdXJyZW50Jyk7XG4gICAgICAgICgwLCBfYWRkQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2l0ZW1zW3N0ZXBJbmRleF0sICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY3VycmVudCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgdGhpcy5fcmVzZXRTdGVwU3RhdGUoc3RlcEluZGV4KTtcbiAgICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbc3RlcEluZGV4XSwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1kaXNhYmxlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luY29tcGxldGUnOlxuICAgICAgICB0aGlzLl9yZXNldFN0ZXBTdGF0ZShzdGVwSW5kZXgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fY2FsY3VsYXRlU3R5bGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIG1ldGhvZCB0byBiaW5kIGNsaWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNlcnRhaW4gc3RlcC5cbiAgICogQHBhcmFtIHtBcnJheX0gYSBzZXQgb2Ygc3RlcCBpbmRpY2VzIHJlcHJlc2VudCB0aGUgdGFyZ2V0IG9mIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuYmluZFN0ZXBDbGlja0NhbGxiYWNrID0gZnVuY3Rpb24gYmluZFN0ZXBDbGlja0NhbGxiYWNrKGluZGV4QXJyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleEFycltpXV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgY2xpY2sgY2FsbGJhY2sgZnJvbSBzdGVwc1xuICAgKiBAcGFyYW0ge0FycmF5fSBhIHNldCBvZiBzdGVwIGluZGljZXMgcmVwcmVzZW50IHRoZSB0YXJnZXQgb2YgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICpcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5yZW1vdmVTdGVwQ2xpY2tDYWxsYmFjayA9IGZ1bmN0aW9uIHJlbW92ZVN0ZXBDbGlja0NhbGxiYWNrKGluZGV4QXJyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9pdGVtc1tpbmRleEFycltpXV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXb3JrIGZvciBfY2FsY3VsYXRlU3R5bGUuXG4gICAqIENvbXBhcmluZyB0aGUgd2lkdGggb2YgbGlzdCBhbmQgdG90YWwgaXRlbXMsIGluY2x1ZGluZyBwYWRkaW5nXG4gICAqIFNvbWV0aW1lcyBhZnRlciBjYWxjdWxhdGluZywgZXZlbiBpdGVtVG90YWxXaWR0aCBpcyBiaWdnZXIgMXB4IHRoYW4gbGlzdFdpZHRoLFxuICAgKiBpdCBhbHNvIG1lYW5zIGl0ZW1zIGFyZSBmaXQgaW4gdGhlIGxpc3QsIG5vdCBvdmVyIHdpZHRoLlxuICAgKiBTbyBhZGQgMnB4IHRvIGxpc3Qgd2lkdGggd2hlbiBjb21wYXJpbmcgdG8gYXZvaWQgdGhpcy5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5faXNPdmVyV2lkdGggPSBmdW5jdGlvbiBfaXNPdmVyV2lkdGgoKSB7XG4gICAgdmFyIGxpc3RXaWR0aCA9IHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGl0ZW1Ub3RhbFdpZHRoID0gdGhpcy5fbGlzdFBhZGRpbmdUb3RhbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtVG90YWxXaWR0aCArPSB0aGlzLl9pdGVtc1tpXS5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgaWYgKGxpc3RXaWR0aCArIDIgPCBpdGVtVG90YWxXaWR0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VhdGUgZGlmZmVyZW50IHN0eWxlIGJhc2VkIHNldHRpbmdzXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX2NhbGN1bGF0ZVN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVN0eWxlKCkge1xuICAgIGlmICghdGhpcy5oZWFkZXIpIHtcbiAgICAgIHZhciB0aXRsZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3Bhcmstc3RlcC1pbmRpY2F0b3JfX3RpdGxlJyk7XG4gICAgICB0aXRsZUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9ib2R5LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2JvZHktLW5vLWJvcmRlcicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3VidGl0bGUpIHtcbiAgICAgIHZhciBzdWJ0aXRsZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuc3Bhcmstc3RlcC1pbmRpY2F0b3JfX3N1YnRpdGxlJyk7XG4gICAgICBzdWJ0aXRsZUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzcGVjaWFsIERPTSBhbmQgQ2xhc3Mgb2YgZHJvcGRvd24gdmFyaWF0aW9uXG4gICAgdGhpcy5fc3dpdGNoRnJvbURyb3Bkb3duKCk7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0YW5kYXJkLWRyb3Bkb3duJzpcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUmVzcFN0eWxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGFyZ2UnOlxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVMYXJnZVN0eWxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29uZGVuc2VkJzpcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlQ29uZGVuc2VkU3R5bGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkcm9wZG93bic6XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZURyb3Bkb3duU3R5bGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVTdGFuZGFyZFN0eWxlKCk7XG4gICAgfVxuICAgIC8vIFdvcmsgZm9yIElFMTEsIGRldGVjdCBJRTExIHZpYSB1c2VyQWdlbnRcbiAgICAvLyB1c2VyQWdlbnQ6IE1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMzsgVHJpZGVudC83LjA7IHJ2IDExLjApIGxpa2UgR2Vja29cbiAgICB2YXIgaXNJRTExID0gISEobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC8pICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3J2WyA6XTExLykpO1xuICAgIGlmIChpc0lFMTEpIHtcbiAgICAgIHRoaXMuX2FkZEl0ZW1XaWR0aCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yIElFMTEgT05MWSwgQWRkIHdpZHRoOiAxMDAlIHRvIHdvcmsgYXJvdW5kIElFMTEgYnVnXG4gICAqIElFMTEgd2lsbCBoYXZlIGluY29ycmVjdCBwb3NpdGlvbiB3aXRoIGZsZXgtZ3JvdyBtYXgtd2lkdGggYW5kIGp1c3RpZnktY29udGVudCB3aGVuIGl0ZW1zIGhpdCBtYXgtd2lkdGhcbiAgICogU29tZXRpbWVzIGFmdGVyIGNhbGN1bGF0aW5nLCBldmVuIGl0ZW1Ub3RhbFdpZHRoIGlzIGxlc3MgMXB4IHRoYW4gbGlzdFdpZHRoLFxuICAgKiBpdCBhbHNvIG1lYW5zIGl0ZW1zIGFyZSBmaXQgaW4gdGhlIGxpc3QsIG5vdCBoaXQgdGhlIG1heC13aWR0aFxuICAgKiBTbyBhZGQgMnB4IHRvIGxpc3Qgd2lkdGggd2hlbiBjb21wYXJpbmcgdG8gYXZvaWQgdGhpcy5cbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fYWRkSXRlbVdpZHRoID0gZnVuY3Rpb24gX2FkZEl0ZW1XaWR0aCgpIHtcbiAgICBpZiAoISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2xpc3QsICdzcGFyay1zdGVwLWluZGljYXRvcl9fbGlzdC0tY29uZGVuc2VkJykgJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2JvZHksICdzcGFyay1zdGVwLWluZGljYXRvcl9fYm9keS0tZHJvcGRvd24nKSkge1xuICAgICAgdmFyIGxpc3RXaWR0aCA9IHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgaXRlbVRvdGFsV2lkdGggPSB0aGlzLl9saXN0UGFkZGluZ1RvdGFsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtVG90YWxXaWR0aCArPSB0aGlzLl9pdGVtc1tpXS5vZmZzZXRXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0V2lkdGggLSBpdGVtVG90YWxXaWR0aCA+IDIpIHtcbiAgICAgICAgdGhpcy5fc3dpdGNoV2lkdGhGb3JJZTExKDAsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3dpdGNoV2lkdGhGb3JJZTExKDAsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3dpdGNoV2lkdGhGb3JJZTExKDAsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3aXRjaCBzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbSBzdHlsZSB3aWR0aDogMTAwJSB0byB3b3JrIGFyb3VuZCBJRTExIGJ1Z1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgaW5kZXggb2Ygc3RlcFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgYWRkIHdpZHRoOiAxMDAlXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3N3aXRjaFdpZHRoRm9ySWUxMSA9IGZ1bmN0aW9uIF9zd2l0Y2hXaWR0aEZvckllMTEoaW5kZXgsIHZhbCkge1xuICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9pdGVtc1tpXS5zdHlsZS53aWR0aCA9IHZhbCA/ICcxMDAlJyA6ICcnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRml4IG9uIGxhcmdlIHZhcmlhdGlvblxuICAgKiBDYWxjdWxhdGUgbm9kZSBhbmQgbGlzdCBsZW5ndGggcmVtb3ZlIGNvbm5lY3QgbGluZSBvZiBlYWNoIGVuZFxuICAgKiBTb21ldGltZXMgYWZ0ZXIgY2FsY3VsYXRpbmcsIGV2ZW4gaXRlbVRvdGFsV2lkdGggaXMgYmlnZ2VyIDFweCB0aGFuIGxpc3RXaWR0aCxcbiAgICogaXQgYWxzbyBtZWFucyBpdGVtcyBhcmUgZml0IGluIHRoZSBsaXN0LCBub3Qgb3ZlciB3aWR0aC5cbiAgICogU28gYWRkIDJweCB0byBsaXN0IHdpZHRoIHdoZW4gY29tcGFyaW5nIHRvIGF2b2lkIHRoaXMuXG4gICAqIERlcGVuZGVuY3kgb2YgX2NhbGN1bGF0ZUNvbmRlbnNlZFN0eWxlKCkgYW5kIF9jYWxjdWxhdGVTdGFuZGFyZFN0eWxlKClcbiAgICpcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fY2FsY3VsYXRlTGFyZ2VTdHlsZSA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVMYXJnZVN0eWxlKCkge1xuICAgIHRoaXMuX2xpc3Quc3R5bGVbJ2ZsZXgtd3JhcCddID0gJ3dyYXAnO1xuICAgIHZhciBsaXN0V2lkdGggPSB0aGlzLl9saXN0Lm9mZnNldFdpZHRoO1xuICAgIHZhciBpdGVtVG90YWxXaWR0aCA9IHRoaXMuX2xpc3RQYWRkaW5nVG90YWw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbaV0sICdub2xpbmUnKTtcbiAgICAgIGl0ZW1Ub3RhbFdpZHRoICs9IHRoaXMuX2l0ZW1zW2ldLm9mZnNldFdpZHRoO1xuICAgICAgaWYgKGxpc3RXaWR0aCArIDIgPCBpdGVtVG90YWxXaWR0aCAmJiBpID4gMCkge1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9pdGVtc1tpIC0gMV0sICdub2xpbmUnKTtcbiAgICAgICAgaXRlbVRvdGFsV2lkdGggPSB0aGlzLl9pdGVtc1tpXS5vZmZzZXRXaWR0aCArIHRoaXMuX2xpc3RQYWRkaW5nVG90YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaXggb24gY29uZGVuc2VkIHZhcmlhdGlvblxuICAgKiBTYW1lIGFzIGZpeCBsYXJnZSB2YXJpYXRpb24gZXhjZXB0IENTUyBjbGFzc1xuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVDb25kZW5zZWRTdHlsZSA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVDb25kZW5zZWRTdHlsZSgpIHtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QtLWNvbmRlbnNlZCcpO1xuICAgIHRoaXMuX2NhbGN1bGF0ZUxhcmdlU3R5bGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRml4IG9uIGRyb3Bkb3duIHZhcmlhdGlvblxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVEcm9wZG93blN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZURyb3Bkb3duU3R5bGUoKSB7XG4gICAgdGhpcy5fc3dpdGNoVG9Ecm9wZG93bigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugb25seSBiZXR3ZWVuIGxhcmdlIGFuZCBjb25kZW5zZWQgdmFyaWF0aW9uXG4gICAqIG5vIGRyb3Bkb3duIHZhcmlhdGlvblxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9jYWxjdWxhdGVTdGFuZGFyZFN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVN0YW5kYXJkU3R5bGUoKSB7XG4gICAgdGhpcy5fbGlzdC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbaV0sICdub2xpbmUnKTtcbiAgICB9XG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKTtcbiAgICBpZiAodGhpcy5faXNPdmVyV2lkdGgoKSkge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKTtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUxhcmdlU3R5bGUoKTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGxpc3QgaW52aXNpYmxlIGFuZCBjaGFuZ2UgaXQgaW50byBsYXJnZSB2YXJpYXRpb24gYXQgZmlyc3QuXG4gICAqIFN3aXRjaCB2YXJpYXRpb24gZnJvbSB0b3AgdG8gYm90dG9tIHRvIGZpbmQgdGhlIGZpdCBvbmVcbiAgICovXG5cblxuICBTdGVwSW5kaWNhdG9yLnByb3RvdHlwZS5fY2FsY3VsYXRlUmVzcFN0eWxlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVJlc3BTdHlsZSgpIHtcbiAgICB0aGlzLl9saXN0LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QtLWNvbmRlbnNlZCcpO1xuICAgIGlmICh0aGlzLl9pc092ZXJXaWR0aCgpKSB7XG4gICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xpc3QtLWNvbmRlbnNlZCcpO1xuICAgICAgaWYgKHRoaXMuX2lzT3ZlcldpZHRoKCkpIHtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19saXN0LS1jb25kZW5zZWQnKTtcbiAgICAgICAgdGhpcy5fc3dpdGNoVG9Ecm9wZG93bigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9saXN0LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBoZWFkZXIgZWxlbWVudCBmb3IgZHJvcGRvd24gdmFyaWF0aW9uXG4gICAqIFRyeSB0byBmaW5kIHRoZSBjdXJyZW50IHN0ZXAgb2YgaW5kaWNhdG9yIGFuZCBzaG93IGl0IG9uIHRoZSBoZWFkZXJcbiAgICogaWYgbm90IGZvdW5kLCBzaG93IHRoZSBmaXJzdCBzdGVwXG4gICAqIEByZXR1cm4ge09iamVjdH0gaGVhZGVyIGVsZW1lbnQgb2YgZHJvcGRvd24gdmFyaWF0aW9uXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX2NyZWF0ZURyb3Bkb3duSGVhZGVyID0gZnVuY3Rpb24gX2NyZWF0ZURyb3Bkb3duSGVhZGVyKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgY3VycmVudFN0ZXAgPSB0aGlzLl9saXN0LnF1ZXJ5U2VsZWN0b3IoJy5zcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY3VycmVudCcpO1xuICAgIC8vIENhbiBub3QgZmluZCBjdXJyZW50IHN0ZXBcbiAgICBpZiAoIWN1cnJlbnRTdGVwKSB7XG4gICAgICBjdXJyZW50U3RlcCA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgIH1cbiAgICBlbC5pbm5lckhUTUwgPSBjdXJyZW50U3RlcC5pbm5lckhUTUw7XG4gICAgZWwuaW5uZXJIVE1MICs9ICc8c3BhbiBjbGFzcz1cInNwYXJrLXN0ZXAtaW5kaWNhdG9yX19ub3RpY2VcIj5TZWxlY3QgYSBTdGVwPC9zcGFuPic7XG5cbiAgICAvLyBDcmVhdGUgbGFiZWwgZWxlbWVudCBsaWtlICcyIG9mIDcnXG4gICAgdmFyIHN0ZXBOb3RpY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5faXRlbXMsIGN1cnJlbnRTdGVwKTtcbiAgICBzdGVwTm90aWNlLmlubmVySFRNTCA9IGN1cnJlbnRJbmRleCArIDEgKyAnIG9mICcgKyB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgc3RlcE5vdGljZS5jbGFzc05hbWUgPSAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2xhYmVsLS1kcm9wZG93bic7XG5cbiAgICBlbC5hcHBlbmRDaGlsZChzdGVwTm90aWNlKTtcbiAgICBlbC5jbGFzc05hbWUgPSBjdXJyZW50U3RlcC5jbGFzc05hbWU7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkoZWwsICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tZHJvcGRvd25fX2hlYWRlcicpO1xuICAgIHRoaXMuX2Ryb3Bkb3duSGVhZGVyID0gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvbWUgZXh0cmEgZXZlbnQgYmluZGVyIGFuZCBET00gb2YgZHJvcGRvd24gdmFyaWF0aW9uIG5lZWQgdG8gYmUgc2V0XG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3N3aXRjaFRvRHJvcGRvd24gPSBmdW5jdGlvbiBfc3dpdGNoVG9Ecm9wZG93bigpIHtcbiAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9ib2R5LCAnc3Bhcmstc3RlcC1pbmRpY2F0b3JfX2JvZHktLWRyb3Bkb3duJyk7XG4gICAgdGhpcy5fY3JlYXRlRHJvcGRvd25IZWFkZXIoKTtcbiAgICB0aGlzLl9saXN0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX2Ryb3Bkb3duSGVhZGVyLCB0aGlzLl9saXN0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX3RvZ2dsZURyb3Bkb3duQm91bmQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fdG9nZ2xlRHJvcGRvd25Cb3VuZCk7XG4gICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ2NvbGxhcHNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBleHRyYSBldmVudCBhbmQgRE9NIHdoZW4gc3dpdGNoIHZhcmlhdGlvbiBmcm9tIGRyb3Bkb3duXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3N3aXRjaEZyb21Ecm9wZG93biA9IGZ1bmN0aW9uIF9zd2l0Y2hGcm9tRHJvcGRvd24oKSB7XG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fYm9keSwgJ3NwYXJrLXN0ZXAtaW5kaWNhdG9yX19ib2R5LS1kcm9wZG93bicpO1xuICAgIHZhciBoZWFkZXIgPSB0aGlzLl9saXN0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLnNwYXJrLXN0ZXAtaW5kaWNhdG9yX19pdGVtLS1kcm9wZG93bl9faGVhZGVyJyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl90b2dnbGVEcm9wZG93bkJvdW5kKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICB0aGlzLl9saXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGVhZGVyKTtcbiAgICB9XG4gICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ2NvbGxhcHNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBjb2xsYXBzZS9leHBhbmQgc3RhdGUgb2Ygc3RlcCBsaXN0IGluIGRyb3Bkb3duIHZhcmlhdGlvblxuICAgKiBJZiB0aGVyZSBpcyBhIHNjcm9sbCBpbiBkcm9wZG93biB2YXJpYXRpb24sIHNjcm9sbCB0byAnY3VycmVudCcgbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gUmVmZXJlbmNlIG9mIERPTSBvYmpcbiAgICogQHBhcmFtIHtPYmplY3R9IEV2ZW50IG9mIGNsaWNrXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX3RvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gX3RvZ2dsZURyb3Bkb3duKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGlmICh0aGlzLl9kcm9wZG93bkhlYWRlci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBpZiAoIXRoaXMuX2Ryb3Bkb3duRXhwYW5kKSB7XG4gICAgICAgICgwLCBfcmVtb3ZlQ2xhc3MyLmRlZmF1bHQpKHRoaXMuX2xpc3QsICdjb2xsYXBzZScpO1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9kcm9wZG93bkhlYWRlciwgJ2V4cGFuZCcpO1xuICAgICAgICB0aGlzLl9kcm9wZG93bkV4cGFuZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX2FkZENsYXNzMi5kZWZhdWx0KSh0aGlzLl9saXN0LCAnY29sbGFwc2UnKTtcbiAgICAgICAgKDAsIF9yZW1vdmVDbGFzczIuZGVmYXVsdCkodGhpcy5fZHJvcGRvd25IZWFkZXIsICdleHBhbmQnKTtcbiAgICAgICAgdGhpcy5fZHJvcGRvd25FeHBhbmQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKDAsIF9hZGRDbGFzczIuZGVmYXVsdCkodGhpcy5fbGlzdCwgJ2NvbGxhcHNlJyk7XG4gICAgICAoMCwgX3JlbW92ZUNsYXNzMi5kZWZhdWx0KSh0aGlzLl9kcm9wZG93bkhlYWRlciwgJ2V4cGFuZCcpO1xuICAgICAgdGhpcy5fZHJvcGRvd25FeHBhbmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpc3Qub2Zmc2V0SGVpZ2h0ID4gMCkge1xuICAgICAgdmFyIHNjcm9sbE1vdmUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKDAsIF9oYXNDbGFzczIuZGVmYXVsdCkodGhpcy5faXRlbXNbaV0sICdzcGFyay1zdGVwLWluZGljYXRvcl9faXRlbS0tY3VycmVudCcpKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdC5zY3JvbGxUb3AgPSBzY3JvbGxNb3ZlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbE1vdmUgKz0gdGhpcy5faXRlbXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGZpbmlzaCBsb2FkaW5nXG4gICAqL1xuXG5cbiAgU3RlcEluZGljYXRvci5wcm90b3R5cGUuX29uTG9hZCA9IGZ1bmN0aW9uIF9vbkxvYWQoKSB7XG4gICAgLy8gQ2FjaGUgbGlzdCBsZWZ0ICsgcmlnaHQgcGFkZGluZyBmb3Igd2lkdGggY2FsY3VsYXRpbmdcbiAgICB2YXIgbGlzdFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fbGlzdCk7XG4gICAgdmFyIGxpc3RQYWRkaW5nTGVmdCA9IHBhcnNlSW50KGxpc3RTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0JyksIDEwKTtcbiAgICB2YXIgbGlzdFBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGxpc3RTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpLCAxMCk7XG4gICAgdGhpcy5fbGlzdFBhZGRpbmdUb3RhbCA9IGxpc3RQYWRkaW5nTGVmdCArIGxpc3RQYWRkaW5nUmlnaHQ7XG4gICAgdGhpcy5fY2FsY3VsYXRlU3R5bGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWQsIGJhc2Ugb24gcGFyYW1zIG1ha2Ugc29tZSByZXBvbnNpdmUgY2hhbmdlLlxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZSgpIHtcbiAgICB0aGlzLl9jYWxjdWxhdGVTdHlsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgcGFyZW50IGNvbnRhaW5lciBzaG93cyBpdHMgY2hpbGRyZW4gYW5kIG91ciBlbGVtZW50XG4gICAqIGlzIGluc2lkZSBvZiBpdCwgcmVzaXplXG4gICAqIEBwYXJhbSAge09iamVjdH0gZVxuICAgKi9cblxuXG4gIFN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl9vblZpc2libGUgPSBmdW5jdGlvbiBfb25WaXNpYmxlKGUpIHtcbiAgICBpZiAoZS50YXJnZXQuY29udGFpbnModGhpcy5lbCkpIHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3R5bGUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdGVwSW5kaWNhdG9yO1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbi8qKlxuICogV2hpdGVsaXN0ZWQgcGFyYW1ldGVycyB3aGljaCBjYW4gYmUgc2V0IG9uIGNvbnN0cnVjdGlvbi5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuXG5cblN0ZXBJbmRpY2F0b3IucHJvdG90eXBlLl93aGl0ZWxpc3RlZFBhcmFtcyA9IFsndHlwZScsICdoZWFkZXInLCAnc3VidGl0bGUnXTtcblxuLyoqXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgaW50ZXJuYWwgcHJvcGVydGllcyB3ZSB3aWxsIGJlIHNldHRpbmcuXG4gKiBUaGVzZSBhcmUgc2V0IG9uIGVhY2ggY29uc3RydWN0aW9uIHNvIHdlIGRvbid0IGxlYWsgcHJvcGVydGllc1xuICogaW50byB0aGUgcHJvdG90eXBlIGNoYWluLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuU3RlcEluZGljYXRvci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGVsOiBudWxsLFxuICBjb250YWluZXJFbDogbnVsbCxcbiAgaGVhZGVyOiBudWxsLFxuICBzdWJ0aXRsZTogbnVsbCxcbiAgdHlwZTogbnVsbCxcbiAgX2JvZHk6IG51bGwsXG4gIF9saXN0OiBudWxsLFxuICBfbGlzdFBhZGRpbmdUb3RhbDogMCxcbiAgX2Ryb3Bkb3duRXhwYW5kOiBmYWxzZSxcbiAgX2Ryb3Bkb3duSGVhZGVyOiBudWxsLFxuICBfaXRlbXM6IG51bGwsXG4gIF9vblJlc2l6ZUJvdW5kOiBudWxsLFxuICBfb25WaXNpYmxlQm91bmQ6IG51bGxcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0ZXBJbmRpY2F0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZXAtaW5kaWNhdG9yLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG52YXIgX2hhc0NsYXNzID0gcmVxdWlyZSgnLi9oYXMtY2xhc3MnKTtcblxudmFyIF9oYXNDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNDbGFzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogIyBBZGQgQ2xhc3NcbiAqIEFkZCBhIGNsYXNzIG9uIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbCBBbiBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vYWRkLWNsYXNzLmpzXG4gKi9cblxudmFyIHdzID0gL1xccysvO1xudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZVswXSk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIHZhciB0b0FkZCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gbmFtZS5sZW5ndGg7XG4gIHZhciBpdGVtID0gdm9pZCAwO1xuICB2YXIgY2xzTmFtZSA9IHR5cGVvZiBlbC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gZWwuY2xhc3NOYW1lIDogZWwuZ2V0QXR0cmlidXRlID8gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIDogJyc7XG5cbiAgLy8gc2VlIGlmIHdlIGhhdmUgYW55dGhpbmcgdG8gYWRkXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgaXRlbSA9IG5hbWVbaV07XG4gICAgaWYgKGl0ZW0gJiYgISgwLCBfaGFzQ2xhc3MyLmRlZmF1bHQpKGNsc05hbWUsIGl0ZW0pKSB7XG4gICAgICB0b0FkZC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9ICgwLCBfdHJpbTIuZGVmYXVsdCkoKGNsc05hbWUgKyAnICcgKyB0b0FkZC5qb2luKCcgJykpLnJlcGxhY2UoY2xlYW51cCwgJyAnKSk7XG4gICAgfSBlbHNlIGlmIChlbC5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoMCwgX3RyaW0yLmRlZmF1bHQpKChjbHNOYW1lICsgJyAnICsgdG9BZGQuam9pbignICcpKS5yZXBsYWNlKGNsZWFudXAsICcgJykpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENsYXNzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtY2xhc3MuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyoqXG4gKiAjIEhhcyBDbGFzc1xuICogU2VlIGlmIGFuIGVsZW1lbnQgaGFzIGEgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICpcbiAqIEBtb2R1bGUgaGVscGVycy9kb20vaGFzLWNsYXNzLmpzXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XG4gIHZhciBjTmFtZSA9ICgodHlwZW9mIGVsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihlbCkpID09PSAnb2JqZWN0JyA/IGVsLmNsYXNzTmFtZSB8fCBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnIDogZWwgfHwgJycpLnJlcGxhY2UoL1tcXHRcXHJcXG5cXGZdL2csICcgJyk7XG4gIHJldHVybiAoJyAnICsgY05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgbmFtZSArICcgJykgIT09IC0xO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBoYXNDbGFzcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWNsYXNzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyaW0gPSByZXF1aXJlKCcuLi91dGlsL3RyaW0nKTtcblxudmFyIF90cmltMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyaW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd3MgPSAvXFxzKy87IC8qKlxuICAgICAgICAgICAgICAgICAqICMgUmVtb3ZlIENsYXNzXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlIGEgY2xhc3Mgb24gYW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWwgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cyB0byB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQG1vZHVsZSBoZWxwZXJzL2RvbS9yZW1vdmUtY2xhc3MuanNcbiAgICAgICAgICAgICAgICAgKi9cblxudmFyIGNsZWFudXAgPSAvXFxzezIsfS9nO1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSAoMCwgX3RyaW0yLmRlZmF1bHQpKG5hbWUpLnNwbGl0KHdzKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gbmFtZSBpbnN0YW5jZW9mIEFycmF5ID8gbmFtZSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIH1cblxuICAvLyBvcHRpbWl6ZSBmb3IgYmVzdCwgbW9zdCBjb21tb24gY2FzZVxuICBpZiAobmFtZS5sZW5ndGggPT09IDEgJiYgZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKG5hbWVbMF0pIGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZVswXSk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLy8gc3RvcmUgdHdvIGNvcGllc1xuICB2YXIgY2xzTmFtZSA9ICcgJyArICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6IGVsLmdldEF0dHJpYnV0ZSA/IGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA6ICcnKSArICcgJztcbiAgdmFyIHJlc3VsdCA9IGNsc05hbWU7XG4gIHZhciBjdXJyZW50ID0gdm9pZCAwO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjdXJyZW50ID0gbmFtZVtpXTtcbiAgICBzdGFydCA9IGN1cnJlbnQgPyByZXN1bHQuaW5kZXhPZignICcgKyBjdXJyZW50ICsgJyAnKSA6IC0xO1xuICAgIGlmIChzdGFydCAhPT0gLTEpIHtcbiAgICAgIHN0YXJ0ICs9IDE7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgc3RhcnQpICsgcmVzdWx0LnNsaWNlKHN0YXJ0ICsgY3VycmVudC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9ubHkgd3JpdGUgaWYgbW9kaWZpZWRcbiAgaWYgKGNsc05hbWUgIT09IHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWwuY2xhc3NOYW1lID0gKDAsIF90cmltMi5kZWZhdWx0KShyZXN1bHQucmVwbGFjZShjbGVhbnVwLCAnICcpKTtcbiAgICB9IGVsc2UgaWYgKGVsLnNldEF0dHJpYnV0ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICgwLCBfdHJpbTIuZGVmYXVsdCkocmVzdWx0LnJlcGxhY2UoY2xlYW51cCwgJyAnKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS1jbGFzcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBFYWNoXG4gKiBBcHBseSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBhbnkga2luZDogQXJyYXksIE5vZGVMaXN0LCBIVE1MQ29sbGVjdGlvbiBvciBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheXxOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbnxPYmplY3R9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKlxuICogQGV4YW1wbGVcbiAqIGVhY2goW10sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAqIGVhY2goZWwuY2hpbGROb2RlcywgY2FsbGJhY2spO1xuICogZWFjaCh7fSwgY2FsbGJhY2spO1xuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL2VhY2guanNcbiAqL1xuZnVuY3Rpb24gZWFjaChsaXN0LCBjYikge1xuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYGVhY2hgIHdpdGhvdXQgYSBjYWxsYmFjayEnKTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIC8vIE9iamVjdFxuICBpZiAobGVuID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGkgaW4gbGlzdCkge1xuICAgICAgaWYgKGkgIT09ICdwcm90b3R5cGUnICYmIGxpc3QuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgY2IoaSwgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFycmF5LWxpa2VcbiAgZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNiKGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZWFjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFjaC5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogIyBUcmltXG4gKiBUcmltIHdoaXRlc3BhY2Ugb24gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICpcbiAqIEBtb2R1bGUgaGVscGVycy91dGlsL3RyaW0uanNcbiAqL1xuXG52YXIgdHJpbVJFID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodHJpbVJFLCAnJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHRyaW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW0uanMubWFwXG4iXX0="}